name: Create Release

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version increment type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
      create_tag:
        description: 'Create and push tag automatically'
        required: true
        type: boolean
        default: true
      skip_ci_check:
        description: 'Skip CI check (use only if CI already passed)'
        required: false
        type: boolean
        default: false

env:
  CARGO_TERM_COLOR: always

jobs:
  calculate-version:
    name: Calculate Next Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get current version
        id: current_version
        run: |
          # Try to get latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LATEST_TAG" ]; then
            # No tags found, use version from Cargo.toml
            CURRENT_VERSION=$(grep '^version =' Cargo.toml | cut -d'"' -f2 | cut -d'-' -f1)
            echo "No tags found, using version from Cargo.toml: ${CURRENT_VERSION}"
          else
            # Extract version from tag (remove 'v' prefix)
            CURRENT_VERSION=${LATEST_TAG#v}
            echo "Latest tag: ${LATEST_TAG}, version: ${CURRENT_VERSION}"
          fi
          
          echo "version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT

      - name: Calculate next version
        id: version
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.version }}"
          VERSION_TYPE="${{ github.event.inputs.version_type }}"
          
          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Remove any pre-release suffix
          PATCH=$(echo "$PATCH" | cut -d'-' -f1)
          
          # Increment based on type
          case "$VERSION_TYPE" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
            *)
              echo "Error: Invalid version type: $VERSION_TYPE"
              exit 1
              ;;
          esac
          
          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          NEW_TAG="v${NEW_VERSION}"
          
          echo "Current version: ${CURRENT_VERSION}"
          echo "Version type: ${VERSION_TYPE}"
          echo "New version: ${NEW_VERSION}"
          echo "New tag: ${NEW_TAG}"
          
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "tag=${NEW_TAG}" >> $GITHUB_OUTPUT

      - name: Verify tag doesn't exist
        run: |
          NEW_TAG="${{ steps.version.outputs.tag }}"
          if git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
            echo "Error: Tag ${NEW_TAG} already exists"
            exit 1
          fi
          echo "Tag ${NEW_TAG} is available"

  check-ci:
    name: Check CI Status
    if: github.event.inputs.skip_ci_check != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check latest CI workflow run
        id: ci_check
        uses: actions/github-script@v7
        with:
          script: |
            const { data: workflows } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ci.yml',
              branch: 'main',
              per_page: 1
            });
            
            if (workflows.workflow_runs.length === 0) {
              core.setFailed('No CI workflow runs found');
              return;
            }
            
            const latestRun = workflows.workflow_runs[0];
            const conclusion = latestRun.conclusion;
            const status = latestRun.status;
            
            console.log(`Latest CI run: ${latestRun.id}, status: ${status}, conclusion: ${conclusion}`);
            
            if (status !== 'completed') {
              core.setFailed(`CI workflow is still running (status: ${status})`);
              return;
            }
            
            if (conclusion !== 'success') {
              core.setFailed(`CI workflow did not succeed (conclusion: ${conclusion}). Please ensure CI passes before creating a release.`);
              return;
            }
            
            console.log('✅ CI workflow passed successfully');
            core.setOutput('ci_passed', 'true');

  check-code-quality:
    name: Check Code Quality Status
    if: github.event.inputs.skip_ci_check != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check latest Code Quality workflow run
        id: code_quality_check
        uses: actions/github-script@v7
        with:
          script: |
            const { data: workflows } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'code-quality.yml',
              branch: 'main',
              per_page: 1
            });
            
            if (workflows.workflow_runs.length === 0) {
              core.setFailed('No Code Quality workflow runs found');
              return;
            }
            
            const latestRun = workflows.workflow_runs[0];
            const conclusion = latestRun.conclusion;
            const status = latestRun.status;
            
            console.log(`Latest Code Quality run: ${latestRun.id}, status: ${status}, conclusion: ${conclusion}`);
            
            if (status !== 'completed') {
              core.setFailed(`Code Quality workflow is still running (status: ${status})`);
              return;
            }
            
            if (conclusion !== 'success') {
              core.setFailed(`Code Quality workflow did not succeed (conclusion: ${conclusion}). Please ensure Code Quality passes before creating a release.`);
              return;
            }
            
            console.log('✅ Code Quality workflow passed successfully');
            core.setOutput('code_quality_passed', 'true');

  prepare-release:
    name: Prepare Release
    needs: [calculate-version, check-ci, check-code-quality]
    # Run if: calculate-version succeeded AND (both checks succeeded OR were skipped OR skip_ci_check is true)
    if: |
      needs.calculate-version.result == 'success' && 
      (needs.check-ci.result == 'success' || needs.check-ci.result == 'skipped' || github.event.inputs.skip_ci_check == 'true') &&
      (needs.check-code-quality.result == 'success' || needs.check-code-quality.result == 'skipped' || github.event.inputs.skip_ci_check == 'true')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: main

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update version in Cargo.toml
        run: |
          NEW_VERSION="${{ needs.calculate-version.outputs.version }}"
          sed -i "s/^version = \".*\"/version = \"${NEW_VERSION}\"/" Cargo.toml
          
          echo "Updated Cargo.toml:"
          grep '^version =' Cargo.toml

      - name: Commit version change
        if: github.event.inputs.create_tag == 'true'
        run: |
          NEW_VERSION="${{ needs.calculate-version.outputs.version }}"
          
          git add Cargo.toml
          git commit -m "chore: bump version to ${NEW_VERSION}" || exit 0
          git push origin main
          
          echo "Pushed version bump commit to main"

      - name: Create and push tag
        if: github.event.inputs.create_tag == 'true'
        run: |
          NEW_VERSION="${{ needs.calculate-version.outputs.version }}"
          NEW_TAG="${{ needs.calculate-version.outputs.tag }}"
          
          # Verify tag doesn't exist locally or remotely
          if git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
            echo "Error: Tag ${NEW_TAG} already exists locally"
            exit 1
          fi
          
          git tag -a "$NEW_TAG" -m "Release ${NEW_VERSION}"
          git push origin "$NEW_TAG"
          
          echo "✅ Created and pushed tag: ${NEW_TAG}"
          echo "The release workflow will now be triggered automatically"

      - name: Create Release Summary
        run: |
          NEW_VERSION="${{ needs.calculate-version.outputs.version }}"
          NEW_TAG="${{ needs.calculate-version.outputs.tag }}"
          VERSION_TYPE="${{ github.event.inputs.version_type }}"
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Release ${NEW_VERSION} Created
          
          - **Version**: ${NEW_VERSION}
          - **Tag**: ${NEW_TAG}
          - **Type**: ${VERSION_TYPE}
          - **Created by**: ${{ github.actor }}
          
          The release workflow will now build and publish the release artifacts.
          
          [View Release Workflow](https://github.com/${{ github.repository }}/actions/workflows/release.yml)
          EOF
          
      - name: Wait for release workflow
        if: github.event.inputs.create_tag == 'true'
        run: |
          echo "⏳ Waiting for release workflow to start..."
          echo "The release workflow should start automatically after the tag is pushed."
          echo "You can monitor it at: https://github.com/${{ github.repository }}/actions/workflows/release.yml"
