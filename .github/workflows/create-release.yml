name: Create Release

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version increment type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
      create_tag:
        description: 'Create and push tag automatically'
        required: true
        type: boolean
        default: true

env:
  CARGO_TERM_COLOR: always

jobs:
  calculate-version:
    name: Calculate Next Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get current version
        id: current_version
        run: |
          # Try to get latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LATEST_TAG" ]; then
            # No tags found, use version from Cargo.toml
            CURRENT_VERSION=$(grep '^version =' Cargo.toml | cut -d'"' -f2 | cut -d'-' -f1)
            echo "No tags found, using version from Cargo.toml: ${CURRENT_VERSION}"
          else
            # Extract version from tag (remove 'v' prefix)
            CURRENT_VERSION=${LATEST_TAG#v}
            echo "Latest tag: ${LATEST_TAG}, version: ${CURRENT_VERSION}"
          fi
          
          echo "version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT

      - name: Calculate next version
        id: version
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.version }}"
          VERSION_TYPE="${{ github.event.inputs.version_type }}"
          
          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Remove any pre-release suffix
          PATCH=$(echo "$PATCH" | cut -d'-' -f1)
          
          # Increment based on type
          case "$VERSION_TYPE" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
            *)
              echo "Error: Invalid version type: $VERSION_TYPE"
              exit 1
              ;;
          esac
          
          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          NEW_TAG="v${NEW_VERSION}"
          
          echo "Current version: ${CURRENT_VERSION}"
          echo "Version type: ${VERSION_TYPE}"
          echo "New version: ${NEW_VERSION}"
          echo "New tag: ${NEW_TAG}"
          
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "tag=${NEW_TAG}" >> $GITHUB_OUTPUT

      - name: Verify tag doesn't exist
        run: |
          NEW_TAG="${{ steps.version.outputs.tag }}"
          if git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
            echo "Error: Tag ${NEW_TAG} already exists"
            exit 1
          fi
          echo "Tag ${NEW_TAG} is available"

  prepare-release:
    name: Prepare Release
    needs: calculate-version
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.ref == 'refs/heads/main' && 'main' || github.ref == 'refs/heads/master' && 'master' || 'main' }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update version in Cargo.toml
        run: |
          NEW_VERSION="${{ needs.calculate-version.outputs.version }}"
          sed -i "s/^version = \".*\"/version = \"${NEW_VERSION}\"/" Cargo.toml
          
          echo "Updated Cargo.toml:"
          grep '^version =' Cargo.toml

      - name: Run tests
        uses: dtolnay/rust-toolchain@stable
        run: |
          cargo test --quiet || {
            echo "Error: Tests failed"
            exit 1
          }

      - name: Check formatting
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt
        run: |
          cargo fmt --all -- --check || {
            echo "Error: Code is not properly formatted"
            exit 1
          }

      - name: Run clippy
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy
        run: |
          cargo clippy -- -D warnings || {
            echo "Error: Clippy found issues"
            exit 1
          }

      - name: Determine branch name
        id: branch
        run: |
          # Try to get branch from ref, fallback to main
          if [ "${{ github.ref }}" = "refs/heads/main" ] || [ "${{ github.ref }}" = "refs/heads/master" ]; then
            BRANCH="${{ github.ref_name }}"
          else
            # For workflow_dispatch, default to main
            BRANCH="main"
            # Try to checkout main if we're not on it
            git checkout main 2>/dev/null || git checkout master 2>/dev/null || true
          fi
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "Using branch: ${BRANCH}"

      - name: Commit version change
        if: github.event.inputs.create_tag == 'true'
        run: |
          NEW_VERSION="${{ needs.calculate-version.outputs.version }}"
          BRANCH_NAME="${{ steps.branch.outputs.branch }}"
          
          git add Cargo.toml
          git commit -m "chore: bump version to ${NEW_VERSION}" || exit 0
          git push origin "${BRANCH_NAME}"
          
          echo "Pushed version bump commit to ${BRANCH_NAME}"

      - name: Create and push tag
        if: github.event.inputs.create_tag == 'true'
        run: |
          NEW_VERSION="${{ needs.calculate-version.outputs.version }}"
          NEW_TAG="${{ needs.calculate-version.outputs.tag }}"
          
          # Verify tag doesn't exist locally or remotely
          if git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
            echo "Error: Tag ${NEW_TAG} already exists locally"
            exit 1
          fi
          
          git tag -a "$NEW_TAG" -m "Release ${NEW_VERSION}"
          git push origin "$NEW_TAG"
          
          echo "✅ Created and pushed tag: ${NEW_TAG}"
          echo "The release workflow will now be triggered automatically"

      - name: Create Release Summary
        run: |
          NEW_VERSION="${{ needs.calculate-version.outputs.version }}"
          NEW_TAG="${{ needs.calculate-version.outputs.tag }}"
          VERSION_TYPE="${{ github.event.inputs.version_type }}"
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Release ${NEW_VERSION} Created
          
          - **Version**: ${NEW_VERSION}
          - **Tag**: ${NEW_TAG}
          - **Type**: ${VERSION_TYPE}
          - **Created by**: ${{ github.actor }}
          
          The release workflow will now build and publish the release artifacts.
          
          [View Release Workflow](https://github.com/${{ github.repository }}/actions/workflows/release.yml)
          EOF
          
      - name: Wait for release workflow
        if: github.event.inputs.create_tag == 'true'
        run: |
          echo "⏳ Waiting for release workflow to start..."
          echo "The release workflow should start automatically after the tag is pushed."
          echo "You can monitor it at: https://github.com/${{ github.repository }}/actions/workflows/release.yml"
