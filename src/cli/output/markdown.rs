//! Markdown report output

use anyhow::Result;
use chrono::Utc;

use super::ReportRenderer;
use crate::rules::results::{AuditResults, Severity};

pub struct MarkdownReport {
    detailed: bool,
}

impl MarkdownReport {
    pub fn new(detailed: bool) -> Self {
        Self { detailed }
    }
}

impl ReportRenderer for MarkdownReport {
    fn render_report(&self, results: &AuditResults) -> Result<String> {
        let mut output = String::new();

        // Header
        output.push_str(&format!(
            "# RepoLens Audit Report\n\n\
             **Repository:** {}\n\
             **Preset:** {}\n\
             **Generated:** {}\n\
             **RepoLens Version:** {}\n\n",
            results.repository_name,
            results.preset,
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            env!("CARGO_PKG_VERSION")
        ));

        // Summary
        output.push_str("## Summary\n\n");
        output.push_str("| Severity | Count |\n");
        output.push_str("|----------|-------|\n");
        output.push_str(&format!(
            "| Critical | {} |\n",
            results.count_by_severity(Severity::Critical)
        ));
        output.push_str(&format!(
            "| Warning | {} |\n",
            results.count_by_severity(Severity::Warning)
        ));
        output.push_str(&format!(
            "| Info | {} |\n\n",
            results.count_by_severity(Severity::Info)
        ));

        // Critical findings
        let critical: Vec<_> = results.findings_by_severity(Severity::Critical).collect();
        if !critical.is_empty() {
            output.push_str("## Critical Issues\n\n");
            output.push_str("These issues must be resolved before proceeding.\n\n");
            for finding in critical {
                output.push_str(&format!("### {} - {}\n\n", finding.rule_id, finding.message));
                if let Some(location) = &finding.location {
                    output.push_str(&format!("**Location:** `{}`\n\n", location));
                }
                if self.detailed {
                    if let Some(description) = &finding.description {
                        output.push_str(&format!("{}\n\n", description));
                    }
                    if let Some(remediation) = &finding.remediation {
                        output.push_str(&format!("**Remediation:** {}\n\n", remediation));
                    }
                }
            }
        }

        // Warning findings
        let warnings: Vec<_> = results.findings_by_severity(Severity::Warning).collect();
        if !warnings.is_empty() {
            output.push_str("## Warnings\n\n");
            output.push_str("These issues should be addressed.\n\n");
            for finding in warnings {
                output.push_str(&format!("### {} - {}\n\n", finding.rule_id, finding.message));
                if let Some(location) = &finding.location {
                    output.push_str(&format!("**Location:** `{}`\n\n", location));
                }
                if self.detailed {
                    if let Some(description) = &finding.description {
                        output.push_str(&format!("{}\n\n", description));
                    }
                    if let Some(remediation) = &finding.remediation {
                        output.push_str(&format!("**Remediation:** {}\n\n", remediation));
                    }
                }
            }
        }

        // Info findings
        let info: Vec<_> = results.findings_by_severity(Severity::Info).collect();
        if !info.is_empty() && self.detailed {
            output.push_str("## Informational\n\n");
            output.push_str("These are suggestions for improvement.\n\n");
            for finding in info {
                output.push_str(&format!("- **{}**: {}\n", finding.rule_id, finding.message));
            }
            output.push('\n');
        }

        // Footer
        output.push_str("---\n\n");
        output.push_str("*Report generated by [RepoLens](https://github.com/kdelfour/repolens)*\n");

        Ok(output)
    }
}
