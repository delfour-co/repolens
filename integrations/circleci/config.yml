# =============================================================================
# RepoLens CircleCI Integration Template
# =============================================================================
#
# This template provides a ready-to-use CircleCI configuration for running
# RepoLens audits on your repository.
#
# USAGE:
# 1. Copy this file to `.circleci/config.yml` in your repository
# 2. Customize the parameters and settings as needed
# 3. Commit and push to trigger the pipeline
#
# REQUIREMENTS:
# - CircleCI project connected to your repository
# - Docker executor support (default)
#
# =============================================================================

version: 2.1

# =============================================================================
# Orb-style Commands and Executors
# =============================================================================
# These reusable components follow CircleCI orb patterns for easy customization.

# Parameters for customizing the audit
parameters:
  repolens-version:
    type: string
    default: "latest"
    description: "RepoLens version to install"
  repolens-preset:
    type: string
    default: "opensource"
    description: "Audit preset (opensource, enterprise, strict)"
  repolens-format:
    type: string
    default: "json"
    description: "Output format (terminal, json, sarif, markdown, html)"
  repolens-fail-on:
    type: string
    default: "critical"
    description: "Fail on severity level (critical, high, medium, low, none)"

# Reusable executors
executors:
  # Docker executor with RepoLens image
  repolens-docker:
    docker:
      - image: ghcr.io/delfour-co/repolens:<< pipeline.parameters.repolens-version >>
    working_directory: ~/project

  # Generic Linux executor for binary installation
  linux:
    docker:
      - image: cimg/base:stable
    working_directory: ~/project

# Reusable commands
commands:
  # Install RepoLens binary
  install-repolens:
    description: "Download and install RepoLens binary"
    parameters:
      version:
        type: string
        default: "latest"
    steps:
      - run:
          name: Install RepoLens
          command: |
            VERSION="<< parameters.version >>"
            if [ "${VERSION}" = "latest" ]; then
              VERSION=$(curl -s https://api.github.com/repos/delfour-co/cli--repolens/releases/latest | grep '"tag_name"' | sed -E 's/.*"v([^"]+)".*/\1/')
            fi
            echo "Installing RepoLens version: ${VERSION}"

            curl -LO "https://github.com/delfour-co/cli--repolens/releases/download/v${VERSION}/repolens-linux-x86_64.tar.gz"
            tar xzf repolens-linux-x86_64.tar.gz
            sudo mv repolens /usr/local/bin/
            rm repolens-linux-x86_64.tar.gz

            repolens --version

  # Run RepoLens audit
  run-audit:
    description: "Execute RepoLens audit"
    parameters:
      preset:
        type: string
        default: "opensource"
      format:
        type: string
        default: "json"
      output:
        type: string
        default: "audit-report"
      fail-on:
        type: string
        default: "critical"
    steps:
      - run:
          name: Run RepoLens Audit
          command: |
            # Determine file extension based on format
            FORMAT="<< parameters.format >>"
            case "${FORMAT}" in
              json)     EXT="json" ;;
              sarif)    EXT="sarif" ;;
              markdown) EXT="md" ;;
              html)     EXT="html" ;;
              *)        EXT="txt" ;;
            esac

            OUTPUT_FILE="<< parameters.output >>.${EXT}"

            # Run the audit
            repolens plan \
              --preset << parameters.preset >> \
              --format ${FORMAT} \
              --output ${OUTPUT_FILE}

            AUDIT_EXIT_CODE=$?

            # Handle fail-on logic
            FAIL_ON="<< parameters.fail-on >>"
            if [ "${FAIL_ON}" = "none" ]; then
              echo "fail-on is set to 'none', ignoring exit code"
              exit 0
            fi

            if [ ${AUDIT_EXIT_CODE} -ne 0 ]; then
              case "${FAIL_ON}" in
                critical)
                  if [ ${AUDIT_EXIT_CODE} -eq 1 ]; then
                    echo "Critical findings detected"
                    exit 1
                  fi
                  ;;
                high|medium|low)
                  echo "Findings detected at or above '${FAIL_ON}' severity"
                  exit 1
                  ;;
              esac
            fi

# =============================================================================
# Jobs
# =============================================================================

jobs:
  # Main audit job using Docker image
  audit-docker:
    executor: repolens-docker
    steps:
      - checkout

      # Restore cache for faster runs
      - restore_cache:
          keys:
            - repolens-cache-v1-{{ .Branch }}-{{ checksum ".repolens.toml" }}
            - repolens-cache-v1-{{ .Branch }}-
            - repolens-cache-v1-

      - run:
          name: Verify RepoLens Installation
          command: repolens --version

      - run-audit:
          preset: << pipeline.parameters.repolens-preset >>
          format: << pipeline.parameters.repolens-format >>
          fail-on: << pipeline.parameters.repolens-fail-on >>

      # Save cache for subsequent runs
      - save_cache:
          key: repolens-cache-v1-{{ .Branch }}-{{ checksum ".repolens.toml" }}
          paths:
            - .repolens/cache

      # Store audit results as artifacts
      - store_artifacts:
          path: audit-report.*
          destination: repolens-reports

      # Store test results (if JSON format)
      - store_test_results:
          path: audit-report.json

  # Audit job using binary installation
  audit-binary:
    executor: linux
    steps:
      - checkout

      # Cache the RepoLens binary
      - restore_cache:
          keys:
            - repolens-binary-v1-<< pipeline.parameters.repolens-version >>

      - install-repolens:
          version: << pipeline.parameters.repolens-version >>

      - save_cache:
          key: repolens-binary-v1-<< pipeline.parameters.repolens-version >>
          paths:
            - /usr/local/bin/repolens

      - run-audit:
          preset: << pipeline.parameters.repolens-preset >>
          format: << pipeline.parameters.repolens-format >>
          fail-on: << pipeline.parameters.repolens-fail-on >>

      - store_artifacts:
          path: audit-report.*
          destination: repolens-reports

  # SARIF audit for security integrations
  audit-sarif:
    executor: repolens-docker
    steps:
      - checkout

      - run:
          name: Generate SARIF Report
          command: |
            repolens plan \
              --preset << pipeline.parameters.repolens-preset >> \
              --format sarif \
              --output audit-report.sarif

      - store_artifacts:
          path: audit-report.sarif
          destination: security-reports

  # HTML report for documentation
  audit-html:
    executor: repolens-docker
    steps:
      - checkout

      - run:
          name: Generate HTML Report
          command: |
            repolens plan \
              --preset << pipeline.parameters.repolens-preset >> \
              --format html \
              --output audit-report.html

      - store_artifacts:
          path: audit-report.html
          destination: reports

# =============================================================================
# Workflows
# =============================================================================

workflows:
  version: 2

  # Main CI workflow - runs on every push and PR
  ci:
    jobs:
      - audit-docker:
          filters:
            branches:
              only:
                - main
                - develop
                - /feature\/.*/
                - /fix\/.*/

  # PR workflow - runs on pull requests
  pr-check:
    jobs:
      - audit-docker:
          filters:
            branches:
              only:
                - /pull\/.*/

  # Nightly comprehensive audit
  nightly:
    triggers:
      - schedule:
          cron: "0 2 * * *"  # Run at 2 AM UTC every day
          filters:
            branches:
              only:
                - main
    jobs:
      - audit-html
      - audit-sarif

  # Weekly full report with HTML output
  weekly-report:
    triggers:
      - schedule:
          cron: "0 8 * * 1"  # Run at 8 AM UTC every Monday
          filters:
            branches:
              only:
                - main
    jobs:
      - audit-html
