{"files":[{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","scripts","check-quality-gates.rs"],"content":"//! Script de v√©rification des seuils de qualit√©\n//! \n//! Ce script v√©rifie que tous les seuils d√©finis dans `.github/quality-gates.toml`\n//! sont respect√©s avant de permettre la cr√©ation d'une nightly build.\n\nuse std::fs;\nuse std::path::Path;\nuse std::process::{Command, Stdio};\n\nuse anyhow::{Context, Result};\nuse serde::Deserialize;\nuse toml;\n\n#[derive(Debug, Deserialize)]\nstruct QualityGates {\n    coverage: Option<Coverage>,\n    clippy: Option<Clippy>,\n    security: Option<Security>,\n    dependencies: Option<Dependencies>,\n    code_metrics: Option<CodeMetrics>,\n    documentation: Option<Documentation>,\n    tests: Option<Tests>,\n    build: Option<Build>,\n    nightly: Option<Nightly>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Coverage {\n    minimum: Option<f64>,\n    target: Option<f64>,\n    exclude: Option<Vec<String>>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Clippy {\n    max_warnings: Option<u32>,\n    severity: Option<String>,\n    strict: Option<bool>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Security {\n    max_critical_vulnerabilities: Option<u32>,\n    max_high_vulnerabilities: Option<u32>,\n    max_medium_vulnerabilities: Option<u32>,\n    allow_unpatched: Option<bool>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Dependencies {\n    max_outdated: Option<u32>,\n    max_duplicates: Option<u32>,\n    check_licenses: Option<bool>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct CodeMetrics {\n    max_binary_size: Option<u64>,\n    min_tests: Option<u32>,\n    min_integration_tests: Option<u32>,\n    max_cyclomatic_complexity: Option<u32>,\n    max_unsafe_percentage: Option<f64>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Documentation {\n    min_documentation_coverage: Option<f64>,\n    require_public_docs: Option<bool>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Tests {\n    require_all_tests_pass: Option<bool>,\n    max_test_duration: Option<u32>,\n    enable_performance_tests: Option<bool>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Build {\n    require_build_success: Option<bool>,\n    max_build_duration: Option<u32>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Nightly {\n    strict_mode: Option<bool>,\n    block_on_coverage_decrease: Option<bool>,\n    block_on_new_vulnerabilities: Option<bool>,\n    block_on_new_warnings: Option<bool>,\n}\n\nstruct CheckResult {\n    name: String,\n    passed: bool,\n    message: String,\n}\n\nfn main() -> Result<()> {\n    println!(\"üîç V√©rification des seuils de qualit√©...\\n\");\n\n    let gates = load_quality_gates()?;\n    let mut results = Vec::new();\n    let mut failed_checks = 0;\n\n    // V√©rifier la couverture\n    if let Some(coverage) = &gates.coverage {\n        if let Some(minimum) = coverage.minimum {\n            match check_coverage(minimum) {\n                Ok(result) => {\n                    if !result.passed {\n                        failed_checks += 1;\n                    }\n                    results.push(result);\n                }\n                Err(e) => {\n                    println!(\"‚ö†Ô∏è  V√©rification de couverture ignor√©e: {}\", e);\n                }\n            }\n        }\n    }\n\n    // V√©rifier Clippy\n    if let Some(clippy) = &gates.clippy {\n        if let Some(max_warnings) = clippy.max_warnings {\n            match check_clippy(max_warnings) {\n                Ok(result) => {\n                    if !result.passed {\n                        failed_checks += 1;\n                    }\n                    results.push(result);\n                }\n                Err(e) => {\n                    println!(\"‚ö†Ô∏è  V√©rification Clippy ignor√©e: {}\", e);\n                }\n            }\n        }\n    }\n\n    // V√©rifier la s√©curit√©\n    if let Some(security) = &gates.security {\n        match check_security(security) {\n            Ok(result) => {\n                if !result.passed {\n                    failed_checks += 1;\n                }\n                results.push(result);\n            }\n            Err(e) => {\n                println!(\"‚ö†Ô∏è  V√©rification de s√©curit√© ignor√©e: {}\", e);\n            }\n        }\n    }\n\n    // V√©rifier les d√©pendances\n    if let Some(deps) = &gates.dependencies {\n        match check_dependencies(deps) {\n            Ok(result) => {\n                if !result.passed {\n                    failed_checks += 1;\n                }\n                results.push(result);\n            }\n            Err(e) => {\n                println!(\"‚ö†Ô∏è  V√©rification des d√©pendances ignor√©e: {}\", e);\n            }\n        }\n    }\n\n    // V√©rifier les m√©triques de code\n    if let Some(metrics) = &gates.code_metrics {\n        match check_code_metrics(metrics) {\n            Ok(result) => {\n                for r in result {\n                    if !r.passed {\n                        failed_checks += 1;\n                    }\n                    results.push(r);\n                }\n            }\n            Err(e) => {\n                println!(\"‚ö†Ô∏è  V√©rification des m√©triques ignor√©e: {}\", e);\n            }\n        }\n    }\n\n    // Afficher les r√©sultats\n    println!();\n    for result in &results {\n        if result.passed {\n            println!(\"‚úÖ {}: {}\", result.name, result.message);\n        } else {\n            println!(\"‚ùå {}: {}\", result.name, result.message);\n        }\n    }\n\n    println!();\n    if failed_checks == 0 {\n        println!(\"‚úÖ Tous les seuils de qualit√© sont respect√©s !\");\n        Ok(())\n    } else {\n        println!(\"‚ùå {} seuil(s) de qualit√© non respect√©(s)\", failed_checks);\n        println!(\"La nightly build ne peut pas √™tre cr√©√©e.\");\n        std::process::exit(1);\n    }\n}\n\nfn load_quality_gates() -> Result<QualityGates> {\n    let content = fs::read_to_string(\".github/quality-gates.toml\")\n        .context(\"Impossible de lire le fichier de configuration des seuils\")?;\n    let gates: QualityGates = toml::from_str(&content)\n        .context(\"Erreur lors du parsing du fichier de configuration\")?;\n    Ok(gates)\n}\n\nfn check_coverage(minimum: f64) -> Result<CheckResult> {\n    // Essayer de lire depuis un fichier XML de couverture\n    let coverage_file = \"coverage/cobertura.xml\";\n    if Path::new(coverage_file).exists() {\n        // Pour une impl√©mentation compl√®te, il faudrait parser le XML\n        // Ici, on utilise une approche simplifi√©e\n        let coverage = extract_coverage_from_xml(coverage_file)?;\n        let passed = coverage >= minimum;\n        Ok(CheckResult {\n            name: \"Couverture de code\".to_string(),\n            passed,\n            message: format!(\"{:.2}% (minimum: {:.2}%)\", coverage, minimum),\n        })\n    } else {\n        // Essayer avec cargo-tarpaulin directement\n        let output = Command::new(\"cargo\")\n            .args(&[\"tarpaulin\", \"--out\", \"Xml\", \"--output-dir\", \"/tmp\"])\n            .stderr(Stdio::null())\n            .output()?;\n\n        if output.status.success() {\n            // Parser la sortie pour extraire le pourcentage\n            let stdout = String::from_utf8_lossy(&output.stdout);\n            let coverage = extract_coverage_from_output(&stdout)?;\n            let passed = coverage >= minimum;\n            Ok(CheckResult {\n                name: \"Couverture de code\".to_string(),\n                passed,\n                message: format!(\"{:.2}% (minimum: {:.2}%)\", coverage, minimum),\n            })\n        } else {\n            Err(anyhow::anyhow!(\"cargo-tarpaulin non disponible\"))\n        }\n    }\n}\n\nfn extract_coverage_from_xml(_file: &str) -> Result<f64> {\n    // Impl√©mentation simplifi√©e - dans un vrai projet, utiliser un parser XML\n    // Pour l'instant, on retourne une valeur par d√©faut\n    Ok(0.0)\n}\n\nfn extract_coverage_from_output(output: &str) -> Result<f64> {\n    // Extraire le pourcentage depuis la sortie de cargo-tarpaulin\n    for line in output.lines() {\n        if line.contains(\"%\") {\n            if let Some(percent_str) = line.split('%').next() {\n                if let Ok(coverage) = percent_str.trim().parse::<f64>() {\n                    return Ok(coverage);\n                }\n            }\n        }\n    }\n    Err(anyhow::anyhow!(\"Impossible d'extraire la couverture\"))\n}\n\nfn check_clippy(max_warnings: u32) -> Result<CheckResult> {\n    let output = Command::new(\"cargo\")\n        .args(&[\"clippy\", \"--all-targets\", \"--all-features\", \"--message-format=json\"])\n        .output()?;\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    let warnings = stdout\n        .lines()\n        .filter(|line| line.contains(r#\"\"level\":\"warning\"\"#))\n        .count() as u32;\n\n    let passed = warnings <= max_warnings;\n    Ok(CheckResult {\n        name: \"Clippy warnings\".to_string(),\n        passed,\n        message: format!(\"{} warnings (maximum: {})\", warnings, max_warnings),\n    })\n}\n\nfn check_security(security: &Security) -> Result<CheckResult> {\n    let output = Command::new(\"cargo\")\n        .args(&[\"audit\", \"--json\"])\n        .output();\n\n    match output {\n        Ok(output) => {\n            let stdout = String::from_utf8_lossy(&output.stdout);\n            let critical = stdout.matches(r#\"\"severity\":\"critical\"\"#).count() as u32;\n            let high = stdout.matches(r#\"\"severity\":\"high\"\"#).count() as u32;\n\n            let max_critical = security.max_critical_vulnerabilities.unwrap_or(0);\n            let max_high = security.max_high_vulnerabilities.unwrap_or(0);\n\n            let passed = critical <= max_critical && high <= max_high;\n            Ok(CheckResult {\n                name: \"Vuln√©rabilit√©s de s√©curit√©\".to_string(),\n                passed,\n                message: format!(\n                    \"Critiques: {} (max: {}), Importantes: {} (max: {})\",\n                    critical, max_critical, high, max_high\n                ),\n            })\n        }\n        Err(_) => Err(anyhow::anyhow!(\"cargo-audit non disponible\")),\n    }\n}\n\nfn check_dependencies(deps: &Dependencies) -> Result<CheckResult> {\n    if let Some(max_outdated) = deps.max_outdated {\n        let output = Command::new(\"cargo\")\n            .args(&[\"outdated\", \"--format\", \"json\"])\n            .output();\n\n        match output {\n            Ok(output) => {\n                let stdout = String::from_utf8_lossy(&output.stdout);\n                let outdated = stdout.matches(r#\"\"name\"\"#).count() as u32;\n\n                let passed = outdated <= max_outdated;\n                Ok(CheckResult {\n                    name: \"D√©pendances obsol√®tes\".to_string(),\n                    passed,\n                    message: format!(\"{} d√©pendances (maximum: {})\", outdated, max_outdated),\n                })\n            }\n            Err(_) => Err(anyhow::anyhow!(\"cargo-outdated non disponible\")),\n        }\n    } else {\n        Ok(CheckResult {\n            name: \"D√©pendances obsol√®tes\".to_string(),\n            passed: true,\n            message: \"V√©rification d√©sactiv√©e\".to_string(),\n        })\n    }\n}\n\nfn check_code_metrics(metrics: &CodeMetrics) -> Result<Vec<CheckResult>> {\n    let mut results = Vec::new();\n\n    // V√©rifier le nombre de tests\n    if let Some(min_tests) = metrics.min_tests {\n        let output = Command::new(\"cargo\")\n            .args(&[\"test\", \"--all-features\", \"--lib\", \"--tests\", \"--no-run\", \"--message-format=json\"])\n            .output()?;\n\n        let stdout = String::from_utf8_lossy(&output.stdout);\n        let test_count = stdout.matches(r#\"\"type\":\"test\"\"#).count() as u32;\n\n        results.push(CheckResult {\n            name: \"Nombre de tests\".to_string(),\n            passed: test_count >= min_tests,\n            message: format!(\"{} tests (minimum: {})\", test_count, min_tests),\n        });\n    }\n\n    // V√©rifier la taille du binaire\n    if let Some(max_size) = metrics.max_binary_size {\n        let binary_path = \"target/release/repolens\";\n        if Path::new(binary_path).exists() {\n            let metadata = fs::metadata(binary_path)?;\n            let size = metadata.len();\n            results.push(CheckResult {\n                name: \"Taille du binaire\".to_string(),\n                passed: size <= max_size,\n                message: format!(\"{} bytes (maximum: {} bytes)\", size, max_size),\n            });\n        }\n    }\n\n    Ok(results)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","branch_protection.rs"],"content":"//! Branch protection configuration via GitHub API\n\nuse crate::error::{ActionError, ProviderError, RepoLensError};\nuse std::process::Command;\n\nuse super::plan::BranchProtectionSettings;\nuse crate::utils::prerequisites::{get_repo_info, is_gh_available};\n\n/// Configure branch protection for a branch\npub async fn configure(\n    branch: &str,\n    settings: &BranchProtectionSettings,\n) -> Result<(), RepoLensError> {\n    // Check if gh CLI is available\n    if !is_gh_available() {\n        return Err(RepoLensError::Provider(\n            ProviderError::GitHubCliNotAvailable,\n        ));\n    }\n\n    // Get repository info\n    let repo = get_repo_info().map_err(|e| {\n        RepoLensError::Action(ActionError::ExecutionFailed {\n            message: format!(\"Failed to get repository info: {}\", e),\n        })\n    })?;\n\n    // Build the API request\n    let required_pr_reviews = if settings.required_approvals > 0 {\n        format!(\n            r#\"{{\"required_approving_review_count\":{},\"dismiss_stale_reviews\":true}}\"#,\n            settings.required_approvals\n        )\n    } else {\n        \"null\".to_string()\n    };\n\n    let required_status_checks = if settings.require_status_checks {\n        r#\"{\"strict\":true,\"contexts\":[]}\"#.to_string()\n    } else {\n        \"null\".to_string()\n    };\n\n    // Execute the API call\n    let output = Command::new(\"gh\")\n        .args([\n            \"api\",\n            &format!(\"repos/{}/branches/{}/protection\", repo, branch),\n            \"--method\",\n            \"PUT\",\n            \"--field\",\n            &format!(\"required_status_checks={}\", required_status_checks),\n            \"--field\",\n            &format!(\"enforce_admins={}\", settings.enforce_admins),\n            \"--field\",\n            &format!(\"required_pull_request_reviews={}\", required_pr_reviews),\n            \"--field\",\n            \"restrictions=null\",\n            \"--field\",\n            &format!(\n                \"required_linear_history={}\",\n                settings.require_linear_history\n            ),\n            \"--field\",\n            &format!(\"allow_force_pushes={}\", !settings.block_force_push),\n            \"--field\",\n            &format!(\"allow_deletions={}\", !settings.block_deletions),\n            \"--field\",\n            &format!(\n                \"required_conversation_resolution={}\",\n                settings.require_conversation_resolution\n            ),\n        ])\n        .output()\n        .map_err(|_| {\n            RepoLensError::Provider(ProviderError::CommandFailed {\n                command: format!(\"gh api repos/{}/branches/{}/protection\", repo, branch),\n            })\n        })?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(&output.stderr);\n\n        // Check for common errors\n        if stderr.contains(\"Resource not accessible\") {\n            return Err(RepoLensError::Action(ActionError::ExecutionFailed {\n                message: \"Cannot configure branch protection. This may require admin access or \\\n                the repository may not support this feature (e.g., free private repos).\"\n                    .to_string(),\n            }));\n        }\n\n        return Err(RepoLensError::Action(ActionError::ExecutionFailed {\n            message: format!(\"Failed to configure branch protection: {}\", stderr),\n        }));\n    }\n\n    // Configure signed commits if required (separate API call)\n    if settings.require_signed_commits {\n        let output = Command::new(\"gh\")\n            .args([\n                \"api\",\n                &format!(\n                    \"repos/{}/branches/{}/protection/required_signatures\",\n                    repo, branch\n                ),\n                \"--method\",\n                \"POST\",\n            ])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: format!(\n                        \"gh api repos/{}/branches/{}/protection/required_signatures\",\n                        repo, branch\n                    ),\n                })\n            })?;\n\n        if !output.status.success() {\n            // Non-fatal: signed commits may not be available\n            tracing::warn!(\"Could not enable signed commits requirement (may require GitHub Pro)\");\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":10,"address":[150768],"length":1,"stats":{"Line":0}},{"line":15,"address":[1169747,1169837],"length":1,"stats":{"Line":0}},{"line":16,"address":[1169855],"length":1,"stats":{"Line":0}},{"line":17,"address":[1169843],"length":1,"stats":{"Line":0}},{"line":22,"address":[1169967,1170054,1170160,1176580,1176873,1176624,1176879],"length":1,"stats":{"Line":0}},{"line":23,"address":[1176795],"length":1,"stats":{"Line":0}},{"line":24,"address":[791874,791826],"length":1,"stats":{"Line":0}},{"line":29,"address":[1170297],"length":1,"stats":{"Line":0}},{"line":30,"address":[1170341,1170426],"length":1,"stats":{"Line":0}},{"line":35,"address":[1170404,1170302],"length":1,"stats":{"Line":0}},{"line":38,"address":[1170414],"length":1,"stats":{"Line":0}},{"line":39,"address":[1170559,1170663],"length":1,"stats":{"Line":0}},{"line":41,"address":[1170528,1170634],"length":1,"stats":{"Line":0}},{"line":45,"address":[1173241,1170636,1173430],"length":1,"stats":{"Line":0}},{"line":46,"address":[1172798],"length":1,"stats":{"Line":0}},{"line":48,"address":[785942,785874],"length":1,"stats":{"Line":0}},{"line":52,"address":[1171024],"length":1,"stats":{"Line":0}},{"line":54,"address":[1171266],"length":1,"stats":{"Line":0}},{"line":56,"address":[1171496],"length":1,"stats":{"Line":0}},{"line":60,"address":[1171738],"length":1,"stats":{"Line":0}},{"line":65,"address":[1171976],"length":1,"stats":{"Line":0}},{"line":67,"address":[1172232],"length":1,"stats":{"Line":0}},{"line":69,"address":[1172488],"length":1,"stats":{"Line":0}},{"line":75,"address":[792064,792409,792403],"length":1,"stats":{"Line":0}},{"line":76,"address":[1177129],"length":1,"stats":{"Line":0}},{"line":77,"address":[1176993,1176928],"length":1,"stats":{"Line":0}},{"line":81,"address":[1174130],"length":1,"stats":{"Line":0}},{"line":82,"address":[1174227,1174165],"length":1,"stats":{"Line":0}},{"line":85,"address":[789414,789497],"length":1,"stats":{"Line":0}},{"line":86,"address":[1174658],"length":1,"stats":{"Line":0}},{"line":87,"address":[789561],"length":1,"stats":{"Line":0}},{"line":93,"address":[1174527],"length":1,"stats":{"Line":0}},{"line":94,"address":[1174366,1174427],"length":1,"stats":{"Line":0}},{"line":99,"address":[1174202],"length":1,"stats":{"Line":0}},{"line":100,"address":[789997,790613,790430],"length":1,"stats":{"Line":0}},{"line":101,"address":[1175149],"length":1,"stats":{"Line":0}},{"line":103,"address":[790095,790024],"length":1,"stats":{"Line":0}},{"line":111,"address":[1177264,1177609,1177603],"length":1,"stats":{"Line":0}},{"line":112,"address":[1177497],"length":1,"stats":{"Line":0}},{"line":113,"address":[1177296,1177361],"length":1,"stats":{"Line":0}},{"line":120,"address":[1175725],"length":1,"stats":{"Line":0}},{"line":122,"address":[1175801,1175754],"length":1,"stats":{"Line":0}},{"line":126,"address":[1174799],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":43},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","executor.rs"],"content":"//! Action executor - Executes planned actions\n//!\n//! This module provides functionality to execute actions from an action plan.\n//! It handles the actual execution of file creation, .gitignore updates,\n//! branch protection configuration, and GitHub settings updates.\n\nuse crate::error::RepoLensError;\nuse tracing::{debug, info};\n\nuse crate::config::Config;\n\nuse super::plan::{Action, ActionOperation, ActionPlan};\nuse super::{branch_protection, github_settings, gitignore, templates};\n\n/// Result of executing a single action\n///\n/// Contains information about whether an action succeeded or failed,\n/// along with any error message if it failed.\n#[derive(Debug)]\npub struct ActionResult {\n    /// Name/description of the action that was executed\n    pub action_name: String,\n    /// Whether the action succeeded\n    pub success: bool,\n    /// Error message if the action failed, `None` if it succeeded\n    pub error: Option<String>,\n}\n\n/// Executes actions from an action plan\n///\n/// The `ActionExecutor` takes an `ActionPlan` and executes each action\n/// sequentially. It handles different types of operations like file creation,\n/// .gitignore updates, and GitHub API calls.\npub struct ActionExecutor {\n    /// Configuration (currently unused but kept for future extensibility)\n    _config: Config,\n}\n\nimpl ActionExecutor {\n    /// Create a new action executor with the given configuration\n    ///\n    /// # Arguments\n    ///\n    /// * `config` - The configuration to use for execution\n    ///\n    /// # Returns\n    ///\n    /// A new `ActionExecutor` instance\n    pub fn new(config: Config) -> Self {\n        Self { _config: config }\n    }\n\n    /// Execute all actions in the plan\n    ///\n    /// Executes each action sequentially and collects results. If an action\n    /// fails, execution continues with the next action.\n    ///\n    /// # Arguments\n    ///\n    /// * `plan` - The action plan to execute\n    ///\n    /// # Returns\n    ///\n    /// A vector of `ActionResult` for each action, indicating success or failure\n    ///\n    /// # Errors\n    ///\n    /// Returns an error only if there's a critical failure in the executor itself\n    pub async fn execute(&self, plan: &ActionPlan) -> Result<Vec<ActionResult>, RepoLensError> {\n        let mut results = Vec::new();\n\n        for action in plan.actions() {\n            info!(\"Executing action: {}\", action.id());\n\n            let result = self.execute_action(action).await;\n\n            results.push(ActionResult {\n                action_name: action.description().to_string(),\n                success: result.is_ok(),\n                error: result.err().map(|e| e.to_string()),\n            });\n        }\n\n        Ok(results)\n    }\n\n    /// Execute a single action\n    ///\n    /// # Arguments\n    ///\n    /// * `action` - The action to execute\n    ///\n    /// # Returns\n    ///\n    /// `Ok(())` if the action succeeded, or an error if it failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the action execution fails\n    async fn execute_action(&self, action: &Action) -> Result<(), RepoLensError> {\n        match action.operation() {\n            ActionOperation::UpdateGitignore { entries } => {\n                debug!(\"Updating .gitignore with {} entries\", entries.len());\n                // Get current directory at the start to avoid race conditions in parallel tests\n                let current_dir = std::env::current_dir().map_err(|e| {\n                    RepoLensError::Action(crate::error::ActionError::ExecutionFailed {\n                        message: format!(\"Failed to get current directory: {}\", e),\n                    })\n                })?;\n                gitignore::update_gitignore_at(&current_dir, entries)?;\n            }\n\n            ActionOperation::CreateFile {\n                path,\n                template,\n                variables,\n            } => {\n                debug!(\"Creating file {} from template {}\", path, template);\n                templates::create_file_from_template(path, template, variables)?;\n            }\n\n            ActionOperation::ConfigureBranchProtection { branch, settings } => {\n                debug!(\"Configuring branch protection for {}\", branch);\n                branch_protection::configure(branch, settings).await?;\n            }\n\n            ActionOperation::UpdateGitHubSettings { settings } => {\n                debug!(\"Updating GitHub repository settings\");\n                github_settings::update(settings).await?;\n            }\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::actions::plan::{ActionOperation, ActionPlan};\n    use std::collections::HashMap;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_execute_action_update_gitignore() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let root_abs = root.canonicalize().unwrap_or_else(|_| root.to_path_buf());\n\n        // Save current directory (fallback to /tmp if current dir is invalid)\n        let original_dir =\n            std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from(\"/tmp\"));\n\n        // Ensure we're in a valid directory before changing\n        if std::env::current_dir().is_err() {\n            let _ = std::env::set_current_dir(\"/tmp\");\n        }\n\n        // Change to temp directory\n        std::env::set_current_dir(&root_abs).expect(\"Failed to change to temp directory\");\n\n        let config = Config::default();\n        let executor = ActionExecutor::new(config);\n\n        let action = Action::new(\n            \"test-gitignore\",\n            \"gitignore\",\n            \"Test gitignore update\",\n            ActionOperation::UpdateGitignore {\n                entries: vec![\".env\".to_string(), \"*.key\".to_string()],\n            },\n        );\n\n        // Execute action - it will get current_dir at start, but we ensure it's correct\n        // by setting it just before execution. However, parallel tests might still interfere,\n        // so we also verify the file was created using absolute path.\n        std::env::set_current_dir(&root_abs)\n            .expect(\"Failed to restore temp directory before execution\");\n\n        let result = executor.execute_action(&action).await;\n\n        // Restore directory immediately after execution\n        let _ = std::env::set_current_dir(&original_dir);\n\n        // Check result after restoring directory\n        assert!(\n            result.is_ok(),\n            \"Action execution failed: {:?}\",\n            result.err()\n        );\n\n        // Verify file was created in the temp directory using absolute path\n        // This works regardless of what the current directory is\n        let gitignore_path = root_abs.join(\".gitignore\");\n        assert!(\n            gitignore_path.exists(),\n            \".gitignore not found at {:?}. Root was: {:?}\",\n            gitignore_path,\n            root_abs\n        );\n    }\n\n    #[tokio::test]\n    async fn test_execute_action_create_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Save current directory (fallback to /tmp if current dir is invalid)\n        let original_dir =\n            std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from(\"/tmp\"));\n\n        // Ensure we're in a valid directory before changing\n        if std::env::current_dir().is_err() {\n            let _ = std::env::set_current_dir(\"/tmp\");\n        }\n\n        std::env::set_current_dir(root).expect(\"Failed to change to temp directory\");\n\n        let config = Config::default();\n        let executor = ActionExecutor::new(config);\n\n        let action = Action::new(\n            \"test-create\",\n            \"file\",\n            \"Test file creation\",\n            ActionOperation::CreateFile {\n                path: \"TEST.md\".to_string(),\n                template: \"CONTRIBUTING.md\".to_string(),\n                variables: HashMap::new(),\n            },\n        );\n\n        let result = executor.execute_action(&action).await;\n\n        // May fail if template doesn't exist, but that's ok for test\n        // We're testing that the function handles it gracefully\n        let _ = result;\n\n        // Restore directory (ignore errors if directory no longer exists)\n        let _ = std::env::set_current_dir(&original_dir);\n    }\n\n    #[tokio::test]\n    async fn test_execute_all_actions() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Save current directory (fallback to /tmp if current dir is invalid)\n        let original_dir =\n            std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from(\"/tmp\"));\n\n        // Ensure we're in a valid directory before changing\n        if std::env::current_dir().is_err() {\n            let _ = std::env::set_current_dir(\"/tmp\");\n        }\n\n        std::env::set_current_dir(root).expect(\"Failed to change to temp directory\");\n\n        let config = Config::default();\n        let executor = ActionExecutor::new(config);\n\n        let mut plan = ActionPlan::new();\n        plan.add(Action::new(\n            \"test-1\",\n            \"gitignore\",\n            \"Test 1\",\n            ActionOperation::UpdateGitignore {\n                entries: vec![\".env\".to_string()],\n            },\n        ));\n\n        let results = executor.execute(&plan).await.unwrap();\n\n        assert_eq!(results.len(), 1);\n        assert!(results[0].success);\n\n        // Restore directory (ignore errors if directory no longer exists)\n        let _ = std::env::set_current_dir(&original_dir);\n    }\n\n    #[tokio::test]\n    async fn test_execute_handles_errors_gracefully() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Save current directory (fallback to /tmp if current dir is invalid)\n        let original_dir =\n            std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from(\"/tmp\"));\n\n        // Ensure we're in a valid directory before changing\n        if std::env::current_dir().is_err() {\n            let _ = std::env::set_current_dir(\"/tmp\");\n        }\n\n        std::env::set_current_dir(root).expect(\"Failed to change to temp directory\");\n\n        let config = Config::default();\n        let executor = ActionExecutor::new(config);\n\n        let mut plan = ActionPlan::new();\n        // Add an action that will fail (invalid template)\n        plan.add(Action::new(\n            \"test-fail\",\n            \"file\",\n            \"Test failure\",\n            ActionOperation::CreateFile {\n                path: \"INVALID.md\".to_string(),\n                template: \"NONEXISTENT_TEMPLATE.md\".to_string(),\n                variables: HashMap::new(),\n            },\n        ));\n\n        let results = executor.execute(&plan).await.unwrap();\n\n        assert_eq!(results.len(), 1);\n        assert!(!results[0].success);\n        assert!(results[0].error.is_some());\n\n        // Restore directory (ignore errors if directory no longer exists)\n        let _ = std::env::set_current_dir(&original_dir);\n    }\n}\n","traces":[{"line":49,"address":[436032],"length":1,"stats":{"Line":5}},{"line":69,"address":[983615,983793,984001,983568,985637,983750],"length":1,"stats":{"Line":16}},{"line":70,"address":[983731],"length":1,"stats":{"Line":4}},{"line":72,"address":[984737,983851,983931],"length":1,"stats":{"Line":10}},{"line":73,"address":[984999,985256,984806],"length":1,"stats":{"Line":8}},{"line":75,"address":[269031],"length":1,"stats":{"Line":12}},{"line":77,"address":[984634,984355],"length":1,"stats":{"Line":4}},{"line":78,"address":[984444,984375],"length":1,"stats":{"Line":4}},{"line":79,"address":[984471],"length":1,"stats":{"Line":2}},{"line":80,"address":[984523,985664,985680],"length":1,"stats":{"Line":6}},{"line":84,"address":[984842],"length":1,"stats":{"Line":3}},{"line":100,"address":[989780,985807,985987,987646,985923,985760],"length":1,"stats":{"Line":12}},{"line":101,"address":[986042,985908],"length":1,"stats":{"Line":6}},{"line":102,"address":[986114],"length":1,"stats":{"Line":2}},{"line":103,"address":[986134,986391,986678],"length":1,"stats":{"Line":4}},{"line":105,"address":[987019,990765,987125,990771,987652,990512,986656],"length":1,"stats":{"Line":4}},{"line":106,"address":[482207],"length":1,"stats":{"Line":0}},{"line":107,"address":[990598,990533],"length":1,"stats":{"Line":0}},{"line":110,"address":[478857,478750],"length":1,"stats":{"Line":4}},{"line":113,"address":[986196],"length":1,"stats":{"Line":2}},{"line":118,"address":[987661,987960,986216],"length":1,"stats":{"Line":4}},{"line":119,"address":[988317,987926,988537],"length":1,"stats":{"Line":6}},{"line":122,"address":[477775],"length":1,"stats":{"Line":0}},{"line":123,"address":[988810,988549,986294],"length":1,"stats":{"Line":0}},{"line":124,"address":[269553],"length":1,"stats":{"Line":0}},{"line":127,"address":[986333],"length":1,"stats":{"Line":0}},{"line":128,"address":[986353,989230,989479],"length":1,"stats":{"Line":0}},{"line":129,"address":[269569],"length":1,"stats":{"Line":0}},{"line":133,"address":[987559],"length":1,"stats":{"Line":2}}],"covered":21,"coverable":29},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","github_settings.rs"],"content":"//! GitHub repository settings management\n\nuse crate::error::{ActionError, ProviderError, RepoLensError};\nuse std::process::Command;\n\nuse super::plan::GitHubRepoSettings;\nuse crate::utils::prerequisites::{get_repo_info, is_gh_available};\n\n/// Update GitHub repository settings\npub async fn update(settings: &GitHubRepoSettings) -> Result<(), RepoLensError> {\n    // Check if gh CLI is available\n    if !is_gh_available() {\n        return Err(RepoLensError::Provider(\n            ProviderError::GitHubCliNotAvailable,\n        ));\n    }\n\n    // Get repository info\n    let repo = get_repo_info().map_err(|e| {\n        RepoLensError::Action(ActionError::ExecutionFailed {\n            message: format!(\"Failed to get repository info: {}\", e),\n        })\n    })?;\n\n    // Update repository settings\n    let mut args = vec![\"repo\", \"edit\"];\n\n    if let Some(true) = settings.enable_discussions {\n        args.push(\"--enable-discussions\");\n    }\n\n    if let Some(false) = settings.enable_wiki {\n        args.push(\"--enable-wiki=false\");\n    }\n\n    // Execute repository edit\n    if args.len() > 2 {\n        let output = Command::new(\"gh\").args(&args).output().map_err(|_| {\n            RepoLensError::Provider(ProviderError::CommandFailed {\n                command: format!(\"gh {}\", args.join(\" \")),\n            })\n        })?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(&output.stderr);\n            tracing::warn!(\"Could not update some repository settings: {}\", stderr);\n        }\n    }\n\n    // Enable vulnerability alerts\n    if let Some(true) = settings.enable_vulnerability_alerts {\n        let output = Command::new(\"gh\")\n            .args([\n                \"api\",\n                &format!(\"repos/{}/vulnerability-alerts\", repo),\n                \"--method\",\n                \"PUT\",\n            ])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: format!(\"gh api repos/{}/vulnerability-alerts\", repo),\n                })\n            })?;\n\n        if !output.status.success() {\n            tracing::warn!(\n                \"Could not enable vulnerability alerts (may require specific permissions)\"\n            );\n        }\n    }\n\n    // Enable automated security fixes\n    if let Some(true) = settings.enable_automated_security_fixes {\n        let output = Command::new(\"gh\")\n            .args([\n                \"api\",\n                &format!(\"repos/{}/automated-security-fixes\", repo),\n                \"--method\",\n                \"PUT\",\n            ])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: format!(\"gh api repos/{}/automated-security-fixes\", repo),\n                })\n            })?;\n\n        if !output.status.success() {\n            tracing::warn!(\n                \"Could not enable automated security fixes (may require specific permissions)\"\n            );\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":10,"address":[121304,121296],"length":1,"stats":{"Line":0}},{"line":12,"address":[1487575,1487485],"length":1,"stats":{"Line":0}},{"line":13,"address":[1487593],"length":1,"stats":{"Line":0}},{"line":14,"address":[574909],"length":1,"stats":{"Line":0}},{"line":19,"address":[1493081,1493087,1492786,1487782,1487705,1492832,1487888],"length":1,"stats":{"Line":0}},{"line":20,"address":[1493003],"length":1,"stats":{"Line":0}},{"line":21,"address":[1492866,1492914],"length":1,"stats":{"Line":0}},{"line":26,"address":[1488062,1487995],"length":1,"stats":{"Line":0}},{"line":28,"address":[1488213],"length":1,"stats":{"Line":0}},{"line":29,"address":[1488363,1488281],"length":1,"stats":{"Line":0}},{"line":32,"address":[1488256,1488373],"length":1,"stats":{"Line":0}},{"line":33,"address":[1488406],"length":1,"stats":{"Line":0}},{"line":37,"address":[1488379,1488454],"length":1,"stats":{"Line":0}},{"line":38,"address":[1488610,1493608,1493104,1493614,1488500,1488768],"length":1,"stats":{"Line":0}},{"line":39,"address":[1493502],"length":1,"stats":{"Line":0}},{"line":40,"address":[1493208,1493131],"length":1,"stats":{"Line":0}},{"line":44,"address":[1488988],"length":1,"stats":{"Line":0}},{"line":45,"address":[1489092,1489023],"length":1,"stats":{"Line":0}},{"line":46,"address":[1489111,1489190,1489477],"length":1,"stats":{"Line":0}},{"line":51,"address":[1488468,1489773],"length":1,"stats":{"Line":0}},{"line":52,"address":[1490402,1489819,1490221],"length":1,"stats":{"Line":0}},{"line":53,"address":[577436],"length":1,"stats":{"Line":0}},{"line":55,"address":[1489917,1489846],"length":1,"stats":{"Line":0}},{"line":60,"address":[1493918,1493924,1493632],"length":1,"stats":{"Line":0}},{"line":61,"address":[1493812],"length":1,"stats":{"Line":0}},{"line":62,"address":[1493723,1493658],"length":1,"stats":{"Line":0}},{"line":66,"address":[1490682],"length":1,"stats":{"Line":0}},{"line":67,"address":[578098,578045],"length":1,"stats":{"Line":0}},{"line":74,"address":[1489787,1491279],"length":1,"stats":{"Line":0}},{"line":75,"address":[1491709,1491884,1491319],"length":1,"stats":{"Line":0}},{"line":76,"address":[1491596],"length":1,"stats":{"Line":0}},{"line":78,"address":[1491346,1491417],"length":1,"stats":{"Line":0}},{"line":83,"address":[1494244,1493952,1494238],"length":1,"stats":{"Line":0}},{"line":84,"address":[1494132],"length":1,"stats":{"Line":0}},{"line":85,"address":[1493978,1494043],"length":1,"stats":{"Line":0}},{"line":89,"address":[1492164],"length":1,"stats":{"Line":0}},{"line":90,"address":[1492193,1492240],"length":1,"stats":{"Line":0}},{"line":96,"address":[1491285],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":38},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","gitignore.rs"],"content":"//! Gitignore file management\n\nuse crate::error::{ActionError, RepoLensError};\nuse std::fs;\nuse std::path::Path;\n\n/// Update .gitignore with new entries at the given root path\npub fn update_gitignore_at(root: &Path, entries: &[String]) -> Result<(), RepoLensError> {\n    let gitignore_path = root.join(\".gitignore\");\n\n    // Read existing content or create empty\n    let mut content = if gitignore_path.exists() {\n        fs::read_to_string(&gitignore_path).map_err(|e| {\n            RepoLensError::Scan(crate::error::ScanError::FileRead {\n                path: gitignore_path.display().to_string(),\n                source: e,\n            })\n        })?\n    } else {\n        String::new()\n    };\n\n    // Track what we add\n    let mut added = Vec::new();\n\n    for entry in entries {\n        // Check if entry already exists (handle various formats)\n        let entry_clean = entry.trim_end_matches('/');\n        let entry_patterns = [\n            entry.as_str(),\n            &format!(\"/{}\", entry),\n            &format!(\"{}/\", entry),\n            entry_clean,\n            &format!(\"/{}\", entry_clean),\n            &format!(\"{}/\", entry_clean),\n        ];\n\n        let exists = content.lines().any(|line| {\n            let line = line.trim();\n            let line_clean = line.trim_end_matches('/');\n            entry_patterns\n                .iter()\n                .any(|p| line == *p || line_clean == entry_clean)\n        });\n\n        if !exists {\n            added.push(entry.clone());\n        }\n    }\n\n    if added.is_empty() {\n        return Ok(());\n    }\n\n    // Add a newline if the file doesn't end with one\n    if !content.is_empty() && !content.ends_with('\\n') {\n        content.push('\\n');\n    }\n\n    // Add comment separator if there's existing content\n    if !content.is_empty() {\n        content.push_str(\"\\n# Added by repolens\\n\");\n    }\n\n    // Add new entries\n    for entry in &added {\n        content.push_str(entry);\n        content.push('\\n');\n    }\n\n    // Write back\n    fs::write(&gitignore_path, content).map_err(|e| {\n        RepoLensError::Action(ActionError::FileWrite {\n            path: gitignore_path.display().to_string(),\n            source: e,\n        })\n    })?;\n\n    Ok(())\n}\n\n/// Update .gitignore with new entries in current directory\n#[allow(dead_code)] // Kept for public API, may be used by external code\npub fn update_gitignore(entries: &[String]) -> Result<(), RepoLensError> {\n    let current_dir = std::env::current_dir().map_err(|e| {\n        RepoLensError::Action(ActionError::ExecutionFailed {\n            message: format!(\"Failed to get current directory: {}\", e),\n        })\n    })?;\n    update_gitignore_at(&current_dir, entries)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_update_gitignore_new_file() {\n        let dir = tempdir().unwrap();\n\n        update_gitignore_at(dir.path(), &[\".env\".to_string(), \"*.key\".to_string()]).unwrap();\n\n        let content = fs::read_to_string(dir.path().join(\".gitignore\")).unwrap();\n        assert!(content.contains(\".env\"));\n        assert!(content.contains(\"*.key\"));\n    }\n\n    #[test]\n    fn test_update_gitignore_existing_file() {\n        let dir = tempdir().unwrap();\n\n        fs::write(dir.path().join(\".gitignore\"), \"node_modules/\\n\").unwrap();\n\n        update_gitignore_at(\n            dir.path(),\n            &[\".env\".to_string(), \"node_modules\".to_string()],\n        )\n        .unwrap();\n\n        let content = fs::read_to_string(dir.path().join(\".gitignore\")).unwrap();\n        assert!(content.contains(\"node_modules\"));\n        assert!(content.contains(\".env\"));\n        // Should not duplicate\n        assert_eq!(content.matches(\"node_modules\").count(), 1);\n    }\n}\n","traces":[{"line":8,"address":[348623,348656,345472],"length":1,"stats":{"Line":4}},{"line":9,"address":[1515128],"length":1,"stats":{"Line":4}},{"line":12,"address":[1515182,1515265,1515627],"length":1,"stats":{"Line":10}},{"line":13,"address":[30070,29808,30064],"length":1,"stats":{"Line":4}},{"line":14,"address":[29978],"length":1,"stats":{"Line":0}},{"line":15,"address":[267780,267707],"length":1,"stats":{"Line":0}},{"line":16,"address":[29973],"length":1,"stats":{"Line":0}},{"line":20,"address":[1515330,1515300],"length":1,"stats":{"Line":4}},{"line":24,"address":[1515338],"length":1,"stats":{"Line":2}},{"line":26,"address":[1515689,1515773],"length":1,"stats":{"Line":8}},{"line":28,"address":[1516809,1515879],"length":1,"stats":{"Line":8}},{"line":29,"address":[1517848],"length":1,"stats":{"Line":4}},{"line":30,"address":[1516873],"length":1,"stats":{"Line":4}},{"line":31,"address":[1516936],"length":1,"stats":{"Line":4}},{"line":32,"address":[1517164],"length":1,"stats":{"Line":4}},{"line":34,"address":[1517380],"length":1,"stats":{"Line":4}},{"line":35,"address":[1517596],"length":1,"stats":{"Line":4}},{"line":38,"address":[348384],"length":1,"stats":{"Line":6}},{"line":39,"address":[30144],"length":1,"stats":{"Line":2}},{"line":40,"address":[30159],"length":1,"stats":{"Line":2}},{"line":41,"address":[30195,30253],"length":1,"stats":{"Line":4}},{"line":43,"address":[268160,268179,268096],"length":1,"stats":{"Line":6}},{"line":46,"address":[1518061],"length":1,"stats":{"Line":2}},{"line":47,"address":[348481,348527],"length":1,"stats":{"Line":4}},{"line":51,"address":[1515913],"length":1,"stats":{"Line":2}},{"line":52,"address":[1515982],"length":1,"stats":{"Line":0}},{"line":56,"address":[346376,346417,346492],"length":1,"stats":{"Line":6}},{"line":57,"address":[1516125],"length":1,"stats":{"Line":0}},{"line":61,"address":[346557,346462],"length":1,"stats":{"Line":4}},{"line":62,"address":[1516147,1516209],"length":1,"stats":{"Line":4}},{"line":66,"address":[1516174,1516227],"length":1,"stats":{"Line":4}},{"line":67,"address":[1516708,1516333],"length":1,"stats":{"Line":8}},{"line":68,"address":[347144],"length":1,"stats":{"Line":5}},{"line":72,"address":[30622,30368,30616],"length":1,"stats":{"Line":5}},{"line":73,"address":[30541],"length":1,"stats":{"Line":0}},{"line":74,"address":[30395,30468],"length":1,"stats":{"Line":0}},{"line":75,"address":[268408],"length":1,"stats":{"Line":0}},{"line":79,"address":[347014],"length":1,"stats":{"Line":6}},{"line":84,"address":[1518256,1518590,1518596],"length":1,"stats":{"Line":0}},{"line":85,"address":[30899,30893,30640],"length":1,"stats":{"Line":0}},{"line":86,"address":[30815],"length":1,"stats":{"Line":0}},{"line":87,"address":[30726,30661],"length":1,"stats":{"Line":0}},{"line":90,"address":[1518481,1518559],"length":1,"stats":{"Line":0}}],"covered":30,"coverable":43},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","mod.rs"],"content":"//! Actions module - Planned changes and execution\n\nmod branch_protection;\npub mod executor;\nmod github_settings;\nmod gitignore;\npub mod plan;\npub mod planner;\nmod templates;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","plan.rs"],"content":"//! Action plan structures\n\nuse serde::{Deserialize, Serialize};\n\n/// A single action to be performed\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Action {\n    /// Action identifier\n    id: String,\n    /// Action category\n    category: String,\n    /// Human-readable description\n    description: String,\n    /// Additional details about what will be changed\n    details: Vec<String>,\n    /// The actual operation to perform\n    operation: ActionOperation,\n}\n\nimpl Action {\n    /// Create a new action\n    pub fn new(\n        id: impl Into<String>,\n        category: impl Into<String>,\n        description: impl Into<String>,\n        operation: ActionOperation,\n    ) -> Self {\n        Self {\n            id: id.into(),\n            category: category.into(),\n            description: description.into(),\n            details: Vec::new(),\n            operation,\n        }\n    }\n\n    /// Add a detail line\n    pub fn with_detail(mut self, detail: impl Into<String>) -> Self {\n        self.details.push(detail.into());\n        self\n    }\n\n    /// Add multiple details\n    pub fn with_details(mut self, details: impl IntoIterator<Item = impl Into<String>>) -> Self {\n        self.details.extend(details.into_iter().map(|d| d.into()));\n        self\n    }\n\n    /// Get the action ID\n    pub fn id(&self) -> &str {\n        &self.id\n    }\n\n    /// Get the category\n    pub fn category(&self) -> &str {\n        &self.category\n    }\n\n    /// Get the description\n    pub fn description(&self) -> &str {\n        &self.description\n    }\n\n    /// Get the details\n    pub fn details(&self) -> &[String] {\n        &self.details\n    }\n\n    /// Get the operation\n    pub fn operation(&self) -> &ActionOperation {\n        &self.operation\n    }\n}\n\n/// The type of operation to perform\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ActionOperation {\n    /// Update .gitignore file\n    UpdateGitignore { entries: Vec<String> },\n\n    /// Create a file from template\n    CreateFile {\n        path: String,\n        template: String,\n        variables: std::collections::HashMap<String, String>,\n    },\n\n    /// Configure branch protection\n    ConfigureBranchProtection {\n        branch: String,\n        settings: BranchProtectionSettings,\n    },\n\n    /// Update GitHub repository settings\n    UpdateGitHubSettings { settings: GitHubRepoSettings },\n}\n\n/// Branch protection settings\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BranchProtectionSettings {\n    pub required_approvals: u32,\n    pub require_status_checks: bool,\n    pub require_conversation_resolution: bool,\n    pub require_linear_history: bool,\n    pub block_force_push: bool,\n    pub block_deletions: bool,\n    pub enforce_admins: bool,\n    pub require_signed_commits: bool,\n}\n\nimpl Default for BranchProtectionSettings {\n    fn default() -> Self {\n        Self {\n            required_approvals: 1,\n            require_status_checks: true,\n            require_conversation_resolution: true,\n            require_linear_history: true,\n            block_force_push: true,\n            block_deletions: true,\n            enforce_admins: true,\n            require_signed_commits: false,\n        }\n    }\n}\n\n/// GitHub repository settings\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct GitHubRepoSettings {\n    pub enable_discussions: Option<bool>,\n    pub enable_issues: Option<bool>,\n    pub enable_wiki: Option<bool>,\n    pub enable_vulnerability_alerts: Option<bool>,\n    pub enable_automated_security_fixes: Option<bool>,\n}\n\n/// A collection of actions to perform\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ActionPlan {\n    actions: Vec<Action>,\n}\n\nimpl ActionPlan {\n    /// Create a new empty action plan\n    pub fn new() -> Self {\n        Self {\n            actions: Vec::new(),\n        }\n    }\n\n    /// Add an action to the plan\n    pub fn add(&mut self, action: Action) {\n        self.actions.push(action);\n    }\n\n    /// Get all actions\n    pub fn actions(&self) -> &[Action] {\n        &self.actions\n    }\n\n    /// Check if the plan is empty\n    pub fn is_empty(&self) -> bool {\n        self.actions.is_empty()\n    }\n\n    /// Get the number of actions\n    #[allow(dead_code)]\n    pub fn len(&self) -> usize {\n        self.actions.len()\n    }\n\n    /// Filter to only include specific action categories\n    pub fn filter_only(&mut self, categories: &[String]) {\n        self.actions\n            .retain(|a| categories.contains(&a.category.to_string()));\n    }\n\n    /// Filter to skip specific action categories\n    pub fn filter_skip(&mut self, categories: &[String]) {\n        self.actions\n            .retain(|a| !categories.contains(&a.category.to_string()));\n    }\n}\n\nimpl Default for ActionPlan {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n","traces":[{"line":22,"address":[1140221,1139587,1139617,1138992,1139632,1140265],"length":1,"stats":{"Line":6}},{"line":29,"address":[48618,49229],"length":1,"stats":{"Line":8}},{"line":30,"address":[],"length":0,"stats":{"Line":8}},{"line":31,"address":[],"length":0,"stats":{"Line":10}},{"line":32,"address":[1139348,1139985],"length":1,"stats":{"Line":10}},{"line":38,"address":[1140288,1140464,1140438,1140635],"length":1,"stats":{"Line":2}},{"line":39,"address":[1140517,1140385,1140320,1140582],"length":1,"stats":{"Line":4}},{"line":40,"address":[49938,50135],"length":1,"stats":{"Line":2}},{"line":44,"address":[1140656,1140810],"length":1,"stats":{"Line":3}},{"line":45,"address":[50380,50206,50352,50269],"length":1,"stats":{"Line":16}},{"line":46,"address":[1140790],"length":1,"stats":{"Line":5}},{"line":50,"address":[482032],"length":1,"stats":{"Line":3}},{"line":51,"address":[482037],"length":1,"stats":{"Line":3}},{"line":55,"address":[482048],"length":1,"stats":{"Line":0}},{"line":56,"address":[1017925],"length":1,"stats":{"Line":0}},{"line":60,"address":[482064],"length":1,"stats":{"Line":2}},{"line":61,"address":[482069],"length":1,"stats":{"Line":2}},{"line":65,"address":[482080],"length":1,"stats":{"Line":0}},{"line":66,"address":[1017957],"length":1,"stats":{"Line":0}},{"line":70,"address":[482112],"length":1,"stats":{"Line":3}},{"line":71,"address":[1017992],"length":1,"stats":{"Line":3}},{"line":112,"address":[482128],"length":1,"stats":{"Line":0}},{"line":144,"address":[482176],"length":1,"stats":{"Line":4}},{"line":146,"address":[1018061],"length":1,"stats":{"Line":4}},{"line":151,"address":[482240],"length":1,"stats":{"Line":4}},{"line":152,"address":[1018117],"length":1,"stats":{"Line":4}},{"line":156,"address":[482272],"length":1,"stats":{"Line":4}},{"line":157,"address":[1018149],"length":1,"stats":{"Line":4}},{"line":161,"address":[482288],"length":1,"stats":{"Line":2}},{"line":162,"address":[1018165],"length":1,"stats":{"Line":2}},{"line":167,"address":[482304],"length":1,"stats":{"Line":0}},{"line":168,"address":[482309],"length":1,"stats":{"Line":0}},{"line":172,"address":[482320],"length":1,"stats":{"Line":0}},{"line":173,"address":[1018210],"length":1,"stats":{"Line":0}},{"line":174,"address":[1140896,1140910],"length":1,"stats":{"Line":0}},{"line":178,"address":[482352],"length":1,"stats":{"Line":0}},{"line":179,"address":[482370],"length":1,"stats":{"Line":0}},{"line":180,"address":[1141070,1141056],"length":1,"stats":{"Line":0}},{"line":185,"address":[482384],"length":1,"stats":{"Line":0}},{"line":186,"address":[482392],"length":1,"stats":{"Line":0}}],"covered":25,"coverable":40},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","planner.rs"],"content":"//! Action planner - Creates action plans based on audit results\n//!\n//! This module provides functionality to generate action plans from audit results.\n//! It analyzes findings and creates appropriate actions to fix issues.\n\nuse std::collections::HashMap;\n\nuse crate::config::Config;\nuse crate::rules::results::AuditResults;\n\nuse super::plan::{\n    Action, ActionOperation, ActionPlan, BranchProtectionSettings, GitHubRepoSettings,\n};\n\n/// Parameters for planning file creation\nstruct FileCreationParams<'a> {\n    rule_id: &'a str,\n    file_path: &'a str,\n    template: &'a str,\n    action_id: &'a str,\n    action_description: &'a str,\n    detail: Option<&'a str>,\n}\n\n/// Creates action plans based on audit results and configuration\n///\n/// The `ActionPlanner` analyzes audit findings and generates a plan of actions\n/// to fix detected issues. Actions can include:\n/// - Creating missing files (LICENSE, CONTRIBUTING.md, etc.)\n/// - Updating .gitignore\n/// - Configuring branch protection\n/// - Updating GitHub repository settings\npub struct ActionPlanner {\n    /// Configuration for action planning\n    config: Config,\n}\n\nimpl ActionPlanner {\n    /// Create a new action planner with the given configuration\n    ///\n    /// # Arguments\n    ///\n    /// * `config` - The configuration that determines which actions to plan\n    ///\n    /// # Returns\n    ///\n    /// A new `ActionPlanner` instance\n    pub fn new(config: Config) -> Self {\n        Self { config }\n    }\n\n    /// Create an action plan based on audit results\n    ///\n    /// Analyzes the audit results and generates actions to fix detected issues.\n    /// Only actions enabled in the configuration will be included.\n    ///\n    /// # Arguments\n    ///\n    /// * `results` - The audit results to analyze\n    ///\n    /// # Returns\n    ///\n    /// An `ActionPlan` containing all planned actions\n    pub fn create_plan(&self, results: &AuditResults) -> ActionPlan {\n        let mut plan = ActionPlan::new();\n\n        // Plan gitignore updates\n        if self.config.actions.gitignore {\n            if let Some(action) = self.plan_gitignore_update(results) {\n                plan.add(action);\n            }\n        }\n\n        // Plan license creation\n        if self.config.actions.license.enabled {\n            if let Some(action) = self.plan_license_creation(results) {\n                plan.add(action);\n            }\n        }\n\n        // Plan CONTRIBUTING creation\n        if self.config.actions.contributing {\n            if let Some(action) = self.plan_contributing_creation(results) {\n                plan.add(action);\n            }\n        }\n\n        // Plan CODE_OF_CONDUCT creation\n        if self.config.actions.code_of_conduct {\n            if let Some(action) = self.plan_code_of_conduct_creation(results) {\n                plan.add(action);\n            }\n        }\n\n        // Plan SECURITY.md creation\n        if self.config.actions.security_policy {\n            if let Some(action) = self.plan_security_creation(results) {\n                plan.add(action);\n            }\n        }\n\n        // Plan branch protection\n        if self.config.actions.branch_protection.enabled {\n            plan.add(self.plan_branch_protection());\n        }\n\n        // Plan GitHub settings\n        plan.add(self.plan_github_settings());\n\n        plan\n    }\n\n    /// Plan .gitignore updates based on findings\n    ///\n    /// Collects entries that should be added to .gitignore from audit findings\n    /// and adds standard entries if they're missing.\n    ///\n    /// # Arguments\n    ///\n    /// * `results` - The audit results\n    ///\n    /// # Returns\n    ///\n    /// An `Action` to update .gitignore, or `None` if no updates are needed\n    fn plan_gitignore_update(&self, results: &AuditResults) -> Option<Action> {\n        // Collect entries that should be added to .gitignore\n        let mut entries = Vec::new();\n\n        // Check findings for missing gitignore entries\n        for finding in results.findings_by_category(\"files\") {\n            if finding.rule_id == \"FILE003\" {\n                // Extract the pattern from the message\n                if let Some(pattern) = finding.message.split(\"entry: \").nth(1) {\n                    entries.push(pattern.to_string());\n                }\n            }\n        }\n\n        // Add standard entries if not present\n        let standard_entries = [\".env\", \"*.key\", \"*.pem\", \".DS_Store\"];\n        for entry in standard_entries {\n            if !entries.contains(&entry.to_string()) {\n                entries.push(entry.to_string());\n            }\n        }\n\n        if entries.is_empty() {\n            return None;\n        }\n\n        Some(\n            Action::new(\n                \"gitignore-update\",\n                \"gitignore\",\n                \"Add entries to .gitignore\",\n                ActionOperation::UpdateGitignore {\n                    entries: entries.clone(),\n                },\n            )\n            .with_details(entries),\n        )\n    }\n\n    /// Plan LICENSE file creation\n    ///\n    /// Creates a LICENSE file if one is missing and license creation is enabled.\n    ///\n    /// # Arguments\n    ///\n    /// * `results` - The audit results\n    ///\n    /// # Returns\n    ///\n    /// An `Action` to create LICENSE, or `None` if not needed\n    fn plan_license_creation(&self, results: &AuditResults) -> Option<Action> {\n        // Check if LICENSE is missing\n        let needs_license = results\n            .findings_by_category(\"docs\")\n            .any(|f| f.rule_id == \"DOC004\");\n\n        if !needs_license {\n            return None;\n        }\n\n        let license_type = &self.config.actions.license.license_type;\n        let mut variables = HashMap::new();\n\n        if let Some(author) = &self.config.actions.license.author {\n            variables.insert(\"author\".to_string(), author.clone());\n        }\n\n        let year = self\n            .config\n            .actions\n            .license\n            .year\n            .clone()\n            .unwrap_or_else(|| chrono::Utc::now().format(\"%Y\").to_string());\n        variables.insert(\"year\".to_string(), year);\n\n        Some(\n            Action::new(\n                \"license-create\",\n                \"file\",\n                \"Create LICENSE file\",\n                ActionOperation::CreateFile {\n                    path: \"LICENSE\".to_string(),\n                    template: format!(\"LICENSE/{}\", license_type),\n                    variables,\n                },\n            )\n            .with_detail(format!(\"License type: {}\", license_type)),\n        )\n    }\n\n    /// Generic helper to plan file creation from template\n    ///\n    /// # Arguments\n    ///\n    /// * `results` - The audit results\n    /// * `params` - Parameters for file creation\n    ///\n    /// # Returns\n    ///\n    /// An `Action` if the file needs to be created, `None` otherwise\n    fn plan_file_creation(\n        &self,\n        results: &AuditResults,\n        params: FileCreationParams<'_>,\n    ) -> Option<Action> {\n        let needs_file = results\n            .findings_by_category(\"docs\")\n            .any(|f| f.rule_id == params.rule_id);\n\n        if !needs_file {\n            return None;\n        }\n\n        let mut action = Action::new(\n            params.action_id,\n            \"file\",\n            params.action_description,\n            ActionOperation::CreateFile {\n                path: params.file_path.to_string(),\n                template: params.template.to_string(),\n                variables: HashMap::new(),\n            },\n        );\n\n        if let Some(detail) = params.detail {\n            action = action.with_detail(detail);\n        }\n\n        Some(action)\n    }\n\n    fn plan_contributing_creation(&self, results: &AuditResults) -> Option<Action> {\n        self.plan_file_creation(\n            results,\n            FileCreationParams {\n                rule_id: \"DOC005\",\n                file_path: \"CONTRIBUTING.md\",\n                template: \"CONTRIBUTING.md\",\n                action_id: \"contributing-create\",\n                action_description: \"Create CONTRIBUTING.md\",\n                detail: None,\n            },\n        )\n    }\n\n    fn plan_code_of_conduct_creation(&self, results: &AuditResults) -> Option<Action> {\n        self.plan_file_creation(\n            results,\n            FileCreationParams {\n                rule_id: \"DOC006\",\n                file_path: \"CODE_OF_CONDUCT.md\",\n                template: \"CODE_OF_CONDUCT.md\",\n                action_id: \"coc-create\",\n                action_description: \"Create CODE_OF_CONDUCT.md\",\n                detail: Some(\"Using Contributor Covenant template\"),\n            },\n        )\n    }\n\n    fn plan_security_creation(&self, results: &AuditResults) -> Option<Action> {\n        self.plan_file_creation(\n            results,\n            FileCreationParams {\n                rule_id: \"DOC007\",\n                file_path: \"SECURITY.md\",\n                template: \"SECURITY.md\",\n                action_id: \"security-create\",\n                action_description: \"Create SECURITY.md\",\n                detail: None,\n            },\n        )\n    }\n\n    /// Plan branch protection configuration\n    ///\n    /// Creates an action to configure branch protection settings based on\n    /// the configuration.\n    ///\n    /// # Returns\n    ///\n    /// An `Action` to configure branch protection\n    fn plan_branch_protection(&self) -> Action {\n        let bp = &self.config.actions.branch_protection;\n\n        let settings = BranchProtectionSettings {\n            required_approvals: bp.required_approvals,\n            require_status_checks: bp.require_status_checks,\n            require_conversation_resolution: true,\n            require_linear_history: true,\n            block_force_push: bp.block_force_push,\n            block_deletions: true,\n            enforce_admins: true,\n            require_signed_commits: bp.require_signed_commits,\n        };\n\n        let mut details = vec![\n            format!(\"Require PR reviews: {}\", bp.required_approvals),\n            format!(\"Require status checks: {}\", bp.require_status_checks),\n            format!(\"Block force push: {}\", bp.block_force_push),\n        ];\n\n        if bp.require_signed_commits {\n            details.push(\"Require signed commits\".to_string());\n        }\n\n        Action::new(\n            \"branch-protection\",\n            \"github\",\n            format!(\"Enable branch protection on '{}'\", bp.branch),\n            ActionOperation::ConfigureBranchProtection {\n                branch: bp.branch.clone(),\n                settings,\n            },\n        )\n        .with_details(details)\n    }\n\n    /// Plan GitHub repository settings updates\n    ///\n    /// Creates an action to update GitHub repository settings like discussions,\n    /// vulnerability alerts, etc.\n    ///\n    /// # Returns\n    ///\n    /// An `Action` to update GitHub settings\n    fn plan_github_settings(&self) -> Action {\n        let gs = &self.config.actions.github_settings;\n\n        let settings = GitHubRepoSettings {\n            enable_discussions: Some(gs.discussions),\n            enable_issues: Some(gs.issues),\n            enable_wiki: Some(gs.wiki),\n            enable_vulnerability_alerts: Some(gs.vulnerability_alerts),\n            enable_automated_security_fixes: Some(gs.automated_security_fixes),\n        };\n\n        let mut details = Vec::new();\n\n        if gs.discussions {\n            details.push(\"Enable discussions\".to_string());\n        }\n        if gs.vulnerability_alerts {\n            details.push(\"Enable vulnerability alerts\".to_string());\n        }\n        if gs.automated_security_fixes {\n            details.push(\"Enable automated security fixes\".to_string());\n        }\n\n        Action::new(\n            \"github-settings\",\n            \"github\",\n            \"Update repository settings\",\n            ActionOperation::UpdateGitHubSettings { settings },\n        )\n        .with_details(details)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::Config;\n    use crate::rules::results::{AuditResults, Finding, Severity};\n\n    #[test]\n    fn test_create_plan_includes_gitignore() {\n        let config = Config::default();\n        let planner = ActionPlanner::new(config);\n\n        let mut results = AuditResults::new(\"test-repo\", \"opensource\");\n        results.add_finding(Finding::new(\n            \"FILE003\",\n            \"files\",\n            Severity::Info,\n            \".gitignore missing recommended entry: .env\",\n        ));\n\n        let plan = planner.create_plan(&results);\n\n        assert!(!plan.is_empty());\n        assert!(plan.actions().iter().any(|a| a.id() == \"gitignore-update\"));\n    }\n\n    #[test]\n    fn test_create_plan_includes_license() {\n        let config = Config::default();\n        let planner = ActionPlanner::new(config);\n\n        let mut results = AuditResults::new(\"test-repo\", \"opensource\");\n        results.add_finding(Finding::new(\n            \"DOC004\",\n            \"docs\",\n            Severity::Critical,\n            \"LICENSE file is missing\",\n        ));\n\n        let plan = planner.create_plan(&results);\n\n        assert!(plan.actions().iter().any(|a| a.id() == \"license-create\"));\n    }\n\n    #[test]\n    fn test_create_plan_includes_contributing() {\n        let config = Config::default();\n        let planner = ActionPlanner::new(config);\n\n        let mut results = AuditResults::new(\"test-repo\", \"opensource\");\n        results.add_finding(Finding::new(\n            \"DOC005\",\n            \"docs\",\n            Severity::Warning,\n            \"CONTRIBUTING file is missing\",\n        ));\n\n        let plan = planner.create_plan(&results);\n\n        assert!(plan\n            .actions()\n            .iter()\n            .any(|a| a.id() == \"contributing-create\"));\n    }\n\n    #[test]\n    fn test_create_plan_filters_by_config() {\n        let mut config = Config::default();\n        config.actions.contributing = false;\n\n        let planner = ActionPlanner::new(config);\n\n        let mut results = AuditResults::new(\"test-repo\", \"opensource\");\n        results.add_finding(Finding::new(\n            \"DOC005\",\n            \"docs\",\n            Severity::Warning,\n            \"CONTRIBUTING file is missing\",\n        ));\n\n        let plan = planner.create_plan(&results);\n\n        // Should not include contributing because it's disabled in config\n        assert!(!plan\n            .actions()\n            .iter()\n            .any(|a| a.id() == \"contributing-create\"));\n    }\n}\n","traces":[{"line":48,"address":[672592],"length":1,"stats":{"Line":8}},{"line":64,"address":[1152640,1154059,1154053],"length":1,"stats":{"Line":8}},{"line":65,"address":[1152683],"length":1,"stats":{"Line":8}},{"line":68,"address":[1152738,1152984],"length":1,"stats":{"Line":14}},{"line":69,"address":[1152829,1152785],"length":1,"stats":{"Line":10}},{"line":70,"address":[1152921,1152964],"length":1,"stats":{"Line":8}},{"line":75,"address":[1152752,1153213],"length":1,"stats":{"Line":5}},{"line":76,"address":[1153042],"length":1,"stats":{"Line":6}},{"line":77,"address":[1153193,1153147],"length":1,"stats":{"Line":4}},{"line":82,"address":[1153006,1153445],"length":1,"stats":{"Line":5}},{"line":83,"address":[673258],"length":1,"stats":{"Line":4}},{"line":84,"address":[1153425,1153379],"length":1,"stats":{"Line":4}},{"line":89,"address":[673222,673661],"length":1,"stats":{"Line":4}},{"line":90,"address":[1153506],"length":1,"stats":{"Line":2}},{"line":91,"address":[1153657,1153611],"length":1,"stats":{"Line":0}},{"line":96,"address":[1153907,1153470],"length":1,"stats":{"Line":6}},{"line":97,"address":[673722],"length":1,"stats":{"Line":3}},{"line":98,"address":[1153887,1153841],"length":1,"stats":{"Line":0}},{"line":103,"address":[1153702],"length":1,"stats":{"Line":4}},{"line":104,"address":[1153960],"length":1,"stats":{"Line":4}},{"line":108,"address":[673986,673924],"length":1,"stats":{"Line":7}},{"line":110,"address":[1154019],"length":1,"stats":{"Line":4}},{"line":125,"address":[1154080,1155739,1155469],"length":1,"stats":{"Line":8}},{"line":127,"address":[1154127],"length":1,"stats":{"Line":8}},{"line":130,"address":[1154252,1154168],"length":1,"stats":{"Line":16}},{"line":131,"address":[1154417,1155482],"length":1,"stats":{"Line":4}},{"line":133,"address":[675483],"length":1,"stats":{"Line":2}},{"line":134,"address":[1155681],"length":1,"stats":{"Line":2}},{"line":140,"address":[674425],"length":1,"stats":{"Line":6}},{"line":141,"address":[1154549,1154737],"length":1,"stats":{"Line":12}},{"line":142,"address":[1155258,1154826],"length":1,"stats":{"Line":10}},{"line":143,"address":[1155411],"length":1,"stats":{"Line":7}},{"line":147,"address":[674857],"length":1,"stats":{"Line":5}},{"line":148,"address":[1154948],"length":1,"stats":{"Line":0}},{"line":152,"address":[1155171,1155038],"length":1,"stats":{"Line":12}},{"line":156,"address":[1154988],"length":1,"stats":{"Line":5}},{"line":157,"address":[1154906],"length":1,"stats":{"Line":7}},{"line":160,"address":[1155107],"length":1,"stats":{"Line":5}},{"line":175,"address":[1156312,1155776,1157257],"length":1,"stats":{"Line":2}},{"line":177,"address":[1155827],"length":1,"stats":{"Line":6}},{"line":179,"address":[683273,683248],"length":1,"stats":{"Line":6}},{"line":181,"address":[1155903],"length":1,"stats":{"Line":2}},{"line":182,"address":[1155912],"length":1,"stats":{"Line":4}},{"line":185,"address":[1155932],"length":1,"stats":{"Line":2}},{"line":186,"address":[1155941],"length":1,"stats":{"Line":2}},{"line":188,"address":[1155964,1156036],"length":1,"stats":{"Line":2}},{"line":189,"address":[1156044,1156182,1156155],"length":1,"stats":{"Line":0}},{"line":192,"address":[1156318,1156080],"length":1,"stats":{"Line":4}},{"line":198,"address":[676332],"length":1,"stats":{"Line":6}},{"line":199,"address":[1156428,1156356],"length":1,"stats":{"Line":4}},{"line":202,"address":[1156884,1157126],"length":1,"stats":{"Line":4}},{"line":206,"address":[676756],"length":1,"stats":{"Line":2}},{"line":207,"address":[1156523],"length":1,"stats":{"Line":2}},{"line":208,"address":[1156622,1156554],"length":1,"stats":{"Line":4}},{"line":209,"address":[1156722],"length":1,"stats":{"Line":2}},{"line":212,"address":[1156961,1157170,1156985,1157225],"length":1,"stats":{"Line":4}},{"line":226,"address":[1157296,1158031],"length":1,"stats":{"Line":4}},{"line":231,"address":[677331],"length":1,"stats":{"Line":4}},{"line":233,"address":[683481,683456],"length":1,"stats":{"Line":6}},{"line":235,"address":[677380],"length":1,"stats":{"Line":2}},{"line":236,"address":[1157405],"length":1,"stats":{"Line":2}},{"line":240,"address":[1157425],"length":1,"stats":{"Line":2}},{"line":242,"address":[677427],"length":1,"stats":{"Line":2}},{"line":243,"address":[677618],"length":1,"stats":{"Line":2}},{"line":244,"address":[1157461],"length":1,"stats":{"Line":2}},{"line":245,"address":[1157501],"length":1,"stats":{"Line":2}},{"line":246,"address":[677570],"length":1,"stats":{"Line":2}},{"line":250,"address":[677812],"length":1,"stats":{"Line":2}},{"line":251,"address":[1157894],"length":1,"stats":{"Line":0}},{"line":254,"address":[677961],"length":1,"stats":{"Line":2}},{"line":257,"address":[1158064],"length":1,"stats":{"Line":4}},{"line":258,"address":[1158225],"length":1,"stats":{"Line":3}},{"line":260,"address":[1158100],"length":1,"stats":{"Line":4}},{"line":266,"address":[1158091],"length":1,"stats":{"Line":4}},{"line":271,"address":[1158256],"length":1,"stats":{"Line":2}},{"line":272,"address":[1158429],"length":1,"stats":{"Line":2}},{"line":274,"address":[678288],"length":1,"stats":{"Line":2}},{"line":280,"address":[1158283],"length":1,"stats":{"Line":2}},{"line":285,"address":[1158464],"length":1,"stats":{"Line":3}},{"line":286,"address":[678609],"length":1,"stats":{"Line":4}},{"line":288,"address":[678484],"length":1,"stats":{"Line":3}},{"line":294,"address":[678475],"length":1,"stats":{"Line":3}},{"line":307,"address":[680083,680089,678640],"length":1,"stats":{"Line":4}},{"line":308,"address":[1158684],"length":1,"stats":{"Line":4}},{"line":311,"address":[1158723],"length":1,"stats":{"Line":4}},{"line":312,"address":[678728],"length":1,"stats":{"Line":4}},{"line":315,"address":[678734],"length":1,"stats":{"Line":4}},{"line":318,"address":[678740],"length":1,"stats":{"Line":5}},{"line":321,"address":[678792,678831,679151,679295,678982,679508,680118],"length":1,"stats":{"Line":6}},{"line":322,"address":[1158823,1158879],"length":1,"stats":{"Line":7}},{"line":323,"address":[679023,678959],"length":1,"stats":{"Line":7}},{"line":324,"address":[1159144,1159211],"length":1,"stats":{"Line":7}},{"line":327,"address":[1159516],"length":1,"stats":{"Line":5}},{"line":328,"address":[1159561,1159633],"length":1,"stats":{"Line":0}},{"line":334,"address":[1159669,1159542],"length":1,"stats":{"Line":8}},{"line":335,"address":[1159842],"length":1,"stats":{"Line":5}},{"line":336,"address":[1159782],"length":1,"stats":{"Line":3}},{"line":340,"address":[1159999],"length":1,"stats":{"Line":5}},{"line":351,"address":[1160144,1160785,1160814],"length":1,"stats":{"Line":4}},{"line":352,"address":[1160174],"length":1,"stats":{"Line":5}},{"line":355,"address":[1160206],"length":1,"stats":{"Line":5}},{"line":356,"address":[680202],"length":1,"stats":{"Line":5}},{"line":357,"address":[1160230],"length":1,"stats":{"Line":3}},{"line":358,"address":[1160242],"length":1,"stats":{"Line":3}},{"line":359,"address":[1160254],"length":1,"stats":{"Line":6}},{"line":362,"address":[1160306],"length":1,"stats":{"Line":5}},{"line":364,"address":[1160330],"length":1,"stats":{"Line":7}},{"line":365,"address":[680336,680405],"length":1,"stats":{"Line":12}},{"line":367,"address":[1160344],"length":1,"stats":{"Line":4}},{"line":368,"address":[1160468],"length":1,"stats":{"Line":4}},{"line":370,"address":[1160456],"length":1,"stats":{"Line":3}},{"line":371,"address":[1160635],"length":1,"stats":{"Line":4}},{"line":378,"address":[1160526],"length":1,"stats":{"Line":4}},{"line":380,"address":[1160707],"length":1,"stats":{"Line":4}}],"covered":108,"coverable":114},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","templates.rs"],"content":"//! Template file creation\n\nuse crate::error::{ActionError, RepoLensError};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\n/// Create a file from a template\npub fn create_file_from_template(\n    path: &str,\n    template_name: &str,\n    variables: &HashMap<String, String>,\n) -> Result<(), RepoLensError> {\n    let template_content = get_template(template_name)?;\n\n    // Replace variables in template\n    let mut content = template_content;\n    for (key, value) in variables {\n        content = content.replace(&format!(\"{{{{ {} }}}}\", key), value);\n        content = content.replace(&format!(\"{{{{{}}}}}\", key), value);\n    }\n\n    // Write the file\n    let file_path = Path::new(path);\n\n    // Create parent directories if needed\n    if let Some(parent) = file_path.parent() {\n        if !parent.as_os_str().is_empty() {\n            fs::create_dir_all(parent).map_err(|e| {\n                RepoLensError::Action(ActionError::DirectoryCreate {\n                    path: parent.display().to_string(),\n                    source: e,\n                })\n            })?;\n        }\n    }\n\n    fs::write(file_path, content).map_err(|e| {\n        RepoLensError::Action(ActionError::FileWrite {\n            path: path.to_string(),\n            source: e,\n        })\n    })?;\n\n    Ok(())\n}\n\n/// Get template content by name\nfn get_template(name: &str) -> Result<String, RepoLensError> {\n    match name {\n        \"LICENSE/MIT\" => Ok(MIT_LICENSE.to_string()),\n        \"LICENSE/Apache-2.0\" => Ok(APACHE_LICENSE.to_string()),\n        \"LICENSE/GPL-3.0\" => Ok(GPL_LICENSE_HEADER.to_string()),\n        \"CONTRIBUTING.md\" => Ok(CONTRIBUTING_TEMPLATE.to_string()),\n        \"CODE_OF_CONDUCT.md\" => Ok(CODE_OF_CONDUCT_TEMPLATE.to_string()),\n        \"SECURITY.md\" => Ok(SECURITY_TEMPLATE.to_string()),\n        \"ISSUE_TEMPLATE/bug_report.md\" => Ok(BUG_REPORT_TEMPLATE.to_string()),\n        \"ISSUE_TEMPLATE/feature_request.md\" => Ok(FEATURE_REQUEST_TEMPLATE.to_string()),\n        \"PULL_REQUEST_TEMPLATE/pull_request_template.md\" => Ok(PULL_REQUEST_TEMPLATE.to_string()),\n        _ => Err(RepoLensError::Action(ActionError::UnknownTemplate {\n            name: name.to_string(),\n        })),\n    }\n}\n\nconst MIT_LICENSE: &str = r#\"MIT License\n\nCopyright (c) {{ year }} {{ author }}\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"#;\n\nconst APACHE_LICENSE: &str = r#\"                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   Copyright {{ year }} {{ author }}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\"#;\n\nconst GPL_LICENSE_HEADER: &str = r#\"Copyright (C) {{ year }} {{ author }}\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"#;\n\nconst CONTRIBUTING_TEMPLATE: &str = r#\"# Contributing\n\nThank you for your interest in contributing to this project!\n\n## How to Contribute\n\n### Reporting Issues\n\n- Check if the issue already exists\n- Use a clear and descriptive title\n- Provide steps to reproduce the issue\n- Include relevant logs or screenshots\n\n### Pull Requests\n\n1. Fork the repository\n2. Create a feature branch (`git checkout -b feature/amazing-feature`)\n3. Make your changes\n4. Run tests to ensure everything works\n5. Commit your changes (`git commit -m 'Add amazing feature'`)\n6. Push to the branch (`git push origin feature/amazing-feature`)\n7. Open a Pull Request\n\n### Code Style\n\n- Follow the existing code style\n- Write meaningful commit messages\n- Add tests for new features\n- Update documentation as needed\n\n### Development Setup\n\n```bash\n# Clone the repository\ngit clone <repository-url>\ncd <project>\n\n# Install dependencies\n# Add project-specific setup instructions here\n```\n\n## Questions?\n\nFeel free to open an issue for any questions or concerns.\n\"#;\n\nconst CODE_OF_CONDUCT_TEMPLATE: &str = r#\"# Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, caste, color, religion, or sexual\nidentity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior:\n\n* The use of sexualized language or imagery, and sexual attention or advances\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information without explicit permission\n* Other conduct which could reasonably be considered inappropriate\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the project maintainers. All complaints will be reviewed and\ninvestigated promptly and fairly.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org),\nversion 2.1.\n\"#;\n\nconst SECURITY_TEMPLATE: &str = r#\"# Security Policy\n\n## Reporting a Vulnerability\n\nWe take security seriously. If you discover a security vulnerability, please follow these steps:\n\n1. **Do not** open a public issue\n2. Email us at [security@example.com] with details\n3. Include steps to reproduce the vulnerability\n4. Allow time for us to investigate and respond\n\n## What to Include\n\n- Type of vulnerability\n- Steps to reproduce\n- Potential impact\n- Suggested fix (if any)\n\n## Response Timeline\n\n- **Initial Response**: Within 48 hours\n- **Status Update**: Within 7 days\n- **Resolution**: Depends on severity and complexity\n\n## Supported Versions\n\n| Version | Supported          |\n| ------- | ------------------ |\n| latest  | :white_check_mark: |\n| < 1.0   | :x:                |\n\n## Security Best Practices\n\nWhen using this project:\n\n- Keep dependencies up to date\n- Use environment variables for secrets\n- Follow the principle of least privilege\n- Enable security features where available\n\nThank you for helping keep this project secure!\n\"#;\n\nconst BUG_REPORT_TEMPLATE: &str = r#\"---\nname: Bug Report\nabout: Create a report to help us improve\ntitle: ''\nlabels: bug\nassignees: ''\n---\n\n## Description\n\nA clear and concise description of what the bug is.\n\n## Steps to Reproduce\n\n1. Go to '...'\n2. Click on '....'\n3. Scroll down to '....'\n4. See error\n\n## Expected Behavior\n\nA clear and concise description of what you expected to happen.\n\n## Actual Behavior\n\nA clear and concise description of what actually happened.\n\n## Environment\n\n- OS: [e.g. Ubuntu 22.04, macOS 13.0, Windows 11]\n- Version: [e.g. 0.1.0]\n- Rust version: [e.g. 1.70.0]\n\n## Additional Context\n\nAdd any other context about the problem here.\n\n## Screenshots\n\nIf applicable, add screenshots to help explain your problem.\n\"#;\n\nconst FEATURE_REQUEST_TEMPLATE: &str = r#\"---\nname: Feature Request\nabout: Suggest an idea for this project\ntitle: ''\nlabels: enhancement\nassignees: ''\n---\n\n## Problem Statement\n\nA clear and concise description of what the problem is. Ex. I'm always frustrated when [...]\n\n## Proposed Solution\n\nA clear and concise description of what you want to happen.\n\n## Alternatives Considered\n\nA clear and concise description of any alternative solutions or features you've considered.\n\n## Use Cases\n\nDescribe the use cases for this feature:\n\n1. Use case 1\n2. Use case 2\n3. Use case 3\n\n## Additional Context\n\nAdd any other context, mockups, or examples about the feature request here.\n\n## Implementation Notes (Optional)\n\nIf you have ideas about how this could be implemented, please share them here.\n\"#;\n\nconst PULL_REQUEST_TEMPLATE: &str = r#\"## Description\n\nBrief description of changes.\n\n## Type of Change\n\n- [ ] Bug fix\n- [ ] New feature\n- [ ] Documentation update\n- [ ] Refactoring\n\n## Checklist\n\n- [ ] Code compiles without errors\n- [ ] Tests pass\n- [ ] Code follows project style guidelines\n- [ ] Documentation updated if needed\n\"#;\n","traces":[{"line":9,"address":[509969,509997,507584],"length":1,"stats":{"Line":2}},{"line":14,"address":[507709],"length":1,"stats":{"Line":2}},{"line":17,"address":[507926],"length":1,"stats":{"Line":2}},{"line":18,"address":[508030,507982],"length":1,"stats":{"Line":4}},{"line":19,"address":[1519777,1518854,1520035],"length":1,"stats":{"Line":0}},{"line":20,"address":[509824,509529],"length":1,"stats":{"Line":0}},{"line":24,"address":[508240],"length":1,"stats":{"Line":2}},{"line":27,"address":[508321],"length":1,"stats":{"Line":2}},{"line":28,"address":[508571,508453],"length":1,"stats":{"Line":4}},{"line":29,"address":[884594,884588,884368],"length":1,"stats":{"Line":0}},{"line":30,"address":[1116436],"length":1,"stats":{"Line":0}},{"line":31,"address":[1116319,1116397],"length":1,"stats":{"Line":0}},{"line":32,"address":[1116431],"length":1,"stats":{"Line":0}},{"line":38,"address":[1116698,1116528,1116692],"length":1,"stats":{"Line":4}},{"line":39,"address":[1116623],"length":1,"stats":{"Line":0}},{"line":40,"address":[1116556],"length":1,"stats":{"Line":0}},{"line":41,"address":[1116618],"length":1,"stats":{"Line":0}},{"line":45,"address":[508971],"length":1,"stats":{"Line":2}},{"line":49,"address":[1520688],"length":1,"stats":{"Line":2}},{"line":51,"address":[510091,510145],"length":1,"stats":{"Line":3}},{"line":52,"address":[1520778,1520901],"length":1,"stats":{"Line":3}},{"line":53,"address":[510345,510222],"length":1,"stats":{"Line":3}},{"line":54,"address":[1521101,1520978],"length":1,"stats":{"Line":5}},{"line":55,"address":[510422,510548],"length":1,"stats":{"Line":2}},{"line":56,"address":[510525,510660],"length":1,"stats":{"Line":2}},{"line":57,"address":[510637,510772],"length":1,"stats":{"Line":2}},{"line":58,"address":[510749,510888],"length":1,"stats":{"Line":2}},{"line":59,"address":[511102,510861],"length":1,"stats":{"Line":2}},{"line":60,"address":[510991],"length":1,"stats":{"Line":2}},{"line":61,"address":[510977],"length":1,"stats":{"Line":2}}],"covered":21,"coverable":30},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","commands","apply.rs"],"content":"//! Apply command - Apply planned changes to the repository\n\nuse colored::Colorize;\nuse dialoguer::Confirm;\nuse std::path::PathBuf;\n\nuse super::ApplyArgs;\nuse crate::actions::executor::ActionExecutor;\nuse crate::actions::planner::ActionPlanner;\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::exit_codes;\nuse crate::rules::engine::RulesEngine;\nuse crate::scanner::Scanner;\n\npub async fn execute(args: ApplyArgs) -> Result<i32, RepoLensError> {\n    // Load configuration\n    let config = Config::load_or_default()?;\n\n    // Initialize scanner\n    let scanner = Scanner::new(PathBuf::from(\".\"));\n\n    // Run the rules engine to get current state\n    let engine = RulesEngine::new(config.clone());\n    let audit_results = engine.run(&scanner).await?;\n\n    // Generate action plan\n    let planner = ActionPlanner::new(config.clone());\n    let mut action_plan = planner.create_plan(&audit_results);\n\n    // Apply filters if specified\n    if let Some(only) = &args.only {\n        action_plan.filter_only(only);\n    }\n    if let Some(skip) = &args.skip {\n        action_plan.filter_skip(skip);\n    }\n\n    // Check if there are any actions to perform\n    if action_plan.is_empty() {\n        println!(\"{}\", \"No actions to perform.\".green());\n        return Ok(exit_codes::SUCCESS);\n    }\n\n    // Display plan summary\n    println!(\"{}\", \"Planned actions:\".bold());\n    println!();\n    for action in action_plan.actions() {\n        println!(\"  {} {}\", \"+\".green(), action.description());\n    }\n    println!();\n\n    // Dry run mode\n    if args.dry_run {\n        println!(\"{}\", \"Dry run mode - no changes made.\".yellow());\n        return Ok(exit_codes::SUCCESS);\n    }\n\n    // Confirm execution\n    if !args.yes {\n        let confirm = Confirm::new()\n            .with_prompt(\"Apply these changes?\")\n            .default(false)\n            .interact()\n            .map_err(|e| {\n                RepoLensError::Action(crate::error::ActionError::ExecutionFailed {\n                    message: format!(\"Failed to get user input: {}\", e),\n                })\n            })?;\n\n        if !confirm {\n            println!(\"{}\", \"Aborted.\".yellow());\n            return Ok(exit_codes::SUCCESS);\n        }\n    }\n\n    // Execute actions\n    let executor = ActionExecutor::new(config);\n    let results = executor.execute(&action_plan).await?;\n\n    // Display results\n    println!();\n    let mut success_count = 0;\n    let mut error_count = 0;\n\n    for result in &results {\n        if result.success {\n            println!(\"  {} {}\", \"‚úì\".green(), result.action_name);\n            success_count += 1;\n        } else {\n            println!(\n                \"  {} {} - {}\",\n                \"‚úó\".red(),\n                result.action_name,\n                result.error.as_deref().unwrap_or(\"Unknown error\")\n            );\n            error_count += 1;\n        }\n    }\n\n    println!();\n    println!(\n        \"{}: {} succeeded, {} failed\",\n        \"Summary\".bold(),\n        success_count.to_string().green(),\n        error_count.to_string().red()\n    );\n\n    if error_count > 0 {\n        Ok(exit_codes::ERROR)\n    } else {\n        Ok(exit_codes::SUCCESS)\n    }\n}\n","traces":[{"line":16,"address":[426272,426289],"length":1,"stats":{"Line":0}},{"line":18,"address":[1054926,1054165,1054311],"length":1,"stats":{"Line":0}},{"line":21,"address":[1054543,1054622],"length":1,"stats":{"Line":0}},{"line":24,"address":[1054723,1054652],"length":1,"stats":{"Line":0}},{"line":25,"address":[1054202,1054856,1058202,1054991,1054753],"length":1,"stats":{"Line":0}},{"line":28,"address":[1055632,1055558],"length":1,"stats":{"Line":0}},{"line":29,"address":[1055662],"length":1,"stats":{"Line":0}},{"line":32,"address":[1055751],"length":1,"stats":{"Line":0}},{"line":33,"address":[1056008,1055823],"length":1,"stats":{"Line":0}},{"line":35,"address":[1055872,1056028],"length":1,"stats":{"Line":0}},{"line":36,"address":[1056036,1056138],"length":1,"stats":{"Line":0}},{"line":40,"address":[1056154,1056085],"length":1,"stats":{"Line":0}},{"line":41,"address":[1031103,1029279],"length":1,"stats":{"Line":0}},{"line":42,"address":[1058174],"length":1,"stats":{"Line":0}},{"line":46,"address":[1056160,1056225],"length":1,"stats":{"Line":0}},{"line":47,"address":[1056384],"length":1,"stats":{"Line":0}},{"line":48,"address":[1029517],"length":1,"stats":{"Line":0}},{"line":49,"address":[1056632,1057759],"length":1,"stats":{"Line":0}},{"line":51,"address":[1056666],"length":1,"stats":{"Line":0}},{"line":54,"address":[1029799],"length":1,"stats":{"Line":0}},{"line":55,"address":[1057572,1056741],"length":1,"stats":{"Line":0}},{"line":56,"address":[1057731],"length":1,"stats":{"Line":0}},{"line":60,"address":[1056725],"length":1,"stats":{"Line":0}},{"line":61,"address":[1057397,1057093,1056775,1056884],"length":1,"stats":{"Line":0}},{"line":65,"address":[1061097,1061103,1060848],"length":1,"stats":{"Line":0}},{"line":66,"address":[1061019],"length":1,"stats":{"Line":0}},{"line":67,"address":[1034018,1033970],"length":1,"stats":{"Line":0}},{"line":71,"address":[1057145],"length":1,"stats":{"Line":0}},{"line":72,"address":[1057153],"length":1,"stats":{"Line":0}},{"line":73,"address":[1057343],"length":1,"stats":{"Line":0}},{"line":78,"address":[1056794],"length":1,"stats":{"Line":0}},{"line":79,"address":[1054223,1057502,1058229,1057399],"length":1,"stats":{"Line":0}},{"line":82,"address":[1058710,1058644],"length":1,"stats":{"Line":0}},{"line":83,"address":[1058729],"length":1,"stats":{"Line":0}},{"line":84,"address":[1058740],"length":1,"stats":{"Line":0}},{"line":86,"address":[1058759],"length":1,"stats":{"Line":0}},{"line":87,"address":[1033486,1031975,1033737],"length":1,"stats":{"Line":0}},{"line":88,"address":[1059994,1060423],"length":1,"stats":{"Line":0}},{"line":89,"address":[1033710,1033742],"length":1,"stats":{"Line":0}},{"line":91,"address":[1060222,1060028],"length":1,"stats":{"Line":0}},{"line":97,"address":[1060369,1060403],"length":1,"stats":{"Line":0}},{"line":101,"address":[1058902],"length":1,"stats":{"Line":0}},{"line":102,"address":[1058947],"length":1,"stats":{"Line":0}},{"line":109,"address":[1059617,1059650],"length":1,"stats":{"Line":0}},{"line":110,"address":[1059652],"length":1,"stats":{"Line":0}},{"line":112,"address":[1059627],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","commands","init.rs"],"content":"//! Init command - Initialize a new configuration file\n\nuse colored::Colorize;\nuse dialoguer::{Confirm, Select};\nuse std::fs;\nuse std::path::Path;\n\nuse super::InitArgs;\nuse crate::config::{Config, Preset};\nuse crate::error::{ActionError, RepoLensError};\nuse crate::utils::prerequisites::{\n    display_error_summary, display_report, display_warnings, run_all_checks, CheckOptions,\n};\n\nconst CONFIG_FILENAME: &str = \".repolens.toml\";\n\npub async fn execute(args: InitArgs) -> Result<i32, RepoLensError> {\n    let root = std::env::current_dir().map_err(|e| {\n        RepoLensError::Action(ActionError::ExecutionFailed {\n            message: format!(\"Failed to get current directory: {}\", e),\n        })\n    })?;\n    let config_path = Path::new(CONFIG_FILENAME);\n\n    // Run prerequisite checks unless skipped\n    if !args.skip_checks {\n        let options = CheckOptions::default();\n        let report = run_all_checks(&root, &options);\n        display_report(&report, false);\n\n        if !report.all_required_passed() {\n            display_error_summary(&report);\n\n            if args.non_interactive {\n                return Ok(crate::exit_codes::ERROR);\n            }\n\n            // Ask if user wants to continue anyway\n            let continue_anyway = Confirm::new()\n                .with_prompt(\"Continue anyway?\")\n                .default(false)\n                .interact()\n                .map_err(|e| {\n                    RepoLensError::Action(ActionError::ExecutionFailed {\n                        message: format!(\"Failed to get user input: {}\", e),\n                    })\n                })?;\n\n            if !continue_anyway {\n                return Ok(crate::exit_codes::ERROR);\n            }\n\n            println!();\n        } else if report.has_warnings() {\n            display_warnings(&report);\n        }\n    }\n\n    // Check if config already exists\n    if config_path.exists() && !args.force {\n        if args.non_interactive {\n            eprintln!(\n                \"{} Configuration file already exists. Use --force to overwrite.\",\n                \"Error:\".red().bold()\n            );\n            return Ok(1);\n        }\n\n        let overwrite = Confirm::new()\n            .with_prompt(\"Configuration file already exists. Overwrite?\")\n            .default(false)\n            .interact()\n            .map_err(|e| {\n                RepoLensError::Action(ActionError::ExecutionFailed {\n                    message: format!(\"Failed to get user input: {}\", e),\n                })\n            })?;\n\n        if !overwrite {\n            println!(\"{}\", \"Aborted.\".yellow());\n            return Ok(0);\n        }\n    }\n\n    // Determine preset\n    let preset = if let Some(preset_name) = args.preset {\n        Preset::from_name(&preset_name).ok_or(RepoLensError::Config(\n            crate::error::ConfigError::InvalidPreset { name: preset_name },\n        ))?\n    } else if args.non_interactive {\n        Preset::OpenSource\n    } else {\n        select_preset()?\n    };\n\n    // Create configuration\n    let config = Config::from_preset(preset);\n\n    // Write configuration file\n    let config_content = config.to_toml()?;\n    fs::write(config_path, &config_content).map_err(|e| {\n        RepoLensError::Action(ActionError::FileWrite {\n            path: config_path.display().to_string(),\n            source: e,\n        })\n    })?;\n\n    println!(\n        \"{} Created {} with preset '{}'\",\n        \"Success:\".green().bold(),\n        CONFIG_FILENAME.cyan(),\n        preset.name().yellow()\n    );\n\n    println!(\"\\nNext steps:\");\n    println!(\"  1. Review and customize {}\", CONFIG_FILENAME.cyan());\n    println!(\"  2. Run {} to see planned actions\", \"repolens plan\".cyan());\n    println!(\"  3. Run {} to apply changes\", \"repolens apply\".cyan());\n\n    Ok(0)\n}\n\nfn select_preset() -> Result<Preset, RepoLensError> {\n    let presets = [\n        (\n            \"opensource\",\n            \"Open Source - Prepare repository for public release\",\n        ),\n        (\"enterprise\", \"Enterprise - Internal company standards\"),\n        (\"strict\", \"Strict - Maximum security and compliance checks\"),\n    ];\n\n    let selection = Select::new()\n        .with_prompt(\"Select a preset\")\n        .items(&presets.iter().map(|(_, desc)| *desc).collect::<Vec<_>>())\n        .default(0)\n        .interact()\n        .map_err(|e| {\n            RepoLensError::Action(ActionError::ExecutionFailed {\n                message: format!(\"Failed to get user input: {}\", e),\n            })\n        })?;\n\n    Ok(match selection {\n        0 => Preset::OpenSource,\n        1 => Preset::Enterprise,\n        2 => Preset::Strict,\n        _ => Preset::OpenSource,\n    })\n}\n","traces":[{"line":17,"address":[840480,840615,841742,845094,845341,840510],"length":1,"stats":{"Line":0}},{"line":18,"address":[142912,138132,142797,143171,138255,138361,143165],"length":1,"stats":{"Line":0}},{"line":19,"address":[143087],"length":1,"stats":{"Line":0}},{"line":20,"address":[142998,142933],"length":1,"stats":{"Line":0}},{"line":23,"address":[138545,138458],"length":1,"stats":{"Line":0}},{"line":26,"address":[841025],"length":1,"stats":{"Line":0}},{"line":27,"address":[138610,138571],"length":1,"stats":{"Line":0}},{"line":28,"address":[138627],"length":1,"stats":{"Line":0}},{"line":29,"address":[138687],"length":1,"stats":{"Line":0}},{"line":31,"address":[841206],"length":1,"stats":{"Line":0}},{"line":32,"address":[138771],"length":1,"stats":{"Line":0}},{"line":34,"address":[138800],"length":1,"stats":{"Line":0}},{"line":35,"address":[138829],"length":1,"stats":{"Line":0}},{"line":39,"address":[139227,138810,138857,139066],"length":1,"stats":{"Line":0}},{"line":43,"address":[143439,143184,143433],"length":1,"stats":{"Line":0}},{"line":44,"address":[143355],"length":1,"stats":{"Line":0}},{"line":45,"address":[143218,143266],"length":1,"stats":{"Line":0}},{"line":49,"address":[139118],"length":1,"stats":{"Line":0}},{"line":50,"address":[139122],"length":1,"stats":{"Line":0}},{"line":53,"address":[139188,139147],"length":1,"stats":{"Line":0}},{"line":54,"address":[138786,139255],"length":1,"stats":{"Line":0}},{"line":55,"address":[139269],"length":1,"stats":{"Line":0}},{"line":60,"address":[138592,139340,139288],"length":1,"stats":{"Line":0}},{"line":61,"address":[139350],"length":1,"stats":{"Line":0}},{"line":62,"address":[139905,139379],"length":1,"stats":{"Line":0}},{"line":66,"address":[140091],"length":1,"stats":{"Line":0}},{"line":69,"address":[139622,139360,139900,139413],"length":1,"stats":{"Line":0}},{"line":73,"address":[143456,143711,143705],"length":1,"stats":{"Line":0}},{"line":74,"address":[143627],"length":1,"stats":{"Line":0}},{"line":75,"address":[143538,143490],"length":1,"stats":{"Line":0}},{"line":79,"address":[139674],"length":1,"stats":{"Line":0}},{"line":80,"address":[139682],"length":1,"stats":{"Line":0}},{"line":81,"address":[139872],"length":1,"stats":{"Line":0}},{"line":86,"address":[139294,140119],"length":1,"stats":{"Line":0}},{"line":87,"address":[140262,140367,140536,140175],"length":1,"stats":{"Line":0}},{"line":88,"address":[140277],"length":1,"stats":{"Line":0}},{"line":90,"address":[140587,140689,140841,140211,140621,140192],"length":1,"stats":{"Line":0}},{"line":91,"address":[140681],"length":1,"stats":{"Line":0}},{"line":93,"address":[140707,140846,140674],"length":1,"stats":{"Line":0}},{"line":97,"address":[843059],"length":1,"stats":{"Line":0}},{"line":100,"address":[142756,140867,140930],"length":1,"stats":{"Line":0}},{"line":101,"address":[843592,846412,846418,843777,843671,846192],"length":1,"stats":{"Line":0}},{"line":102,"address":[143876],"length":1,"stats":{"Line":0}},{"line":103,"address":[143837,143759],"length":1,"stats":{"Line":0}},{"line":104,"address":[143871],"length":1,"stats":{"Line":0}},{"line":108,"address":[843868,843970,844090],"length":1,"stats":{"Line":0}},{"line":115,"address":[141855],"length":1,"stats":{"Line":0}},{"line":116,"address":[844364],"length":1,"stats":{"Line":0}},{"line":117,"address":[142090],"length":1,"stats":{"Line":0}},{"line":118,"address":[844744],"length":1,"stats":{"Line":0}},{"line":120,"address":[142470],"length":1,"stats":{"Line":0}},{"line":123,"address":[507563,506544,507557],"length":1,"stats":{"Line":0}},{"line":124,"address":[506561,506731],"length":1,"stats":{"Line":0}},{"line":129,"address":[506623],"length":1,"stats":{"Line":0}},{"line":130,"address":[506677],"length":1,"stats":{"Line":0}},{"line":133,"address":[506821,507081,507349,507203,507120],"length":1,"stats":{"Line":0}},{"line":135,"address":[1223355,1223576,1223497,1223999],"length":1,"stats":{"Line":0}},{"line":138,"address":[144249,144000,144255],"length":1,"stats":{"Line":0}},{"line":139,"address":[846635],"length":1,"stats":{"Line":0}},{"line":140,"address":[846546,846498],"length":1,"stats":{"Line":0}},{"line":144,"address":[507489,507415],"length":1,"stats":{"Line":0}},{"line":145,"address":[507456],"length":1,"stats":{"Line":0}},{"line":146,"address":[507466],"length":1,"stats":{"Line":0}},{"line":147,"address":[507476],"length":1,"stats":{"Line":0}},{"line":148,"address":[507446],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":65},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","commands","mod.rs"],"content":"//! CLI commands module\n\npub mod apply;\npub mod init;\npub mod plan;\npub mod report;\n\nuse clap::Args;\nuse std::path::PathBuf;\n\n/// Arguments for the init command\n#[derive(Args, Debug)]\npub struct InitArgs {\n    /// Preset to use (opensource, enterprise, strict)\n    #[arg(short, long, value_name = \"PRESET\")]\n    pub preset: Option<String>,\n\n    /// Force overwrite existing configuration\n    #[arg(short, long)]\n    pub force: bool,\n\n    /// Skip interactive prompts\n    #[arg(long)]\n    pub non_interactive: bool,\n\n    /// Skip prerequisite checks (git, gh, etc.)\n    #[arg(long)]\n    pub skip_checks: bool,\n}\n\n/// Arguments for the plan command\n#[derive(Args, Debug)]\npub struct PlanArgs {\n    /// Output format (terminal, json, sarif)\n    #[arg(short, long, default_value = \"terminal\")]\n    pub format: OutputFormat,\n\n    /// Only check specific rule categories\n    #[arg(long, value_delimiter = ',')]\n    pub only: Option<Vec<String>>,\n\n    /// Skip specific rule categories\n    #[arg(long, value_delimiter = ',')]\n    pub skip: Option<Vec<String>>,\n\n    /// Output file (defaults to stdout)\n    #[arg(short, long, value_name = \"FILE\")]\n    pub output: Option<PathBuf>,\n}\n\n/// Arguments for the apply command\n#[derive(Args, Debug)]\npub struct ApplyArgs {\n    /// Skip confirmation prompts\n    #[arg(short, long)]\n    pub yes: bool,\n\n    /// Dry run - show what would be done without making changes\n    #[arg(long)]\n    pub dry_run: bool,\n\n    /// Only apply specific actions\n    #[arg(long, value_delimiter = ',')]\n    pub only: Option<Vec<String>>,\n\n    /// Skip specific actions\n    #[arg(long, value_delimiter = ',')]\n    pub skip: Option<Vec<String>>,\n}\n\n/// Arguments for the report command\n#[derive(Args, Debug)]\npub struct ReportArgs {\n    /// Output format (html, markdown, json)\n    #[arg(short, long, default_value = \"markdown\")]\n    pub format: ReportFormat,\n\n    /// Output file\n    #[arg(short, long, value_name = \"FILE\")]\n    pub output: Option<PathBuf>,\n\n    /// Include full details in report\n    #[arg(long)]\n    pub detailed: bool,\n}\n\n/// Output format for plan command\n#[derive(Debug, Clone, PartialEq, Eq, clap::ValueEnum)]\npub enum OutputFormat {\n    Terminal,\n    Json,\n    Sarif,\n}\n\n/// Output format for report command\n#[derive(Debug, Clone, PartialEq, Eq, clap::ValueEnum)]\npub enum ReportFormat {\n    Html,\n    Markdown,\n    Json,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","commands","plan.rs"],"content":"//! Plan command - Analyze repository and show planned actions\n//!\n//! This module implements the `plan` command which analyzes a repository\n//! and generates an action plan to fix detected issues.\n\nuse std::path::PathBuf;\n\nuse super::{OutputFormat, PlanArgs};\nuse crate::actions::planner::ActionPlanner;\nuse crate::cli::output::{JsonOutput, OutputRenderer, SarifOutput, TerminalOutput};\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::exit_codes;\nuse crate::rules::engine::RulesEngine;\nuse crate::scanner::Scanner;\n\n/// Execute the plan command\n///\n/// Analyzes the repository, runs audit rules, generates an action plan,\n/// and outputs the results in the requested format.\n///\n/// # Arguments\n///\n/// * `args` - Command line arguments for the plan command\n///\n/// # Returns\n///\n/// An exit code: 0 for success, 1 for critical issues, 2 for warnings\n///\n/// # Errors\n///\n/// Returns an error if the audit or plan generation fails\npub async fn execute(args: PlanArgs) -> Result<i32, RepoLensError> {\n    // Load configuration\n    let config = Config::load_or_default()?;\n\n    // Initialize scanner\n    let scanner = Scanner::new(PathBuf::from(\".\"));\n\n    // Run the rules engine\n    let mut engine = RulesEngine::new(config.clone());\n\n    // Apply filters if specified\n    if let Some(only) = &args.only {\n        engine.set_only_categories(only.clone());\n    }\n    if let Some(skip) = &args.skip {\n        engine.set_skip_categories(skip.clone());\n    }\n\n    // Execute audit\n    let audit_results = engine.run(&scanner).await?;\n\n    // Generate action plan\n    let planner = ActionPlanner::new(config);\n    let action_plan = planner.create_plan(&audit_results);\n\n    // Render output\n    let output: Box<dyn OutputRenderer> = match args.format {\n        OutputFormat::Terminal => Box::new(TerminalOutput::new()),\n        OutputFormat::Json => Box::new(JsonOutput::new()),\n        OutputFormat::Sarif => Box::new(SarifOutput::new()),\n    };\n\n    let rendered = output.render_plan(&audit_results, &action_plan)?;\n\n    // Write output\n    if let Some(output_path) = args.output {\n        std::fs::write(&output_path, &rendered).map_err(|e| {\n            RepoLensError::Action(crate::error::ActionError::FileWrite {\n                path: output_path.display().to_string(),\n                source: e,\n            })\n        })?;\n        eprintln!(\"Plan written to: {}\", output_path.display());\n    } else {\n        println!(\"{rendered}\");\n    }\n\n    // Determine exit code based on findings\n    let exit_code = if audit_results.has_critical() {\n        exit_codes::CRITICAL_ISSUES\n    } else if audit_results.has_warnings() {\n        exit_codes::WARNINGS\n    } else {\n        exit_codes::SUCCESS\n    };\n\n    Ok(exit_code)\n}\n","traces":[{"line":33,"address":[661448,660144,660206,664060,660392,663475],"length":1,"stats":{"Line":0}},{"line":35,"address":[660385,660510,661409],"length":1,"stats":{"Line":0}},{"line":38,"address":[660745,660824],"length":1,"stats":{"Line":0}},{"line":41,"address":[685459,685382],"length":1,"stats":{"Line":0}},{"line":44,"address":[660961],"length":1,"stats":{"Line":0}},{"line":45,"address":[685561,685725],"length":1,"stats":{"Line":0}},{"line":47,"address":[661211,661078],"length":1,"stats":{"Line":0}},{"line":48,"address":[661219,661317],"length":1,"stats":{"Line":0}},{"line":52,"address":[664286,661342,660422,661264,661474],"length":1,"stats":{"Line":0}},{"line":55,"address":[662035],"length":1,"stats":{"Line":0}},{"line":56,"address":[662176],"length":1,"stats":{"Line":0}},{"line":59,"address":[662366,662220],"length":1,"stats":{"Line":0}},{"line":60,"address":[686790,686854],"length":1,"stats":{"Line":0}},{"line":61,"address":[662269,662446],"length":1,"stats":{"Line":0}},{"line":62,"address":[662488,662279],"length":1,"stats":{"Line":0}},{"line":65,"address":[664214,662398,662589],"length":1,"stats":{"Line":0}},{"line":68,"address":[662801],"length":1,"stats":{"Line":0}},{"line":69,"address":[662914,665032,664784,665038,663021,663127],"length":1,"stats":{"Line":0}},{"line":70,"address":[664957],"length":1,"stats":{"Line":0}},{"line":71,"address":[664811,664884],"length":1,"stats":{"Line":0}},{"line":72,"address":[689480],"length":1,"stats":{"Line":0}},{"line":75,"address":[663168],"length":1,"stats":{"Line":0}},{"line":77,"address":[687454,688009],"length":1,"stats":{"Line":0}},{"line":81,"address":[663559,663595,663405],"length":1,"stats":{"Line":0}},{"line":82,"address":[663584],"length":1,"stats":{"Line":0}},{"line":83,"address":[663573,663618,663601],"length":1,"stats":{"Line":0}},{"line":84,"address":[663620],"length":1,"stats":{"Line":0}},{"line":86,"address":[663607],"length":1,"stats":{"Line":0}},{"line":89,"address":[663631],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","commands","report.rs"],"content":"//! Report command - Generate an audit report\n\nuse colored::Colorize;\nuse std::path::PathBuf;\n\nuse super::{ReportArgs, ReportFormat};\nuse crate::cli::output::{HtmlReport, JsonOutput, MarkdownReport, ReportRenderer};\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::exit_codes;\nuse crate::rules::engine::RulesEngine;\nuse crate::scanner::Scanner;\n\npub async fn execute(args: ReportArgs) -> Result<i32, RepoLensError> {\n    // Load configuration\n    let config = Config::load_or_default()?;\n\n    // Initialize scanner\n    let scanner = Scanner::new(PathBuf::from(\".\"));\n\n    // Run the rules engine\n    let engine = RulesEngine::new(config);\n    let audit_results = engine.run(&scanner).await?;\n\n    // Generate report\n    let renderer: Box<dyn ReportRenderer> = match args.format {\n        ReportFormat::Html => Box::new(HtmlReport::new(args.detailed)),\n        ReportFormat::Markdown => Box::new(MarkdownReport::new(args.detailed)),\n        ReportFormat::Json => Box::new(JsonOutput::new()),\n    };\n\n    let report = renderer.render_report(&audit_results)?;\n\n    // Write output\n    let output_path = args.output.unwrap_or_else(|| {\n        let extension = match args.format {\n            ReportFormat::Html => \"html\",\n            ReportFormat::Markdown => \"md\",\n            ReportFormat::Json => \"json\",\n        };\n        PathBuf::from(format!(\"repolens-report.{extension}\"))\n    });\n\n    std::fs::write(&output_path, &report).map_err(|e| {\n        RepoLensError::Action(crate::error::ActionError::FileWrite {\n            path: output_path.display().to_string(),\n            source: e,\n        })\n    })?;\n\n    println!(\n        \"{} Report written to: {}\",\n        \"Success:\".green().bold(),\n        output_path.display().to_string().cyan()\n    );\n\n    // Return exit code based on findings\n    let exit_code = if audit_results.has_critical() {\n        exit_codes::CRITICAL_ISSUES\n    } else if audit_results.has_warnings() {\n        exit_codes::WARNINGS\n    } else {\n        exit_codes::SUCCESS\n    };\n\n    Ok(exit_code)\n}\n","traces":[{"line":14,"address":[998803,998800],"length":1,"stats":{"Line":0}},{"line":16,"address":[37177,37048,37781],"length":1,"stats":{"Line":0}},{"line":19,"address":[37478,37399],"length":1,"stats":{"Line":0}},{"line":22,"address":[37505],"length":1,"stats":{"Line":0}},{"line":23,"address":[37714,37623,37085,37850,40316],"length":1,"stats":{"Line":0}},{"line":26,"address":[38411,38599],"length":1,"stats":{"Line":0}},{"line":27,"address":[38450,38553],"length":1,"stats":{"Line":0}},{"line":28,"address":[38473,38678],"length":1,"stats":{"Line":0}},{"line":29,"address":[38726,38499],"length":1,"stats":{"Line":0}},{"line":32,"address":[40280,38631,38827],"length":1,"stats":{"Line":0}},{"line":35,"address":[40496,39007],"length":1,"stats":{"Line":0}},{"line":36,"address":[40518],"length":1,"stats":{"Line":0}},{"line":37,"address":[76971],"length":1,"stats":{"Line":0}},{"line":38,"address":[40578],"length":1,"stats":{"Line":0}},{"line":39,"address":[40601],"length":1,"stats":{"Line":0}},{"line":41,"address":[40622],"length":1,"stats":{"Line":0}},{"line":44,"address":[41022,39336,41016,39156,39230,40768],"length":1,"stats":{"Line":0}},{"line":45,"address":[40941],"length":1,"stats":{"Line":0}},{"line":46,"address":[77211,77284],"length":1,"stats":{"Line":0}},{"line":47,"address":[40936],"length":1,"stats":{"Line":0}},{"line":51,"address":[76094,75922],"length":1,"stats":{"Line":0}},{"line":58,"address":[39915,39966],"length":1,"stats":{"Line":0}},{"line":59,"address":[39955],"length":1,"stats":{"Line":0}},{"line":60,"address":[39944,39989,39972],"length":1,"stats":{"Line":0}},{"line":61,"address":[39991],"length":1,"stats":{"Line":0}},{"line":63,"address":[39978],"length":1,"stats":{"Line":0}},{"line":66,"address":[40002],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","mod.rs"],"content":"//! CLI module - Command line interface definition and handlers\n\npub mod commands;\npub mod output;\n\nuse clap::{Parser, Subcommand};\nuse std::path::PathBuf;\n\nuse commands::{ApplyArgs, InitArgs, PlanArgs, ReportArgs};\n\n/// RepoLens - Audit and prepare repositories for open source or enterprise standards\n#[derive(Parser, Debug)]\n#[command(name = \"repolens\")]\n#[command(author, version, about, long_about = None)]\n#[command(propagate_version = true)]\npub struct Cli {\n    /// Increase verbosity level (-v, -vv, -vvv)\n    #[arg(short, long, action = clap::ArgAction::Count, global = true)]\n    pub verbose: u8,\n\n    /// Path to configuration file\n    #[arg(short, long, global = true, value_name = \"FILE\")]\n    pub config: Option<PathBuf>,\n\n    /// Working directory (defaults to current directory)\n    #[arg(short = 'C', long, global = true, value_name = \"DIR\")]\n    pub directory: Option<PathBuf>,\n\n    #[command(subcommand)]\n    pub command: Commands,\n}\n\n#[derive(Subcommand, Debug)]\npub enum Commands {\n    /// Initialize a new configuration file\n    Init(InitArgs),\n\n    /// Analyze repository and show planned actions\n    Plan(PlanArgs),\n\n    /// Apply planned changes to the repository\n    Apply(ApplyArgs),\n\n    /// Generate an audit report\n    Report(ReportArgs),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","html.rs"],"content":"//! HTML report output\n\nuse crate::error::RepoLensError;\nuse chrono::Utc;\n\nuse super::ReportRenderer;\nuse crate::rules::results::{AuditResults, Severity};\n\npub struct HtmlReport {\n    detailed: bool,\n}\n\nimpl HtmlReport {\n    pub fn new(detailed: bool) -> Self {\n        Self { detailed }\n    }\n}\n\nimpl ReportRenderer for HtmlReport {\n    fn render_report(&self, results: &AuditResults) -> Result<String, RepoLensError> {\n        let critical_count = results.count_by_severity(Severity::Critical);\n        let warning_count = results.count_by_severity(Severity::Warning);\n        let info_count = results.count_by_severity(Severity::Info);\n\n        let status_color = if critical_count > 0 {\n            \"#dc3545\"\n        } else if warning_count > 0 {\n            \"#ffc107\"\n        } else {\n            \"#28a745\"\n        };\n\n        let mut findings_html = String::new();\n\n        // Critical findings\n        for finding in results.findings_by_severity(Severity::Critical) {\n            findings_html.push_str(&format!(\n                r#\"<div class=\"finding critical\">\n                    <div class=\"finding-header\">\n                        <span class=\"badge critical\">CRITICAL</span>\n                        <span class=\"rule-id\">{}</span>\n                    </div>\n                    <div class=\"finding-message\">{}</div>\n                    {}\n                    {}\n                </div>\"#,\n                finding.rule_id,\n                finding.message,\n                finding.location.as_ref().map_or(String::new(), |l| {\n                    format!(r#\"<div class=\"finding-location\">Location: <code>{}</code></div>\"#, l)\n                }),\n                if self.detailed {\n                    format!(\n                        \"{}{}\",\n                        finding.description.as_ref().map_or(String::new(), |d| {\n                            format!(r#\"<div class=\"finding-description\">{}</div>\"#, d)\n                        }),\n                        finding.remediation.as_ref().map_or(String::new(), |r| {\n                            format!(r#\"<div class=\"finding-remediation\"><strong>Remediation:</strong> {}</div>\"#, r)\n                        })\n                    )\n                } else {\n                    String::new()\n                }\n            ));\n        }\n\n        // Warning findings\n        for finding in results.findings_by_severity(Severity::Warning) {\n            findings_html.push_str(&format!(\n                r#\"<div class=\"finding warning\">\n                    <div class=\"finding-header\">\n                        <span class=\"badge warning\">WARNING</span>\n                        <span class=\"rule-id\">{}</span>\n                    </div>\n                    <div class=\"finding-message\">{}</div>\n                    {}\n                </div>\"#,\n                finding.rule_id,\n                finding.message,\n                finding.location.as_ref().map_or(String::new(), |l| {\n                    format!(\n                        r#\"<div class=\"finding-location\">Location: <code>{}</code></div>\"#,\n                        l\n                    )\n                })\n            ));\n        }\n\n        // Info findings\n        if self.detailed {\n            for finding in results.findings_by_severity(Severity::Info) {\n                findings_html.push_str(&format!(\n                    r#\"<div class=\"finding info\">\n                        <div class=\"finding-header\">\n                            <span class=\"badge info\">INFO</span>\n                            <span class=\"rule-id\">{}</span>\n                        </div>\n                        <div class=\"finding-message\">{}</div>\n                    </div>\"#,\n                    finding.rule_id, finding.message\n                ));\n            }\n        }\n\n        let html = format!(\n            r#\"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>RepoLens Audit Report - {}</title>\n    <style>\n        :root {{\n            --critical: #dc3545;\n            --warning: #ffc107;\n            --info: #17a2b8;\n            --success: #28a745;\n        }}\n        * {{ box-sizing: border-box; margin: 0; padding: 0; }}\n        body {{\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n            line-height: 1.6;\n            color: #333;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 2rem;\n            background: #f8f9fa;\n        }}\n        header {{\n            background: white;\n            padding: 2rem;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n            margin-bottom: 2rem;\n        }}\n        h1 {{ color: #333; margin-bottom: 1rem; }}\n        .meta {{ color: #666; font-size: 0.9rem; }}\n        .summary {{\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));\n            gap: 1rem;\n            margin: 2rem 0;\n        }}\n        .stat {{\n            background: white;\n            padding: 1.5rem;\n            border-radius: 8px;\n            text-align: center;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }}\n        .stat-value {{ font-size: 2rem; font-weight: bold; }}\n        .stat-label {{ color: #666; font-size: 0.9rem; }}\n        .stat.critical .stat-value {{ color: var(--critical); }}\n        .stat.warning .stat-value {{ color: var(--warning); }}\n        .stat.info .stat-value {{ color: var(--info); }}\n        .status-indicator {{\n            display: inline-block;\n            width: 12px;\n            height: 12px;\n            border-radius: 50%;\n            margin-right: 8px;\n        }}\n        .findings {{ margin-top: 2rem; }}\n        .finding {{\n            background: white;\n            padding: 1.5rem;\n            border-radius: 8px;\n            margin-bottom: 1rem;\n            border-left: 4px solid;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }}\n        .finding.critical {{ border-color: var(--critical); }}\n        .finding.warning {{ border-color: var(--warning); }}\n        .finding.info {{ border-color: var(--info); }}\n        .finding-header {{ display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem; }}\n        .badge {{\n            padding: 0.25rem 0.5rem;\n            border-radius: 4px;\n            font-size: 0.75rem;\n            font-weight: bold;\n            color: white;\n        }}\n        .badge.critical {{ background: var(--critical); }}\n        .badge.warning {{ background: var(--warning); color: #333; }}\n        .badge.info {{ background: var(--info); }}\n        .rule-id {{ color: #666; font-family: monospace; }}\n        .finding-message {{ font-weight: 500; }}\n        .finding-location {{ margin-top: 0.5rem; color: #666; font-size: 0.9rem; }}\n        .finding-location code {{ background: #f1f1f1; padding: 0.2rem 0.4rem; border-radius: 4px; }}\n        .finding-description {{ margin-top: 0.5rem; color: #555; }}\n        .finding-remediation {{ margin-top: 0.5rem; color: #28a745; }}\n        footer {{\n            margin-top: 3rem;\n            text-align: center;\n            color: #666;\n            font-size: 0.9rem;\n        }}\n        footer a {{ color: #007bff; text-decoration: none; }}\n    </style>\n</head>\n<body>\n    <header>\n        <h1>\n            <span class=\"status-indicator\" style=\"background: {}\"></span>\n            RepoLens Audit Report\n        </h1>\n        <div class=\"meta\">\n            <p><strong>Repository:</strong> {}</p>\n            <p><strong>Preset:</strong> {}</p>\n            <p><strong>Generated:</strong> {}</p>\n            <p><strong>Version:</strong> {}</p>\n        </div>\n    </header>\n\n    <section class=\"summary\">\n        <div class=\"stat critical\">\n            <div class=\"stat-value\">{}</div>\n            <div class=\"stat-label\">Critical</div>\n        </div>\n        <div class=\"stat warning\">\n            <div class=\"stat-value\">{}</div>\n            <div class=\"stat-label\">Warnings</div>\n        </div>\n        <div class=\"stat info\">\n            <div class=\"stat-value\">{}</div>\n            <div class=\"stat-label\">Info</div>\n        </div>\n    </section>\n\n    <section class=\"findings\">\n        <h2>Findings</h2>\n        {}\n    </section>\n\n    <footer>\n        <p>Report generated by <a href=\"https://github.com/kdelfour/repolens\">RepoLens</a></p>\n    </footer>\n</body>\n</html>\"#,\n            results.repository_name,\n            status_color,\n            results.repository_name,\n            results.preset,\n            Utc::now().format(\"%Y-%m-%d %H:%M:%S UTC\"),\n            env!(\"CARGO_PKG_VERSION\"),\n            critical_count,\n            warning_count,\n            info_count,\n            findings_html\n        );\n\n        Ok(html)\n    }\n}\n","traces":[{"line":14,"address":[655360],"length":1,"stats":{"Line":0}},{"line":20,"address":[659173,655376,657153],"length":1,"stats":{"Line":0}},{"line":21,"address":[655442],"length":1,"stats":{"Line":0}},{"line":22,"address":[655479],"length":1,"stats":{"Line":0}},{"line":23,"address":[655516],"length":1,"stats":{"Line":0}},{"line":25,"address":[655545,655596],"length":1,"stats":{"Line":0}},{"line":26,"address":[655569],"length":1,"stats":{"Line":0}},{"line":27,"address":[655654,655556,655625],"length":1,"stats":{"Line":0}},{"line":28,"address":[655627],"length":1,"stats":{"Line":0}},{"line":30,"address":[655598],"length":1,"stats":{"Line":0}},{"line":33,"address":[655694],"length":1,"stats":{"Line":0}},{"line":36,"address":[655707,655798],"length":1,"stats":{"Line":0}},{"line":37,"address":[655944,657934,658025,658710,658151,659144],"length":1,"stats":{"Line":0}},{"line":49,"address":[513808],"length":1,"stats":{"Line":0}},{"line":50,"address":[513829],"length":1,"stats":{"Line":0}},{"line":52,"address":[658104],"length":1,"stats":{"Line":0}},{"line":53,"address":[658224,658363],"length":1,"stats":{"Line":0}},{"line":55,"address":[658189,658129],"length":1,"stats":{"Line":0}},{"line":56,"address":[513957],"length":1,"stats":{"Line":0}},{"line":58,"address":[658300],"length":1,"stats":{"Line":0}},{"line":59,"address":[514085],"length":1,"stats":{"Line":0}},{"line":63,"address":[112213,112245],"length":1,"stats":{"Line":0}},{"line":69,"address":[110070],"length":1,"stats":{"Line":0}},{"line":70,"address":[111520,111996,110257,111611],"length":1,"stats":{"Line":0}},{"line":81,"address":[111548],"length":1,"stats":{"Line":0}},{"line":82,"address":[514213],"length":1,"stats":{"Line":0}},{"line":91,"address":[656191],"length":1,"stats":{"Line":0}},{"line":92,"address":[656234],"length":1,"stats":{"Line":0}},{"line":93,"address":[657390,657164,656425],"length":1,"stats":{"Line":0}},{"line":106,"address":[656204,656602,656447],"length":1,"stats":{"Line":0}},{"line":245,"address":[656532],"length":1,"stats":{"Line":0}},{"line":253,"address":[657080],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","json.rs"],"content":"//! JSON output formatting\n\nuse crate::error::RepoLensError;\nuse serde::Serialize;\n\nuse super::{OutputRenderer, ReportRenderer};\nuse crate::actions::plan::ActionPlan;\nuse crate::rules::results::AuditResults;\n\npub struct JsonOutput;\n\nimpl JsonOutput {\n    pub fn new() -> Self {\n        Self\n    }\n}\n\nimpl Default for JsonOutput {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[derive(Serialize)]\nstruct PlanOutput<'a> {\n    version: &'static str,\n    repository: &'a str,\n    preset: &'a str,\n    audit: AuditSummary<'a>,\n    actions: Vec<ActionSummary<'a>>,\n}\n\n#[derive(Serialize)]\nstruct AuditSummary<'a> {\n    critical_count: usize,\n    warning_count: usize,\n    info_count: usize,\n    findings: &'a [crate::rules::results::Finding],\n}\n\n#[derive(Serialize)]\nstruct ActionSummary<'a> {\n    category: &'a str,\n    description: &'a str,\n    details: &'a [String],\n}\n\nimpl OutputRenderer for JsonOutput {\n    fn render_plan(\n        &self,\n        results: &AuditResults,\n        plan: &ActionPlan,\n    ) -> Result<String, RepoLensError> {\n        let output = PlanOutput {\n            version: env!(\"CARGO_PKG_VERSION\"),\n            repository: &results.repository_name,\n            preset: &results.preset,\n            audit: AuditSummary {\n                critical_count: results\n                    .count_by_severity(crate::rules::results::Severity::Critical),\n                warning_count: results.count_by_severity(crate::rules::results::Severity::Warning),\n                info_count: results.count_by_severity(crate::rules::results::Severity::Info),\n                findings: results.findings(),\n            },\n            actions: plan\n                .actions()\n                .iter()\n                .map(|a| ActionSummary {\n                    category: a.category(),\n                    description: a.description(),\n                    details: a.details(),\n                })\n                .collect(),\n        };\n\n        Ok(serde_json::to_string_pretty(&output)?)\n    }\n}\n\nimpl ReportRenderer for JsonOutput {\n    fn render_report(&self, results: &AuditResults) -> Result<String, RepoLensError> {\n        Ok(serde_json::to_string_pretty(results)?)\n    }\n}\n","traces":[{"line":19,"address":[478976],"length":1,"stats":{"Line":0}},{"line":20,"address":[478977],"length":1,"stats":{"Line":0}},{"line":49,"address":[478992,479766,479772],"length":1,"stats":{"Line":0}},{"line":56,"address":[479051],"length":1,"stats":{"Line":0}},{"line":57,"address":[479071],"length":1,"stats":{"Line":0}},{"line":58,"address":[479213],"length":1,"stats":{"Line":0}},{"line":65,"address":[479253],"length":1,"stats":{"Line":0}},{"line":76,"address":[479519,479459],"length":1,"stats":{"Line":0}},{"line":81,"address":[479792],"length":1,"stats":{"Line":0}},{"line":82,"address":[479827],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","markdown.rs"],"content":"//! Markdown report output\n\nuse crate::error::RepoLensError;\nuse chrono::Utc;\n\nuse super::ReportRenderer;\nuse crate::rules::results::{AuditResults, Severity};\n\npub struct MarkdownReport {\n    detailed: bool,\n}\n\nimpl MarkdownReport {\n    pub fn new(detailed: bool) -> Self {\n        Self { detailed }\n    }\n}\n\nimpl ReportRenderer for MarkdownReport {\n    fn render_report(&self, results: &AuditResults) -> Result<String, RepoLensError> {\n        let mut output = String::new();\n\n        // Header\n        output.push_str(&format!(\n            \"# RepoLens Audit Report\\n\\n\\\n             **Repository:** {}\\n\\\n             **Preset:** {}\\n\\\n             **Generated:** {}\\n\\\n             **RepoLens Version:** {}\\n\\n\",\n            results.repository_name,\n            results.preset,\n            Utc::now().format(\"%Y-%m-%d %H:%M:%S UTC\"),\n            env!(\"CARGO_PKG_VERSION\")\n        ));\n\n        // Summary\n        output.push_str(\"## Summary\\n\\n\");\n        output.push_str(\"| Severity | Count |\\n\");\n        output.push_str(\"|----------|-------|\\n\");\n        output.push_str(&format!(\n            \"| Critical | {} |\\n\",\n            results.count_by_severity(Severity::Critical)\n        ));\n        output.push_str(&format!(\n            \"| Warning | {} |\\n\",\n            results.count_by_severity(Severity::Warning)\n        ));\n        output.push_str(&format!(\n            \"| Info | {} |\\n\\n\",\n            results.count_by_severity(Severity::Info)\n        ));\n\n        // Critical findings\n        let critical: Vec<_> = results.findings_by_severity(Severity::Critical).collect();\n        if !critical.is_empty() {\n            output.push_str(\"## Critical Issues\\n\\n\");\n            output.push_str(\"These issues must be resolved before proceeding.\\n\\n\");\n            for finding in critical {\n                output.push_str(&format!(\n                    \"### {} - {}\\n\\n\",\n                    finding.rule_id, finding.message\n                ));\n                if let Some(location) = &finding.location {\n                    output.push_str(&format!(\"**Location:** `{}`\\n\\n\", location));\n                }\n                if self.detailed {\n                    if let Some(description) = &finding.description {\n                        output.push_str(&format!(\"{}\\n\\n\", description));\n                    }\n                    if let Some(remediation) = &finding.remediation {\n                        output.push_str(&format!(\"**Remediation:** {}\\n\\n\", remediation));\n                    }\n                }\n            }\n        }\n\n        // Warning findings\n        let warnings: Vec<_> = results.findings_by_severity(Severity::Warning).collect();\n        if !warnings.is_empty() {\n            output.push_str(\"## Warnings\\n\\n\");\n            output.push_str(\"These issues should be addressed.\\n\\n\");\n            for finding in warnings {\n                output.push_str(&format!(\n                    \"### {} - {}\\n\\n\",\n                    finding.rule_id, finding.message\n                ));\n                if let Some(location) = &finding.location {\n                    output.push_str(&format!(\"**Location:** `{}`\\n\\n\", location));\n                }\n                if self.detailed {\n                    if let Some(description) = &finding.description {\n                        output.push_str(&format!(\"{}\\n\\n\", description));\n                    }\n                    if let Some(remediation) = &finding.remediation {\n                        output.push_str(&format!(\"**Remediation:** {}\\n\\n\", remediation));\n                    }\n                }\n            }\n        }\n\n        // Info findings\n        let info: Vec<_> = results.findings_by_severity(Severity::Info).collect();\n        if !info.is_empty() && self.detailed {\n            output.push_str(\"## Informational\\n\\n\");\n            output.push_str(\"These are suggestions for improvement.\\n\\n\");\n            for finding in info {\n                output.push_str(&format!(\"- **{}**: {}\\n\", finding.rule_id, finding.message));\n            }\n            output.push('\\n');\n        }\n\n        // Footer\n        output.push_str(\"---\\n\\n\");\n        output.push_str(\"*Report generated by [RepoLens](https://github.com/kdelfour/repolens)*\\n\");\n\n        Ok(output)\n    }\n}\n","traces":[{"line":14,"address":[114368],"length":1,"stats":{"Line":0}},{"line":20,"address":[114384,117219,120689],"length":1,"stats":{"Line":0}},{"line":21,"address":[114439],"length":1,"stats":{"Line":0}},{"line":24,"address":[114500,114661,115030,114568],"length":1,"stats":{"Line":0}},{"line":32,"address":[114591],"length":1,"stats":{"Line":0}},{"line":37,"address":[115056],"length":1,"stats":{"Line":0}},{"line":38,"address":[115083],"length":1,"stats":{"Line":0}},{"line":39,"address":[115110],"length":1,"stats":{"Line":0}},{"line":40,"address":[115192,115418],"length":1,"stats":{"Line":0}},{"line":42,"address":[115145],"length":1,"stats":{"Line":0}},{"line":44,"address":[115499,115725],"length":1,"stats":{"Line":0}},{"line":46,"address":[115452],"length":1,"stats":{"Line":0}},{"line":48,"address":[116032,115806],"length":1,"stats":{"Line":0}},{"line":50,"address":[115759],"length":1,"stats":{"Line":0}},{"line":54,"address":[116066],"length":1,"stats":{"Line":0}},{"line":55,"address":[116198,116136],"length":1,"stats":{"Line":0}},{"line":56,"address":[116204],"length":1,"stats":{"Line":0}},{"line":57,"address":[116273],"length":1,"stats":{"Line":0}},{"line":58,"address":[116300,116498],"length":1,"stats":{"Line":0}},{"line":59,"address":[1577246,1577484,1577201],"length":1,"stats":{"Line":0}},{"line":63,"address":[116878],"length":1,"stats":{"Line":0}},{"line":64,"address":[1577631,1577582],"length":1,"stats":{"Line":0}},{"line":66,"address":[116977],"length":1,"stats":{"Line":0}},{"line":67,"address":[1577873],"length":1,"stats":{"Line":0}},{"line":68,"address":[117389,117297],"length":1,"stats":{"Line":0}},{"line":70,"address":[1577972,1578265],"length":1,"stats":{"Line":0}},{"line":71,"address":[117633],"length":1,"stats":{"Line":0}},{"line":78,"address":[117904,116239],"length":1,"stats":{"Line":0}},{"line":79,"address":[117927,117989],"length":1,"stats":{"Line":0}},{"line":80,"address":[117995],"length":1,"stats":{"Line":0}},{"line":81,"address":[1578704],"length":1,"stats":{"Line":0}},{"line":82,"address":[118091,118289],"length":1,"stats":{"Line":0}},{"line":83,"address":[118352,118397,118623],"length":1,"stats":{"Line":0}},{"line":87,"address":[118657],"length":1,"stats":{"Line":0}},{"line":88,"address":[1579404,1579355],"length":1,"stats":{"Line":0}},{"line":90,"address":[118750],"length":1,"stats":{"Line":0}},{"line":91,"address":[1579628],"length":1,"stats":{"Line":0}},{"line":92,"address":[119046,119135],"length":1,"stats":{"Line":0}},{"line":94,"address":[1579996,1579721],"length":1,"stats":{"Line":0}},{"line":95,"address":[119364],"length":1,"stats":{"Line":0}},{"line":102,"address":[119623,118030],"length":1,"stats":{"Line":0}},{"line":103,"address":[119646,119702],"length":1,"stats":{"Line":0}},{"line":104,"address":[1580391],"length":1,"stats":{"Line":0}},{"line":105,"address":[119778],"length":1,"stats":{"Line":0}},{"line":106,"address":[119805,119997],"length":1,"stats":{"Line":0}},{"line":107,"address":[120057,120121],"length":1,"stats":{"Line":0}},{"line":109,"address":[120104],"length":1,"stats":{"Line":0}},{"line":113,"address":[119721],"length":1,"stats":{"Line":0}},{"line":114,"address":[120374],"length":1,"stats":{"Line":0}},{"line":116,"address":[120409],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":50},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","mod.rs"],"content":"//! Output formatting module for CLI\n\nmod html;\nmod json;\nmod markdown;\nmod sarif;\nmod terminal;\n\npub use html::HtmlReport;\npub use json::JsonOutput;\npub use markdown::MarkdownReport;\npub use sarif::SarifOutput;\npub use terminal::TerminalOutput;\n\nuse crate::actions::plan::ActionPlan;\nuse crate::error::RepoLensError;\nuse crate::rules::results::AuditResults;\n\n/// Trait for rendering plan output\npub trait OutputRenderer {\n    fn render_plan(\n        &self,\n        results: &AuditResults,\n        plan: &ActionPlan,\n    ) -> Result<String, RepoLensError>;\n}\n\n/// Trait for rendering report output\npub trait ReportRenderer {\n    fn render_report(&self, results: &AuditResults) -> Result<String, RepoLensError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","sarif.rs"],"content":"//! SARIF output formatting for GitHub Code Scanning integration\n\nuse crate::error::RepoLensError;\nuse serde::Serialize;\n\nuse super::OutputRenderer;\nuse crate::actions::plan::ActionPlan;\nuse crate::rules::results::{AuditResults, Finding, Severity};\n\npub struct SarifOutput;\n\nimpl SarifOutput {\n    pub fn new() -> Self {\n        Self\n    }\n}\n\nimpl Default for SarifOutput {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[derive(Serialize)]\nstruct SarifReport {\n    #[serde(rename = \"$schema\")]\n    schema: &'static str,\n    version: &'static str,\n    runs: Vec<SarifRun>,\n}\n\n#[derive(Serialize)]\nstruct SarifRun {\n    tool: SarifTool,\n    results: Vec<SarifResult>,\n}\n\n#[derive(Serialize)]\nstruct SarifTool {\n    driver: SarifDriver,\n}\n\n#[derive(Serialize)]\nstruct SarifDriver {\n    name: &'static str,\n    version: &'static str,\n    #[serde(rename = \"informationUri\")]\n    information_uri: &'static str,\n    rules: Vec<SarifRule>,\n}\n\n#[derive(Serialize)]\nstruct SarifRule {\n    id: String,\n    name: String,\n    #[serde(rename = \"shortDescription\")]\n    short_description: SarifMessage,\n    #[serde(rename = \"defaultConfiguration\")]\n    default_configuration: SarifDefaultConfig,\n}\n\n#[derive(Serialize)]\nstruct SarifDefaultConfig {\n    level: String,\n}\n\n#[derive(Serialize)]\nstruct SarifResult {\n    #[serde(rename = \"ruleId\")]\n    rule_id: String,\n    level: String,\n    message: SarifMessage,\n    locations: Vec<SarifLocation>,\n}\n\n#[derive(Serialize)]\nstruct SarifMessage {\n    text: String,\n}\n\n#[derive(Serialize)]\nstruct SarifLocation {\n    #[serde(rename = \"physicalLocation\")]\n    physical_location: SarifPhysicalLocation,\n}\n\n#[derive(Serialize)]\nstruct SarifPhysicalLocation {\n    #[serde(rename = \"artifactLocation\")]\n    artifact_location: SarifArtifactLocation,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    region: Option<SarifRegion>,\n}\n\n#[derive(Serialize)]\nstruct SarifArtifactLocation {\n    uri: String,\n}\n\n#[derive(Serialize)]\nstruct SarifRegion {\n    #[serde(rename = \"startLine\")]\n    start_line: u32,\n    #[serde(rename = \"startColumn\", skip_serializing_if = \"Option::is_none\")]\n    start_column: Option<u32>,\n}\n\nimpl SarifOutput {\n    fn severity_to_level(severity: Severity) -> &'static str {\n        match severity {\n            Severity::Critical => \"error\",\n            Severity::Warning => \"warning\",\n            Severity::Info => \"note\",\n        }\n    }\n\n    fn finding_to_result(finding: &Finding) -> SarifResult {\n        let (uri, region) = if let Some(location) = &finding.location {\n            // Parse location like \"src/config.ts:42\"\n            let parts: Vec<&str> = location.split(':').collect();\n            let uri = parts.first().unwrap_or(&\"unknown\").to_string();\n            let region = parts.get(1).and_then(|line| {\n                line.parse::<u32>().ok().map(|l| SarifRegion {\n                    start_line: l,\n                    start_column: None,\n                })\n            });\n            (uri, region)\n        } else {\n            (\"unknown\".to_string(), None)\n        };\n\n        SarifResult {\n            rule_id: finding.rule_id.clone(),\n            level: Self::severity_to_level(finding.severity).to_string(),\n            message: SarifMessage {\n                text: finding.message.clone(),\n            },\n            locations: vec![SarifLocation {\n                physical_location: SarifPhysicalLocation {\n                    artifact_location: SarifArtifactLocation { uri },\n                    region,\n                },\n            }],\n        }\n    }\n}\n\nimpl OutputRenderer for SarifOutput {\n    fn render_plan(\n        &self,\n        results: &AuditResults,\n        _plan: &ActionPlan,\n    ) -> Result<String, RepoLensError> {\n        let rules: Vec<SarifRule> = results\n            .findings()\n            .iter()\n            .map(|f| SarifRule {\n                id: f.rule_id.clone(),\n                name: f.rule_id.clone(),\n                short_description: SarifMessage {\n                    text: f.message.clone(),\n                },\n                default_configuration: SarifDefaultConfig {\n                    level: Self::severity_to_level(f.severity).to_string(),\n                },\n            })\n            .collect();\n\n        let results_sarif: Vec<SarifResult> = results\n            .findings()\n            .iter()\n            .map(Self::finding_to_result)\n            .collect();\n\n        let report = SarifReport {\n            schema: \"https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json\",\n            version: \"2.1.0\",\n            runs: vec![SarifRun {\n                tool: SarifTool {\n                    driver: SarifDriver {\n                        name: \"repolens\",\n                        version: env!(\"CARGO_PKG_VERSION\"),\n                        information_uri: \"https://github.com/kdelfour/repolens\",\n                        rules,\n                    },\n                },\n                results: results_sarif,\n            }],\n        };\n\n        Ok(serde_json::to_string_pretty(&report)?)\n    }\n}\n","traces":[{"line":19,"address":[690320],"length":1,"stats":{"Line":0}},{"line":20,"address":[860673],"length":1,"stats":{"Line":0}},{"line":109,"address":[860688],"length":1,"stats":{"Line":0}},{"line":110,"address":[860695],"length":1,"stats":{"Line":0}},{"line":111,"address":[690374],"length":1,"stats":{"Line":0}},{"line":112,"address":[860749],"length":1,"stats":{"Line":0}},{"line":113,"address":[860772],"length":1,"stats":{"Line":0}},{"line":117,"address":[861591,861597,860816],"length":1,"stats":{"Line":0}},{"line":118,"address":[860846,861118,861502],"length":1,"stats":{"Line":0}},{"line":120,"address":[860912],"length":1,"stats":{"Line":0}},{"line":121,"address":[861177,860979],"length":1,"stats":{"Line":0}},{"line":122,"address":[1420432],"length":1,"stats":{"Line":0}},{"line":123,"address":[1420450,1420543,1420528],"length":1,"stats":{"Line":0}},{"line":125,"address":[1420535],"length":1,"stats":{"Line":0}},{"line":128,"address":[861357],"length":1,"stats":{"Line":0}},{"line":130,"address":[861003],"length":1,"stats":{"Line":0}},{"line":134,"address":[691220],"length":1,"stats":{"Line":0}},{"line":135,"address":[861653,861727],"length":1,"stats":{"Line":0}},{"line":136,"address":[691463],"length":1,"stats":{"Line":0}},{"line":139,"address":[691505,691735],"length":1,"stats":{"Line":0}},{"line":150,"address":[863722,862448,863716],"length":1,"stats":{"Line":0}},{"line":155,"address":[692150],"length":1,"stats":{"Line":0}},{"line":158,"address":[1421054,1420560,1421048,1420924],"length":1,"stats":{"Line":0}},{"line":159,"address":[1420606],"length":1,"stats":{"Line":0}},{"line":160,"address":[1420640],"length":1,"stats":{"Line":0}},{"line":161,"address":[1420756],"length":1,"stats":{"Line":0}},{"line":162,"address":[1420690],"length":1,"stats":{"Line":0}},{"line":164,"address":[1420876],"length":1,"stats":{"Line":0}},{"line":165,"address":[1420782,1420847],"length":1,"stats":{"Line":0}},{"line":170,"address":[862639,862571],"length":1,"stats":{"Line":0}},{"line":179,"address":[863024,862723],"length":1,"stats":{"Line":0}},{"line":192,"address":[863428,863365],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","terminal.rs"],"content":"//! Terminal output formatting with colors\n\nuse crate::error::RepoLensError;\nuse colored::Colorize;\n\nuse super::{OutputRenderer, ReportRenderer};\nuse crate::actions::plan::ActionPlan;\nuse crate::rules::results::{AuditResults, Finding, Severity};\n\npub struct TerminalOutput;\n\nimpl TerminalOutput {\n    pub fn new() -> Self {\n        Self\n    }\n\n    fn format_header(&self, repo_name: &str, preset: &str) -> String {\n        format!(\n            r#\"\n{} v{}\n\n{} {}\n{} {}\n\"#,\n            \"repolens\".cyan().bold(),\n            env!(\"CARGO_PKG_VERSION\"),\n            \"Repository:\".dimmed(),\n            repo_name.white().bold(),\n            \"Preset:\".dimmed(),\n            preset.yellow()\n        )\n    }\n\n    fn format_findings(&self, results: &AuditResults) -> String {\n        let mut output = String::new();\n\n        output.push_str(&format!(\n            \"\\n{}\\n{}\\n\\n\",\n            \"‚îÅ\".repeat(50).dimmed(),\n            \"  AUDIT RESULTS\".bold()\n        ));\n\n        // Critical findings\n        let critical: Vec<_> = results.findings_by_severity(Severity::Critical).collect();\n        if !critical.is_empty() {\n            output.push_str(&format!(\n                \"{} ({})\\\\n\",\n                \"‚ùå CRITICAL\".red().bold(),\n                critical.len()\n            ));\n            for finding in critical {\n                output.push_str(&self.format_finding(finding));\n            }\n            output.push('\\n');\n        }\n\n        // Warning findings\n        let warnings: Vec<_> = results.findings_by_severity(Severity::Warning).collect();\n        if !warnings.is_empty() {\n            output.push_str(&format!(\n                \"{} ({})\\\\n\",\n                \"‚ö†Ô∏è  WARNING\".yellow().bold(),\n                warnings.len()\n            ));\n            for finding in warnings {\n                output.push_str(&self.format_finding(finding));\n            }\n            output.push('\\n');\n        }\n\n        // Info findings\n        let info: Vec<_> = results.findings_by_severity(Severity::Info).collect();\n        if !info.is_empty() {\n            output.push_str(&format!(\"{} ({})\\\\n\", \"‚ÑπÔ∏è  INFO\".blue().bold(), info.len()));\n            for finding in info {\n                output.push_str(&self.format_finding(finding));\n            }\n            output.push('\\n');\n        }\n\n        output\n    }\n\n    fn format_finding(&self, finding: &Finding) -> String {\n        let mut output = format!(\n            \"  {} [{}] {}\\n\",\n            \"‚Ä¢\".dimmed(),\n            finding.rule_id.cyan(),\n            finding.message\n        );\n\n        if let Some(location) = &finding.location {\n            output.push_str(&format!(\"    {} {}\\n\", \"‚îî‚îÄ\".dimmed(), location.dimmed()));\n        }\n\n        output\n    }\n\n    fn format_actions(&self, plan: &ActionPlan) -> String {\n        let mut output = String::new();\n\n        output.push_str(&format!(\n            \"\\n{}\\n{}\\n\\n\",\n            \"‚îÅ\".repeat(50).dimmed(),\n            \"  PLANNED ACTIONS\".bold()\n        ));\n\n        if plan.is_empty() {\n            output.push_str(&format!(\"  {}\\n\", \"No actions required.\".green()));\n            return output;\n        }\n\n        output.push_str(\"The following changes will be applied:\\n\\n\");\n\n        for action in plan.actions() {\n            output.push_str(&format!(\n                \"  {} [{}] {}\\n\",\n                \"+\".green(),\n                action.category().cyan(),\n                action.description()\n            ));\n\n            for detail in action.details() {\n                output.push_str(&format!(\"      {} {}\\n\", \"‚îî‚îÄ\".dimmed(), detail.dimmed()));\n            }\n        }\n\n        output\n    }\n\n    fn format_summary(&self, results: &AuditResults) -> String {\n        let mut output = String::new();\n\n        output.push_str(&format!(\n            \"\\n{}\\n{}\\n\\n\",\n            \"‚îÅ\".repeat(50).dimmed(),\n            \"  SUMMARY\".bold()\n        ));\n\n        let critical_count = results.count_by_severity(Severity::Critical);\n        let warning_count = results.count_by_severity(Severity::Warning);\n        let info_count = results.count_by_severity(Severity::Info);\n\n        output.push_str(&format!(\n            \"Critical: {} ‚îÇ Warnings: {} ‚îÇ Info: {}\\n\",\n            critical_count.to_string().red().bold(),\n            warning_count.to_string().yellow().bold(),\n            info_count.to_string().blue().bold()\n        ));\n\n        if critical_count > 0 {\n            output.push_str(&format!(\n                \"\\n{} {} critical issue(s) must be fixed manually.\\n\",\n                \"‚ö†Ô∏è \".yellow(),\n                critical_count\n            ));\n        }\n\n        output.push_str(&format!(\n            \"\\nRun '{}' to execute planned actions.\\n\",\n            \"repolens apply\".cyan()\n        ));\n\n        output\n    }\n}\n\nimpl Default for TerminalOutput {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl OutputRenderer for TerminalOutput {\n    fn render_plan(\n        &self,\n        results: &AuditResults,\n        plan: &ActionPlan,\n    ) -> Result<String, RepoLensError> {\n        let mut output = String::new();\n\n        output.push_str(&self.format_header(&results.repository_name, &results.preset));\n        output.push_str(&self.format_findings(results));\n        output.push_str(&self.format_actions(plan));\n        output.push_str(&self.format_summary(results));\n\n        Ok(output)\n    }\n}\n\nimpl ReportRenderer for TerminalOutput {\n    fn render_report(&self, results: &AuditResults) -> Result<String, RepoLensError> {\n        let mut output = String::new();\n\n        output.push_str(&self.format_header(&results.repository_name, &results.preset));\n        output.push_str(&self.format_findings(results));\n        output.push_str(&self.format_summary(results));\n\n        Ok(output)\n    }\n}\n","traces":[{"line":17,"address":[209240,208128,209234],"length":1,"stats":{"Line":0}},{"line":18,"address":[907406,907502,907304,907180,907086],"length":1,"stats":{"Line":0}},{"line":25,"address":[208204],"length":1,"stats":{"Line":0}},{"line":27,"address":[208333],"length":1,"stats":{"Line":0}},{"line":28,"address":[208442],"length":1,"stats":{"Line":0}},{"line":29,"address":[208559],"length":1,"stats":{"Line":0}},{"line":30,"address":[208667],"length":1,"stats":{"Line":0}},{"line":34,"address":[211332,213701,209264],"length":1,"stats":{"Line":0}},{"line":35,"address":[209319],"length":1,"stats":{"Line":0}},{"line":37,"address":[210149,209651,209476,209552],"length":1,"stats":{"Line":0}},{"line":39,"address":[209453,209533,209372],"length":1,"stats":{"Line":0}},{"line":40,"address":[209620],"length":1,"stats":{"Line":0}},{"line":44,"address":[210183],"length":1,"stats":{"Line":0}},{"line":45,"address":[210253,210315],"length":1,"stats":{"Line":0}},{"line":46,"address":[210421,210531,210868],"length":1,"stats":{"Line":0}},{"line":48,"address":[909137,909210],"length":1,"stats":{"Line":0}},{"line":49,"address":[210500],"length":1,"stats":{"Line":0}},{"line":51,"address":[210894,211092],"length":1,"stats":{"Line":0}},{"line":52,"address":[211218,211163],"length":1,"stats":{"Line":0}},{"line":54,"address":[910014],"length":1,"stats":{"Line":0}},{"line":58,"address":[210360,211354],"length":1,"stats":{"Line":0}},{"line":59,"address":[211433,211377],"length":1,"stats":{"Line":0}},{"line":60,"address":[211968,211539,211643],"length":1,"stats":{"Line":0}},{"line":62,"address":[211512,211439],"length":1,"stats":{"Line":0}},{"line":63,"address":[211618],"length":1,"stats":{"Line":0}},{"line":65,"address":[910810,911002],"length":1,"stats":{"Line":0}},{"line":66,"address":[911073,911128],"length":1,"stats":{"Line":0}},{"line":68,"address":[212292],"length":1,"stats":{"Line":0}},{"line":72,"address":[911252,910294],"length":1,"stats":{"Line":0}},{"line":73,"address":[212459,212515],"length":1,"stats":{"Line":0}},{"line":74,"address":[212521,212622],"length":1,"stats":{"Line":0}},{"line":75,"address":[213104,213296],"length":1,"stats":{"Line":0}},{"line":76,"address":[213422,213367],"length":1,"stats":{"Line":0}},{"line":78,"address":[912218],"length":1,"stats":{"Line":0}},{"line":81,"address":[212560],"length":1,"stats":{"Line":0}},{"line":84,"address":[213744,215071,215077],"length":1,"stats":{"Line":0}},{"line":85,"address":[213821,213935],"length":1,"stats":{"Line":0}},{"line":87,"address":[912598],"length":1,"stats":{"Line":0}},{"line":88,"address":[213889],"length":1,"stats":{"Line":0}},{"line":92,"address":[214325],"length":1,"stats":{"Line":0}},{"line":93,"address":[214383,214499],"length":1,"stats":{"Line":0}},{"line":96,"address":[214424],"length":1,"stats":{"Line":0}},{"line":99,"address":[215104,217824,218255],"length":1,"stats":{"Line":0}},{"line":100,"address":[913975],"length":1,"stats":{"Line":0}},{"line":102,"address":[914087,914262,914163,914760],"length":1,"stats":{"Line":0}},{"line":104,"address":[914144,913980,914064],"length":1,"stats":{"Line":0}},{"line":105,"address":[914231],"length":1,"stats":{"Line":0}},{"line":108,"address":[215978],"length":1,"stats":{"Line":0}},{"line":109,"address":[217830,216032],"length":1,"stats":{"Line":0}},{"line":110,"address":[218215],"length":1,"stats":{"Line":0}},{"line":113,"address":[914821],"length":1,"stats":{"Line":0}},{"line":115,"address":[216074],"length":1,"stats":{"Line":0}},{"line":116,"address":[216489,217012,216611,216352],"length":1,"stats":{"Line":0}},{"line":118,"address":[216262],"length":1,"stats":{"Line":0}},{"line":119,"address":[216431],"length":1,"stats":{"Line":0}},{"line":120,"address":[216568],"length":1,"stats":{"Line":0}},{"line":123,"address":[915862],"length":1,"stats":{"Line":0}},{"line":124,"address":[217213],"length":1,"stats":{"Line":0}},{"line":128,"address":[216301],"length":1,"stats":{"Line":0}},{"line":131,"address":[218272,221519,221525],"length":1,"stats":{"Line":0}},{"line":132,"address":[218327],"length":1,"stats":{"Line":0}},{"line":134,"address":[218614,218515,218439,219106],"length":1,"stats":{"Line":0}},{"line":136,"address":[218332,218496,218416],"length":1,"stats":{"Line":0}},{"line":137,"address":[218583],"length":1,"stats":{"Line":0}},{"line":140,"address":[917956],"length":1,"stats":{"Line":0}},{"line":141,"address":[918005],"length":1,"stats":{"Line":0}},{"line":142,"address":[918054],"length":1,"stats":{"Line":0}},{"line":144,"address":[219554,219651,219431,220556,219331,219871,219774],"length":1,"stats":{"Line":0}},{"line":146,"address":[219279,219385],"length":1,"stats":{"Line":0}},{"line":147,"address":[219502,219605],"length":1,"stats":{"Line":0}},{"line":148,"address":[918538,918641],"length":1,"stats":{"Line":0}},{"line":151,"address":[919398],"length":1,"stats":{"Line":0}},{"line":152,"address":[220658,221054],"length":1,"stats":{"Line":0}},{"line":154,"address":[220627],"length":1,"stats":{"Line":0}},{"line":159,"address":[920250,919899],"length":1,"stats":{"Line":0}},{"line":161,"address":[220593],"length":1,"stats":{"Line":0}},{"line":164,"address":[221476],"length":1,"stats":{"Line":0}},{"line":169,"address":[221552],"length":1,"stats":{"Line":0}},{"line":170,"address":[920369],"length":1,"stats":{"Line":0}},{"line":175,"address":[222458,222464,221568],"length":1,"stats":{"Line":0}},{"line":180,"address":[221638],"length":1,"stats":{"Line":0}},{"line":182,"address":[221651,221752],"length":1,"stats":{"Line":0}},{"line":183,"address":[221947],"length":1,"stats":{"Line":0}},{"line":184,"address":[222085],"length":1,"stats":{"Line":0}},{"line":185,"address":[921042],"length":1,"stats":{"Line":0}},{"line":187,"address":[222359],"length":1,"stats":{"Line":0}},{"line":192,"address":[223184,223190,222480],"length":1,"stats":{"Line":0}},{"line":193,"address":[222531],"length":1,"stats":{"Line":0}},{"line":195,"address":[222627,222541],"length":1,"stats":{"Line":0}},{"line":196,"address":[222819],"length":1,"stats":{"Line":0}},{"line":197,"address":[222957],"length":1,"stats":{"Line":0}},{"line":199,"address":[223085],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":92},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","config","loader.rs"],"content":"//! Configuration loader\n\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\nuse crate::error::{ConfigError, RepoLensError};\n\nuse super::presets::Preset;\nuse super::{ActionsConfig, CustomRulesConfig, RuleConfig, SecretsConfig, TemplatesConfig, UrlConfig};\n\nconst CONFIG_FILENAME: &str = \".repolens.toml\";\n\n/// Main configuration structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Config {\n    /// Preset name (opensource, enterprise, strict)\n    #[serde(default = \"default_preset\")]\n    pub preset: String,\n\n    /// Rule overrides\n    #[serde(default)]\n    pub rules: HashMap<String, RuleConfig>,\n\n    /// Secrets detection configuration\n    #[serde(default)]\n    #[serde(rename = \"rules.secrets\")]\n    pub secrets: SecretsConfig,\n\n    /// URL detection configuration\n    #[serde(default)]\n    #[serde(rename = \"rules.urls\")]\n    pub urls: UrlConfig,\n\n    /// Actions configuration\n    #[serde(default)]\n    pub actions: ActionsConfig,\n\n    /// Template configuration\n    #[serde(default)]\n    pub templates: TemplatesConfig,\n\n    /// Custom rules configuration\n    #[serde(default)]\n    #[serde(rename = \"rules.custom\")]\n    pub custom_rules: CustomRulesConfig,\n}\n\nfn default_preset() -> String {\n    \"opensource\".to_string()\n}\n\nimpl Default for Config {\n    fn default() -> Self {\n        Self {\n            preset: \"opensource\".to_string(),\n            rules: HashMap::new(),\n            secrets: SecretsConfig::default(),\n            urls: UrlConfig::default(),\n            actions: ActionsConfig::default(),\n            templates: TemplatesConfig::default(),\n            custom_rules: CustomRulesConfig::default(),\n        }\n    }\n}\n\nimpl Config {\n    /// Load configuration from file or return default\n    pub fn load_or_default() -> Result<Self, RepoLensError> {\n        let config_path = Path::new(CONFIG_FILENAME);\n\n        if config_path.exists() {\n            Self::load_from_file(config_path)\n        } else {\n            Ok(Self::default())\n        }\n    }\n\n    /// Load configuration from a specific file\n    pub fn load_from_file(path: &Path) -> Result<Self, RepoLensError> {\n        let content = fs::read_to_string(path).map_err(|e| {\n            RepoLensError::Config(ConfigError::FileRead {\n                path: path.display().to_string(),\n                source: e,\n            })\n        })?;\n\n        toml::from_str(&content).map_err(Into::into)\n    }\n\n    /// Create a new configuration from a preset\n    pub fn from_preset(preset: Preset) -> Self {\n        let mut config = Self {\n            preset: preset.name().to_string(),\n            ..Default::default()\n        };\n\n        // Apply preset-specific defaults\n        match preset {\n            Preset::OpenSource => {\n                config.actions.license.enabled = true;\n                config.actions.contributing = true;\n                config.actions.code_of_conduct = true;\n                config.actions.security_policy = true;\n                config.actions.github_settings.discussions = true;\n            }\n            Preset::Enterprise => {\n                config.actions.license.enabled = false;\n                config.actions.contributing = false;\n                config.actions.code_of_conduct = false;\n                config.actions.security_policy = true;\n                config.actions.branch_protection.required_approvals = 2;\n                config.actions.branch_protection.require_signed_commits = true;\n                config.actions.github_settings.discussions = false;\n            }\n            Preset::Strict => {\n                config.actions.license.enabled = true;\n                config.actions.contributing = true;\n                config.actions.code_of_conduct = true;\n                config.actions.security_policy = true;\n                config.actions.branch_protection.required_approvals = 2;\n                config.actions.branch_protection.require_signed_commits = true;\n                config.actions.github_settings.discussions = true;\n            }\n        }\n\n        config\n    }\n\n    /// Serialize configuration to TOML\n    pub fn to_toml(&self) -> Result<String, RepoLensError> {\n        toml::to_string_pretty(self).map_err(Into::into)\n    }\n\n    /// Check if a rule is enabled\n    pub fn is_rule_enabled(&self, rule_id: &str) -> bool {\n        self.rules.get(rule_id).map(|r| r.enabled).unwrap_or(true)\n    }\n\n    /// Get severity override for a rule\n    #[allow(dead_code)]\n    pub fn get_rule_severity(&self, rule_id: &str) -> Option<&str> {\n        self.rules.get(rule_id).and_then(|r| r.severity.as_deref())\n    }\n\n    /// Check if a file should be ignored for secrets scanning\n    pub fn should_ignore_file(&self, file_path: &str) -> bool {\n        self.secrets\n            .ignore_files\n            .iter()\n            .any(|pattern| glob_match(pattern, file_path))\n    }\n\n    /// Check if a pattern should be ignored for secrets scanning\n    pub fn should_ignore_pattern(&self, path: &str) -> bool {\n        self.secrets\n            .ignore_patterns\n            .iter()\n            .any(|pattern| glob_match(pattern, path))\n    }\n\n    /// Check if a URL is allowed (for enterprise mode)\n    #[allow(dead_code)]\n    pub fn is_url_allowed(&self, url: &str) -> bool {\n        if self.urls.allowed_internal.is_empty() {\n            return false;\n        }\n\n        self.urls\n            .allowed_internal\n            .iter()\n            .any(|pattern| glob_match(pattern, url))\n    }\n}\n\n/// Simple glob matching (supports * and **)\npub fn glob_match(pattern: &str, text: &str) -> bool {\n    if pattern.contains(\"**\") {\n        return glob_match_double_star(pattern, text);\n    }\n\n    if pattern.contains('*') {\n        return glob_match_single_star(pattern, text);\n    }\n\n    text == pattern\n}\n\n/// Match pattern with double star (**)\nfn glob_match_double_star(pattern: &str, text: &str) -> bool {\n    let parts: Vec<&str> = pattern.split(\"**\").collect();\n\n    // Handle patterns like \"**/test/**\" which split into ['', '/test/', '']\n    if parts.len() == 3 && parts[0].is_empty() && parts[2].is_empty() {\n        // Pattern is **something**, check if text contains something\n        let middle = parts[1].trim_matches('/');\n        return text.contains(&format!(\"/{}\", middle)) || text.starts_with(middle);\n    }\n\n    if parts.len() != 2 {\n        return false;\n    }\n\n    let prefix = parts[0].trim_end_matches('/');\n    let suffix_raw = parts[1];\n    let suffix = suffix_raw.trim_start_matches('/');\n\n    if !prefix.is_empty() && !text.starts_with(prefix) {\n        return false;\n    }\n\n    if suffix.is_empty() {\n        // Pattern like \"**\" or \"prefix/**\" matches everything\n        return true;\n    }\n\n    // Handle patterns like *.test.ts\n    if suffix.starts_with('*') {\n        let suffix_pattern = suffix.trim_start_matches('*');\n        return text.ends_with(suffix_pattern);\n    }\n\n    // For patterns like \"**/test/**\" or \"**/test\", check if suffix appears anywhere\n    if prefix.is_empty() {\n        // Pattern starts with **, check if suffix appears anywhere\n        // For \"**/test/**\", suffix_raw is \"/test/\", suffix is \"test/\"\n        // We need to check if the path contains \"/test/\" anywhere\n        // Since suffix_raw had a leading slash, check for \"/suffix\" pattern\n        if suffix_raw.starts_with('/') {\n            // Check for \"/suffix\" in the path (e.g., \"/test/\" in \"src/test/file.ts\")\n            // suffix is \"test/\" so we check for \"/test/\"\n            // Also handle case where path starts with \"test/\"\n            let pattern_to_find = format!(\"/{}\", suffix);\n            if text.contains(&pattern_to_find) {\n                return true;\n            }\n            // Also check if text starts with suffix (for paths like \"test/file.ts\")\n            if text.starts_with(suffix) {\n                return true;\n            }\n            return false;\n        }\n        // No leading slash in original, check for suffix anywhere\n        return text.contains(suffix);\n    }\n\n    // Pattern has both prefix and suffix\n    // Check if text starts with prefix and contains suffix after prefix\n    if let Some(after_prefix) = text.strip_prefix(prefix) {\n        return after_prefix.contains(suffix) || after_prefix.ends_with(suffix);\n    }\n\n    // Fallback: check ends or contains\n    text.ends_with(suffix) || text.contains(suffix)\n}\n\n/// Match pattern with single star (*)\nfn glob_match_single_star(pattern: &str, text: &str) -> bool {\n    let parts: Vec<&str> = pattern.split('*').collect();\n    let mut pos = 0;\n\n    for (i, part) in parts.iter().enumerate() {\n        if part.is_empty() {\n            continue;\n        }\n\n        if let Some(found_pos) = text[pos..].find(part) {\n            if i == 0 && found_pos != 0 {\n                return false;\n            }\n            pos += found_pos + part.len();\n        } else {\n            return false;\n        }\n    }\n\n    if let Some(last_part) = parts.last() {\n        if !last_part.is_empty() {\n            return text.ends_with(last_part);\n        }\n    }\n\n    true\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_glob_match() {\n        assert!(glob_match(\"*.ts\", \"file.ts\"));\n        assert!(glob_match(\"*.ts\", \"path/to/file.ts\"));\n        assert!(!glob_match(\"*.ts\", \"file.js\"));\n\n        // For \"**/test/**\", we check if path contains \"/test/\" anywhere\n        // For \"**/test/**\", check if path contains \"/test/\" anywhere\n        // \"src/test/file.ts\" contains \"/test/\" so it should match\n        assert!(\n            glob_match(\"**/test/**\", \"src/test/file.ts\"),\n            \"Pattern **/test/** should match src/test/file.ts\"\n        );\n        assert!(glob_match(\"**/test/**\", \"test/file.ts\"));\n        assert!(glob_match(\"**/*.test.ts\", \"src/file.test.ts\"));\n    }\n\n    #[test]\n    fn test_default_config() {\n        let config = Config::default();\n        assert_eq!(config.preset, \"opensource\");\n        assert!(config.actions.gitignore);\n    }\n\n    #[test]\n    fn test_from_preset() {\n        let config = Config::from_preset(Preset::Enterprise);\n        assert_eq!(config.preset, \"enterprise\");\n        assert!(!config.actions.license.enabled);\n        assert_eq!(config.actions.branch_protection.required_approvals, 2);\n    }\n\n    #[test]\n    fn test_custom_rules_config_parsing() {\n        let toml_content = r#\"\npreset = \"opensource\"\n\n[\"rules.custom\".\"no-todo\"]\npattern = \"TODO\"\nseverity = \"warning\"\nfiles = [\"**/*.rs\"]\nmessage = \"TODO comment found\"\n\"#;\n        let config: Config = toml::from_str(toml_content).unwrap();\n        assert!(config.custom_rules.rules.contains_key(\"no-todo\"));\n        let rule = config.custom_rules.rules.get(\"no-todo\").unwrap();\n        assert_eq!(rule.pattern, \"TODO\");\n        assert_eq!(rule.severity, \"warning\");\n    }\n}\n","traces":[{"line":50,"address":[248704],"length":1,"stats":{"Line":0}},{"line":51,"address":[683512],"length":1,"stats":{"Line":0}},{"line":55,"address":[684096,683536,684090],"length":1,"stats":{"Line":10}},{"line":57,"address":[683552],"length":1,"stats":{"Line":2}},{"line":58,"address":[683583],"length":1,"stats":{"Line":16}},{"line":59,"address":[683636],"length":1,"stats":{"Line":2}},{"line":60,"address":[683685],"length":1,"stats":{"Line":16}},{"line":61,"address":[683734],"length":1,"stats":{"Line":2}},{"line":62,"address":[683786],"length":1,"stats":{"Line":9}},{"line":63,"address":[683838],"length":1,"stats":{"Line":9}},{"line":70,"address":[249312],"length":1,"stats":{"Line":0}},{"line":71,"address":[684128],"length":1,"stats":{"Line":0}},{"line":73,"address":[684216,684178],"length":1,"stats":{"Line":0}},{"line":74,"address":[684232],"length":1,"stats":{"Line":0}},{"line":76,"address":[684187],"length":1,"stats":{"Line":0}},{"line":81,"address":[684256,684612,684618],"length":1,"stats":{"Line":0}},{"line":82,"address":[550759,550753,550512],"length":1,"stats":{"Line":0}},{"line":83,"address":[550667],"length":1,"stats":{"Line":0}},{"line":84,"address":[550622,550544],"length":1,"stats":{"Line":0}},{"line":85,"address":[316998],"length":1,"stats":{"Line":0}},{"line":89,"address":[684490,684561],"length":1,"stats":{"Line":0}},{"line":93,"address":[684640,685485,685479],"length":1,"stats":{"Line":2}},{"line":95,"address":[684669],"length":1,"stats":{"Line":2}},{"line":100,"address":[685252],"length":1,"stats":{"Line":2}},{"line":101,"address":[685324],"length":1,"stats":{"Line":0}},{"line":102,"address":[250484],"length":1,"stats":{"Line":0}},{"line":103,"address":[685292],"length":1,"stats":{"Line":0}},{"line":104,"address":[685300],"length":1,"stats":{"Line":0}},{"line":105,"address":[685308],"length":1,"stats":{"Line":0}},{"line":106,"address":[685316],"length":1,"stats":{"Line":0}},{"line":108,"address":[685385],"length":1,"stats":{"Line":2}},{"line":109,"address":[250526],"length":1,"stats":{"Line":2}},{"line":110,"address":[685334],"length":1,"stats":{"Line":2}},{"line":111,"address":[685342],"length":1,"stats":{"Line":2}},{"line":112,"address":[685350],"length":1,"stats":{"Line":2}},{"line":113,"address":[685358],"length":1,"stats":{"Line":2}},{"line":114,"address":[685369],"length":1,"stats":{"Line":2}},{"line":115,"address":[685377],"length":1,"stats":{"Line":2}},{"line":118,"address":[685387],"length":1,"stats":{"Line":0}},{"line":119,"address":[685395],"length":1,"stats":{"Line":0}},{"line":120,"address":[685403],"length":1,"stats":{"Line":0}},{"line":121,"address":[685411],"length":1,"stats":{"Line":0}},{"line":122,"address":[685419],"length":1,"stats":{"Line":0}},{"line":123,"address":[685430],"length":1,"stats":{"Line":0}},{"line":124,"address":[685438],"length":1,"stats":{"Line":0}},{"line":128,"address":[685451],"length":1,"stats":{"Line":2}},{"line":132,"address":[685504],"length":1,"stats":{"Line":0}},{"line":133,"address":[685522],"length":1,"stats":{"Line":0}},{"line":137,"address":[685568],"length":1,"stats":{"Line":5}},{"line":138,"address":[550789,550784],"length":1,"stats":{"Line":3}},{"line":143,"address":[685632],"length":1,"stats":{"Line":0}},{"line":144,"address":[550800,550809],"length":1,"stats":{"Line":0}},{"line":148,"address":[685680],"length":1,"stats":{"Line":2}},{"line":149,"address":[685708],"length":1,"stats":{"Line":2}},{"line":152,"address":[550864,550832],"length":1,"stats":{"Line":4}},{"line":156,"address":[250976],"length":1,"stats":{"Line":2}},{"line":157,"address":[685804],"length":1,"stats":{"Line":2}},{"line":160,"address":[550912,550944],"length":1,"stats":{"Line":0}},{"line":165,"address":[685872],"length":1,"stats":{"Line":0}},{"line":166,"address":[685905],"length":1,"stats":{"Line":0}},{"line":167,"address":[251189],"length":1,"stats":{"Line":0}},{"line":170,"address":[251123],"length":1,"stats":{"Line":0}},{"line":173,"address":[551024,550992],"length":1,"stats":{"Line":0}},{"line":178,"address":[686016],"length":1,"stats":{"Line":2}},{"line":179,"address":[251239],"length":1,"stats":{"Line":2}},{"line":180,"address":[251296],"length":1,"stats":{"Line":2}},{"line":183,"address":[686070],"length":1,"stats":{"Line":2}},{"line":184,"address":[251350],"length":1,"stats":{"Line":2}},{"line":187,"address":[686128],"length":1,"stats":{"Line":2}},{"line":191,"address":[687067,686192,688529],"length":1,"stats":{"Line":2}},{"line":192,"address":[251456],"length":1,"stats":{"Line":2}},{"line":195,"address":[686398,686327,686480],"length":1,"stats":{"Line":6}},{"line":197,"address":[251802],"length":1,"stats":{"Line":2}},{"line":198,"address":[251916,252261],"length":1,"stats":{"Line":4}},{"line":201,"address":[252285,251646],"length":1,"stats":{"Line":4}},{"line":202,"address":[687125],"length":1,"stats":{"Line":0}},{"line":205,"address":[252291,252347],"length":1,"stats":{"Line":4}},{"line":206,"address":[252434],"length":1,"stats":{"Line":2}},{"line":207,"address":[252519],"length":1,"stats":{"Line":2}},{"line":209,"address":[252572,252665],"length":1,"stats":{"Line":2}},{"line":210,"address":[252671],"length":1,"stats":{"Line":0}},{"line":213,"address":[687430,687484],"length":1,"stats":{"Line":4}},{"line":215,"address":[687526],"length":1,"stats":{"Line":0}},{"line":219,"address":[252747,252694],"length":1,"stats":{"Line":4}},{"line":220,"address":[252774,253684],"length":1,"stats":{"Line":4}},{"line":221,"address":[688496],"length":1,"stats":{"Line":2}},{"line":225,"address":[687615,687559],"length":1,"stats":{"Line":0}},{"line":230,"address":[252882,253279],"length":1,"stats":{"Line":0}},{"line":234,"address":[688128,688173],"length":1,"stats":{"Line":0}},{"line":235,"address":[253501,253560],"length":1,"stats":{"Line":0}},{"line":236,"address":[688409],"length":1,"stats":{"Line":0}},{"line":239,"address":[688423,688378],"length":1,"stats":{"Line":0}},{"line":245,"address":[688159,688097],"length":1,"stats":{"Line":0}},{"line":250,"address":[687711,687647],"length":1,"stats":{"Line":0}},{"line":251,"address":[687800,687882],"length":1,"stats":{"Line":0}},{"line":255,"address":[687964,687847],"length":1,"stats":{"Line":0}},{"line":259,"address":[688544,689661,689667],"length":1,"stats":{"Line":2}},{"line":260,"address":[253824],"length":1,"stats":{"Line":2}},{"line":261,"address":[688679],"length":1,"stats":{"Line":2}},{"line":263,"address":[688691,689638,688778],"length":1,"stats":{"Line":6}},{"line":264,"address":[689330,689055],"length":1,"stats":{"Line":4}},{"line":268,"address":[689356],"length":1,"stats":{"Line":2}},{"line":269,"address":[689490,689516],"length":1,"stats":{"Line":2}},{"line":270,"address":[254762],"length":1,"stats":{"Line":0}},{"line":272,"address":[689569,689527,689643],"length":1,"stats":{"Line":4}},{"line":274,"address":[689498],"length":1,"stats":{"Line":2}},{"line":278,"address":[689079],"length":1,"stats":{"Line":2}},{"line":279,"address":[689241,689195],"length":1,"stats":{"Line":4}},{"line":280,"address":[689268],"length":1,"stats":{"Line":2}},{"line":284,"address":[689213],"length":1,"stats":{"Line":0}}],"covered":59,"coverable":110},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","config","mod.rs"],"content":"//! Configuration module\n\npub mod loader;\npub mod presets;\n\npub use loader::Config;\npub use presets::Preset;\n\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n/// Rule configuration\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct RuleConfig {\n    /// Whether the rule is enabled\n    #[serde(default = \"default_true\")]\n    pub enabled: bool,\n\n    /// Severity override (critical, warning, info)\n    pub severity: Option<String>,\n}\n\nfn default_true() -> bool {\n    true\n}\n\n/// Secrets configuration\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct SecretsConfig {\n    /// Patterns to ignore when scanning for secrets\n    #[serde(default)]\n    pub ignore_patterns: Vec<String>,\n\n    /// Files to ignore when scanning for secrets\n    #[serde(default)]\n    pub ignore_files: Vec<String>,\n\n    /// Custom secret patterns to detect\n    #[serde(default)]\n    pub custom_patterns: Vec<String>,\n}\n\n/// URL configuration\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct UrlConfig {\n    /// Allowed internal URLs (for enterprise mode)\n    #[serde(default)]\n    pub allowed_internal: Vec<String>,\n}\n\n/// Actions configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ActionsConfig {\n    /// Whether to update .gitignore\n    #[serde(default = \"default_true\")]\n    pub gitignore: bool,\n\n    /// License configuration\n    #[serde(default)]\n    pub license: LicenseConfig,\n\n    /// Whether to create CONTRIBUTING.md\n    #[serde(default = \"default_true\")]\n    pub contributing: bool,\n\n    /// Whether to create CODE_OF_CONDUCT.md\n    #[serde(default = \"default_true\")]\n    pub code_of_conduct: bool,\n\n    /// Whether to create SECURITY.md\n    #[serde(default = \"default_true\")]\n    pub security_policy: bool,\n\n    /// Branch protection configuration\n    #[serde(default)]\n    pub branch_protection: BranchProtectionConfig,\n\n    /// GitHub settings configuration\n    #[serde(default)]\n    pub github_settings: GitHubSettingsConfig,\n}\n\nimpl Default for ActionsConfig {\n    fn default() -> Self {\n        Self {\n            gitignore: true,\n            license: LicenseConfig::default(),\n            contributing: true,\n            code_of_conduct: true,\n            security_policy: true,\n            branch_protection: BranchProtectionConfig::default(),\n            github_settings: GitHubSettingsConfig::default(),\n        }\n    }\n}\n\n/// License configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LicenseConfig {\n    /// Whether to create LICENSE file\n    #[serde(default = \"default_true\")]\n    pub enabled: bool,\n\n    /// License type (MIT, Apache-2.0, GPL-3.0, etc.)\n    #[serde(default = \"default_license_type\")]\n    pub license_type: String,\n\n    /// Author name for license\n    #[serde(default)]\n    pub author: Option<String>,\n\n    /// Year for license (defaults to current year)\n    #[serde(default)]\n    pub year: Option<String>,\n}\n\nimpl Default for LicenseConfig {\n    fn default() -> Self {\n        Self {\n            enabled: true,\n            license_type: \"MIT\".to_string(),\n            author: None,\n            year: None,\n        }\n    }\n}\n\nfn default_license_type() -> String {\n    \"MIT\".to_string()\n}\n\n/// Branch protection configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BranchProtectionConfig {\n    /// Whether to enable branch protection\n    #[serde(default = \"default_true\")]\n    pub enabled: bool,\n\n    /// Branch to protect (defaults to main)\n    #[serde(default = \"default_branch\")]\n    pub branch: String,\n\n    /// Number of required approvals\n    #[serde(default = \"default_approvals\")]\n    pub required_approvals: u32,\n\n    /// Whether to require status checks\n    #[serde(default = \"default_true\")]\n    pub require_status_checks: bool,\n\n    /// Whether to block force pushes\n    #[serde(default = \"default_true\")]\n    pub block_force_push: bool,\n\n    /// Whether to require signed commits\n    #[serde(default)]\n    pub require_signed_commits: bool,\n}\n\nimpl Default for BranchProtectionConfig {\n    fn default() -> Self {\n        Self {\n            enabled: true,\n            branch: \"main\".to_string(),\n            required_approvals: 1,\n            require_status_checks: true,\n            block_force_push: true,\n            require_signed_commits: false,\n        }\n    }\n}\n\nfn default_branch() -> String {\n    \"main\".to_string()\n}\n\nfn default_approvals() -> u32 {\n    1\n}\n\n/// GitHub settings configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GitHubSettingsConfig {\n    /// Whether to enable GitHub Discussions\n    #[serde(default = \"default_true\")]\n    pub discussions: bool,\n\n    /// Whether to enable GitHub Issues\n    #[serde(default = \"default_true\")]\n    pub issues: bool,\n\n    /// Whether to enable GitHub Wiki\n    #[serde(default)]\n    pub wiki: bool,\n\n    /// Whether to enable vulnerability alerts\n    #[serde(default = \"default_true\")]\n    pub vulnerability_alerts: bool,\n\n    /// Whether to enable automatic security fixes\n    #[serde(default = \"default_true\")]\n    pub automated_security_fixes: bool,\n}\n\nimpl Default for GitHubSettingsConfig {\n    fn default() -> Self {\n        Self {\n            discussions: true,\n            issues: true,\n            wiki: false,\n            vulnerability_alerts: true,\n            automated_security_fixes: true,\n        }\n    }\n}\n\n/// Template configuration\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct TemplatesConfig {\n    /// Author name for templates\n    pub license_author: Option<String>,\n\n    /// Year for templates\n    pub license_year: Option<String>,\n\n    /// Project name override\n    pub project_name: Option<String>,\n\n    /// Project description\n    pub project_description: Option<String>,\n}\n\n/// Custom rule configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CustomRule {\n    /// Regex pattern to match\n    pub pattern: String,\n\n    /// Severity level (critical, warning, info)\n    #[serde(default = \"default_custom_severity\")]\n    pub severity: String,\n\n    /// File glob patterns to include\n    #[serde(default)]\n    pub files: Vec<String>,\n\n    /// Custom message for the finding\n    pub message: Option<String>,\n\n    /// Detailed description\n    pub description: Option<String>,\n\n    /// Suggested remediation\n    pub remediation: Option<String>,\n\n    /// If true, fail when pattern is NOT found (inverted matching)\n    #[serde(default)]\n    pub invert: bool,\n}\n\nfn default_custom_severity() -> String {\n    \"warning\".to_string()\n}\n\n/// Custom rules configuration container\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct CustomRulesConfig {\n    /// Map of rule ID to rule configuration\n    #[serde(flatten)]\n    pub rules: HashMap<String, CustomRule>,\n}\n","traces":[{"line":84,"address":[582046,582052,581760],"length":1,"stats":{"Line":2}},{"line":87,"address":[1496230],"length":1,"stats":{"Line":2}},{"line":91,"address":[1496240],"length":1,"stats":{"Line":11}},{"line":92,"address":[1496284,1496338],"length":1,"stats":{"Line":20}},{"line":118,"address":[1496528],"length":1,"stats":{"Line":10}},{"line":121,"address":[1496541],"length":1,"stats":{"Line":9}},{"line":128,"address":[1496704],"length":1,"stats":{"Line":0}},{"line":129,"address":[1496712],"length":1,"stats":{"Line":0}},{"line":161,"address":[1496736],"length":1,"stats":{"Line":9}},{"line":164,"address":[1496749],"length":1,"stats":{"Line":11}},{"line":173,"address":[1496848],"length":1,"stats":{"Line":0}},{"line":174,"address":[1496856],"length":1,"stats":{"Line":0}},{"line":261,"address":[1496944],"length":1,"stats":{"Line":0}},{"line":262,"address":[1496952],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":14},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","config","presets","mod.rs"],"content":"//! Preset configurations for different use cases\n\n/// Available presets\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum Preset {\n    /// Open source project - prepare for public release\n    OpenSource,\n    /// Enterprise project - internal company standards\n    Enterprise,\n    /// Strict mode - maximum security and compliance\n    Strict,\n}\n\nimpl Preset {\n    /// Get preset from name\n    pub fn from_name(name: &str) -> Option<Self> {\n        match name.to_lowercase().as_str() {\n            \"opensource\" | \"open-source\" | \"oss\" => Some(Self::OpenSource),\n            \"enterprise\" | \"ent\" | \"internal\" => Some(Self::Enterprise),\n            \"strict\" | \"secure\" | \"compliance\" => Some(Self::Strict),\n            _ => None,\n        }\n    }\n\n    /// Get the name of the preset\n    pub fn name(&self) -> &'static str {\n        match self {\n            Self::OpenSource => \"opensource\",\n            Self::Enterprise => \"enterprise\",\n            Self::Strict => \"strict\",\n        }\n    }\n\n    /// Get a description of the preset\n    #[allow(dead_code)]\n    pub fn description(&self) -> &'static str {\n        match self {\n            Self::OpenSource => \"Prepare repository for public open source release\",\n            Self::Enterprise => \"Apply internal company standards and policies\",\n            Self::Strict => \"Maximum security and compliance checks\",\n        }\n    }\n\n    /// Get the rules that should be enabled for this preset\n    #[allow(dead_code)]\n    pub fn enabled_rules(&self) -> Vec<&'static str> {\n        match self {\n            Self::OpenSource => vec![\n                \"secrets/hardcoded\",\n                \"secrets/files\",\n                \"secrets/env\",\n                \"docs/readme\",\n                \"docs/license\",\n                \"docs/contributing\",\n                \"docs/code-of-conduct\",\n                \"docs/security\",\n                \"files/sensitive\",\n                \"files/large\",\n                \"files/gitignore\",\n                \"security/dependencies\",\n                \"workflows/secrets\",\n                \"workflows/permissions\",\n                \"github/branch-protection\",\n                \"github/settings\",\n            ],\n            Self::Enterprise => vec![\n                \"secrets/hardcoded\",\n                \"secrets/files\",\n                \"secrets/env\",\n                \"docs/readme\",\n                \"docs/security\",\n                \"files/sensitive\",\n                \"files/large\",\n                \"files/gitignore\",\n                \"security/dependencies\",\n                \"security/codeowners\",\n                \"security/signed-commits\",\n                \"workflows/secrets\",\n                \"workflows/permissions\",\n                \"github/branch-protection\",\n                \"github/settings\",\n            ],\n            Self::Strict => vec![\n                \"secrets/hardcoded\",\n                \"secrets/files\",\n                \"secrets/env\",\n                \"secrets/history\",\n                \"docs/readme\",\n                \"docs/license\",\n                \"docs/contributing\",\n                \"docs/code-of-conduct\",\n                \"docs/security\",\n                \"docs/changelog\",\n                \"files/sensitive\",\n                \"files/large\",\n                \"files/gitignore\",\n                \"files/editorconfig\",\n                \"security/dependencies\",\n                \"security/codeowners\",\n                \"security/signed-commits\",\n                \"workflows/secrets\",\n                \"workflows/permissions\",\n                \"workflows/pinned-actions\",\n                \"github/branch-protection\",\n                \"github/settings\",\n                \"quality/tests\",\n                \"quality/linting\",\n            ],\n        }\n    }\n\n    /// Get rules with critical severity for this preset\n    #[allow(dead_code)]\n    pub fn critical_rules(&self) -> Vec<&'static str> {\n        match self {\n            Self::OpenSource => vec![\"secrets/hardcoded\", \"secrets/files\", \"docs/license\"],\n            Self::Enterprise => vec![\"secrets/hardcoded\", \"secrets/files\", \"security/codeowners\"],\n            Self::Strict => vec![\n                \"secrets/hardcoded\",\n                \"secrets/files\",\n                \"secrets/history\",\n                \"docs/license\",\n                \"security/codeowners\",\n                \"security/signed-commits\",\n            ],\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_preset_from_name() {\n        assert_eq!(Preset::from_name(\"opensource\").unwrap(), Preset::OpenSource);\n        assert_eq!(Preset::from_name(\"oss\").unwrap(), Preset::OpenSource);\n        assert_eq!(Preset::from_name(\"enterprise\").unwrap(), Preset::Enterprise);\n        assert_eq!(Preset::from_name(\"strict\").unwrap(), Preset::Strict);\n        assert!(Preset::from_name(\"invalid\").is_none());\n    }\n\n    #[test]\n    fn test_preset_name() {\n        assert_eq!(Preset::OpenSource.name(), \"opensource\");\n        assert_eq!(Preset::Enterprise.name(), \"enterprise\");\n        assert_eq!(Preset::Strict.name(), \"strict\");\n    }\n}\n","traces":[{"line":16,"address":[532608,533198,533192],"length":1,"stats":{"Line":2}},{"line":17,"address":[532631,532720],"length":1,"stats":{"Line":4}},{"line":18,"address":[532736],"length":1,"stats":{"Line":2}},{"line":19,"address":[532883],"length":1,"stats":{"Line":2}},{"line":20,"address":[693846],"length":1,"stats":{"Line":2}},{"line":21,"address":[533164],"length":1,"stats":{"Line":2}},{"line":26,"address":[533216],"length":1,"stats":{"Line":2}},{"line":27,"address":[533221],"length":1,"stats":{"Line":2}},{"line":28,"address":[533253],"length":1,"stats":{"Line":2}},{"line":29,"address":[533276],"length":1,"stats":{"Line":2}},{"line":30,"address":[533299],"length":1,"stats":{"Line":2}},{"line":36,"address":[533344],"length":1,"stats":{"Line":0}},{"line":37,"address":[533349],"length":1,"stats":{"Line":0}},{"line":38,"address":[533381],"length":1,"stats":{"Line":0}},{"line":39,"address":[694220],"length":1,"stats":{"Line":0}},{"line":40,"address":[533427],"length":1,"stats":{"Line":0}},{"line":46,"address":[533472],"length":1,"stats":{"Line":0}},{"line":47,"address":[533491],"length":1,"stats":{"Line":0}},{"line":48,"address":[694339,694453],"length":1,"stats":{"Line":0}},{"line":66,"address":[533555,534082],"length":1,"stats":{"Line":0}},{"line":83,"address":[533594,534494],"length":1,"stats":{"Line":0}},{"line":114,"address":[535136],"length":1,"stats":{"Line":0}},{"line":115,"address":[535155],"length":1,"stats":{"Line":0}},{"line":116,"address":[535187,535301],"length":1,"stats":{"Line":0}},{"line":117,"address":[535219,535448],"length":1,"stats":{"Line":0}},{"line":118,"address":[535587,535258],"length":1,"stats":{"Line":0}}],"covered":11,"coverable":26},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","error.rs"],"content":"//! Error types for RepoLens\n//!\n//! This module defines custom error types using `thiserror` for better error handling\n//! and more descriptive error messages throughout the application.\n\nuse thiserror::Error;\n\n/// Main error type for RepoLens\n#[derive(Error, Debug)]\npub enum RepoLensError {\n    /// Scan-related errors\n    #[error(\"Scan error: {0}\")]\n    Scan(#[from] ScanError),\n\n    /// Configuration-related errors\n    #[error(\"Config error: {0}\")]\n    Config(#[from] ConfigError),\n\n    /// Provider-related errors (GitHub API, etc.)\n    #[error(\"Provider error: {0}\")]\n    Provider(#[from] ProviderError),\n\n    /// Action execution errors\n    #[error(\"Action error: {0}\")]\n    Action(#[from] ActionError),\n\n    /// Rule execution errors\n    #[error(\"Rule error: {0}\")]\n    Rule(#[from] RuleError),\n}\n\n/// Errors that occur during repository scanning\n#[derive(Error, Debug)]\npub enum ScanError {\n    /// Failed to read a file\n    #[error(\"Failed to read file '{path}': {source}\")]\n    FileRead {\n        /// Path to the file that failed to read\n        path: String,\n        /// The underlying I/O error\n        source: std::io::Error,\n    },\n}\n\n/// Errors that occur during configuration loading and parsing\n#[derive(Error, Debug)]\npub enum ConfigError {\n    /// Failed to read configuration file\n    #[error(\"Failed to read configuration file '{path}': {source}\")]\n    FileRead {\n        /// Path to the configuration file\n        path: String,\n        /// The underlying I/O error\n        source: std::io::Error,\n    },\n\n    /// Failed to parse configuration file\n    #[error(\"Failed to parse configuration file: {message}\")]\n    Parse {\n        /// Error message describing the parse failure\n        message: String,\n    },\n\n    /// Failed to serialize configuration\n    #[error(\"Failed to serialize configuration: {message}\")]\n    Serialize {\n        /// Error message describing the serialization failure\n        message: String,\n    },\n\n    /// Invalid preset name\n    #[error(\"Invalid preset name: {name}\")]\n    InvalidPreset {\n        /// The invalid preset name\n        name: String,\n    },\n}\n\n/// Errors that occur when interacting with external providers (GitHub API, etc.)\n#[derive(Error, Debug)]\npub enum ProviderError {\n    /// Command execution failed\n    #[error(\"Command execution failed: {command}\")]\n    CommandFailed {\n        /// The command that failed\n        command: String,\n    },\n\n    /// Failed to parse JSON response\n    #[error(\"Failed to parse JSON response: {message}\")]\n    JsonParse {\n        /// Error message describing the parse failure\n        message: String,\n    },\n\n    /// Not in a GitHub repository or not authenticated\n    #[error(\"Not in a GitHub repository or not authenticated\")]\n    NotAuthenticated,\n\n    /// Invalid repository name format\n    #[error(\"Invalid repository name format: {name}\")]\n    InvalidRepoName {\n        /// The invalid repository name\n        name: String,\n    },\n\n    /// GitHub CLI not available\n    #[error(\"GitHub CLI (gh) is not available or not authenticated\")]\n    GitHubCliNotAvailable,\n}\n\n/// Errors that occur during action execution\n#[derive(Error, Debug)]\npub enum ActionError {\n    /// Failed to create file\n    #[error(\"Failed to create file '{path}': {source}\")]\n    #[allow(dead_code)]\n    FileCreate {\n        /// Path to the file that failed to create\n        path: String,\n        /// The underlying I/O error\n        source: std::io::Error,\n    },\n\n    /// Failed to write file\n    #[error(\"Failed to write file '{path}': {source}\")]\n    FileWrite {\n        /// Path to the file that failed to write\n        path: String,\n        /// The underlying I/O error\n        source: std::io::Error,\n    },\n\n    /// Failed to create directory\n    #[error(\"Failed to create directory '{path}': {source}\")]\n    DirectoryCreate {\n        /// Path to the directory that failed to create\n        path: String,\n        /// The underlying I/O error\n        source: std::io::Error,\n    },\n\n    /// Unknown template\n    #[error(\"Unknown template: {name}\")]\n    UnknownTemplate {\n        /// The unknown template name\n        name: String,\n    },\n\n    /// Action execution failed\n    #[error(\"Action execution failed: {message}\")]\n    ExecutionFailed {\n        /// Error message describing the failure\n        message: String,\n    },\n}\n\n/// Errors that occur during rule execution\n#[derive(Error, Debug)]\npub enum RuleError {\n    /// Rule execution failed\n    #[error(\"Rule execution failed: {message}\")]\n    ExecutionFailed {\n        /// Error message describing the failure\n        message: String,\n    },\n}\n\n// Allow conversion from std::io::Error for convenience\nimpl From<std::io::Error> for RepoLensError {\n    fn from(err: std::io::Error) -> Self {\n        RepoLensError::Scan(ScanError::FileRead {\n            path: \"unknown\".to_string(),\n            source: err,\n        })\n    }\n}\n\n// Conversion from toml::de::Error\nimpl From<toml::de::Error> for RepoLensError {\n    fn from(err: toml::de::Error) -> Self {\n        RepoLensError::Config(ConfigError::Parse {\n            message: err.to_string(),\n        })\n    }\n}\n\n// Conversion from toml::ser::Error\nimpl From<toml::ser::Error> for RepoLensError {\n    fn from(err: toml::ser::Error) -> Self {\n        RepoLensError::Config(ConfigError::Serialize {\n            message: err.to_string(),\n        })\n    }\n}\n\n// Conversion from serde_json::Error\nimpl From<serde_json::Error> for RepoLensError {\n    fn from(err: serde_json::Error) -> Self {\n        RepoLensError::Provider(ProviderError::JsonParse {\n            message: err.to_string(),\n        })\n    }\n}\n","traces":[{"line":170,"address":[12777514,12778298],"length":1,"stats":{"Line":2}},{"line":171,"address":[6393129],"length":1,"stats":{"Line":2}},{"line":172,"address":[8448433,8447649],"length":1,"stats":{"Line":2}},{"line":173,"address":[3277710],"length":1,"stats":{"Line":0}},{"line":174,"address":[6392969],"length":1,"stats":{"Line":4}},{"line":180,"address":[6393184],"length":1,"stats":{"Line":0}},{"line":181,"address":[847124,846944],"length":1,"stats":{"Line":0}},{"line":182,"address":[12778784],"length":1,"stats":{"Line":2}},{"line":183,"address":[3277906],"length":1,"stats":{"Line":0}},{"line":189,"address":[6699161],"length":1,"stats":{"Line":0}},{"line":190,"address":[12778839],"length":1,"stats":{"Line":0}},{"line":191,"address":[15778011],"length":1,"stats":{"Line":0}},{"line":192,"address":[6698992],"length":1,"stats":{"Line":0}},{"line":198,"address":[10625488],"length":1,"stats":{"Line":2}},{"line":199,"address":[999472,999657,999651],"length":1,"stats":{"Line":6}},{"line":200,"address":[8449469],"length":1,"stats":{"Line":2}},{"line":201,"address":[8449551,8449612],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":17},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","lib.rs"],"content":"//! RepoLens Library\n//!\n//! This crate provides the core functionality for auditing repositories\n//! and preparing them for open source or enterprise standards.\n\npub mod actions;\npub mod cli;\npub mod config;\npub mod error;\npub mod providers;\npub mod rules;\npub mod scanner;\npub mod utils;\n\npub use error::RepoLensError;\n\n/// Exit codes for the CLI\npub mod exit_codes {\n    /// Success - no issues found\n    pub const SUCCESS: i32 = 0;\n    /// Critical issues found that block release\n    pub const CRITICAL_ISSUES: i32 = 1;\n    /// Warnings found but not blocking\n    pub const WARNINGS: i32 = 2;\n    /// Configuration or runtime error\n    pub const ERROR: i32 = 3;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","main.rs"],"content":"//! RepoLens - A CLI tool to audit and prepare repositories for open source or enterprise standards\n//!\n//! This is the main entry point for the CLI application.\n\nuse clap::Parser;\nuse tracing_subscriber::{fmt, prelude::*, EnvFilter};\n\nmod actions;\nmod cli;\nmod config;\nmod error;\nmod providers;\nmod rules;\nmod scanner;\nmod utils;\n\nuse error::RepoLensError;\n\n/// Exit codes for the CLI\npub mod exit_codes {\n    /// Success - no issues found\n    pub const SUCCESS: i32 = 0;\n    /// Critical issues found that block release\n    pub const CRITICAL_ISSUES: i32 = 1;\n    /// Warnings found but not blocking\n    pub const WARNINGS: i32 = 2;\n    /// Configuration or runtime error\n    pub const ERROR: i32 = 3;\n}\n\nuse cli::{Cli, Commands};\n\n#[tokio::main]\nasync fn main() -> Result<(), RepoLensError> {\n    // Parse CLI arguments\n    let cli = Cli::parse();\n\n    // Setup logging based on verbosity\n    setup_logging(cli.verbose);\n\n    // Execute the appropriate command\n    let result = match cli.command {\n        Commands::Init(args) => cli::commands::init::execute(args).await,\n        Commands::Plan(args) => cli::commands::plan::execute(args).await,\n        Commands::Apply(args) => cli::commands::apply::execute(args).await,\n        Commands::Report(args) => cli::commands::report::execute(args).await,\n    };\n\n    // Handle exit codes for CI integration\n    match result {\n        Ok(exit_code) => std::process::exit(exit_code),\n        Err(e) => {\n            eprintln!(\"Error: {}\", e);\n            std::process::exit(1);\n        }\n    }\n}\n\nfn setup_logging(verbosity: u8) {\n    let filter = match verbosity {\n        0 => \"warn\",\n        1 => \"info\",\n        2 => \"debug\",\n        _ => \"trace\",\n    };\n\n    tracing_subscriber::registry()\n        .with(fmt::layer())\n        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(filter)))\n        .init();\n}\n","traces":[{"line":34,"address":[681772,681344,681766],"length":1,"stats":{"Line":0}},{"line":36,"address":[807766],"length":1,"stats":{"Line":0}},{"line":39,"address":[808007],"length":1,"stats":{"Line":0}},{"line":42,"address":[808114],"length":1,"stats":{"Line":0}},{"line":43,"address":[629364],"length":1,"stats":{"Line":0}},{"line":44,"address":[629383],"length":1,"stats":{"Line":0}},{"line":45,"address":[629402],"length":1,"stats":{"Line":0}},{"line":46,"address":[629421],"length":1,"stats":{"Line":0}},{"line":50,"address":[681530,681400,681460,681641],"length":1,"stats":{"Line":0}},{"line":51,"address":[809937],"length":1,"stats":{"Line":0}},{"line":52,"address":[809872],"length":1,"stats":{"Line":0}},{"line":53,"address":[810001,809930],"length":1,"stats":{"Line":0}},{"line":54,"address":[810070],"length":1,"stats":{"Line":0}},{"line":59,"address":[681306,681274,680816],"length":1,"stats":{"Line":0}},{"line":60,"address":[680852],"length":1,"stats":{"Line":0}},{"line":61,"address":[680917],"length":1,"stats":{"Line":0}},{"line":62,"address":[680940],"length":1,"stats":{"Line":0}},{"line":63,"address":[680963],"length":1,"stats":{"Line":0}},{"line":64,"address":[680894],"length":1,"stats":{"Line":0}},{"line":67,"address":[681212,681256,680984,681065],"length":1,"stats":{"Line":0}},{"line":68,"address":[681312,681017,681024,681104],"length":1,"stats":{"Line":0}},{"line":69,"address":[681139,681248,681287,681120],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","providers","github.rs"],"content":"//! GitHub provider - Interactions with GitHub API via gh CLI\n\nuse crate::error::{ProviderError, RepoLensError};\nuse serde::Deserialize;\nuse std::process::Command;\n\n/// GitHub provider for repository operations\n#[allow(dead_code)]\npub struct GitHubProvider {\n    repo_owner: String,\n    repo_name: String,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\nstruct RepoInfo {\n    name: String,\n    owner: RepoOwner,\n    visibility: String,\n    #[serde(rename = \"hasIssuesEnabled\")]\n    has_issues_enabled: bool,\n    #[serde(rename = \"hasDiscussionsEnabled\")]\n    has_discussions_enabled: bool,\n    #[serde(rename = \"hasWikiEnabled\")]\n    has_wiki_enabled: bool,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\nstruct RepoOwner {\n    login: String,\n}\n\nimpl GitHubProvider {\n    /// Create a new GitHub provider for the current repository\n    #[allow(dead_code)]\n    pub fn new() -> Result<Self, RepoLensError> {\n        let (owner, name) = Self::get_repo_info()?;\n        Ok(Self {\n            repo_owner: owner,\n            repo_name: name,\n        })\n    }\n\n    /// Check if GitHub CLI is available and authenticated\n    #[allow(dead_code)]\n    pub fn is_available() -> bool {\n        Command::new(\"gh\")\n            .args([\"auth\", \"status\"])\n            .output()\n            .map(|o| o.status.success())\n            .unwrap_or(false)\n    }\n\n    /// Get repository owner and name\n    #[allow(dead_code)]\n    fn get_repo_info() -> Result<(String, String), RepoLensError> {\n        let output = Command::new(\"gh\")\n            .args([\n                \"repo\",\n                \"view\",\n                \"--json\",\n                \"owner,name\",\n                \"-q\",\n                \".owner.login + \\\"/\\\" + .name\",\n            ])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: \"gh repo view\".to_string(),\n                })\n            })?;\n\n        if !output.status.success() {\n            return Err(RepoLensError::Provider(ProviderError::NotAuthenticated));\n        }\n\n        let full_name = String::from_utf8_lossy(&output.stdout).trim().to_string();\n        let parts: Vec<&str> = full_name.split('/').collect();\n\n        if parts.len() != 2 {\n            return Err(RepoLensError::Provider(ProviderError::InvalidRepoName {\n                name: full_name,\n            }));\n        }\n\n        Ok((parts[0].to_string(), parts[1].to_string()))\n    }\n\n    /// Get the full repository name (owner/name)\n    #[allow(dead_code)]\n    pub fn full_name(&self) -> String {\n        format!(\"{}/{}\", self.repo_owner, self.repo_name)\n    }\n\n    /// Get repository visibility\n    #[allow(dead_code)]\n    pub fn get_visibility(&self) -> Result<String, RepoLensError> {\n        let output = Command::new(\"gh\")\n            .args([\"repo\", \"view\", \"--json\", \"visibility\", \"-q\", \".visibility\"])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: \"gh repo view\".to_string(),\n                })\n            })?;\n\n        Ok(String::from_utf8_lossy(&output.stdout)\n            .trim()\n            .to_lowercase())\n    }\n\n    /// Check if the repository is public\n    #[allow(dead_code)]\n    pub fn is_public(&self) -> Result<bool, RepoLensError> {\n        Ok(self.get_visibility()? == \"public\")\n    }\n\n    /// Get list of repository secrets (names only)\n    #[allow(dead_code)]\n    pub fn list_secrets(&self) -> Result<Vec<String>, RepoLensError> {\n        let output = Command::new(\"gh\")\n            .args([\"secret\", \"list\", \"--json\", \"name\", \"-q\", \".[].name\"])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: \"gh secret list\".to_string(),\n                })\n            })?;\n\n        if !output.status.success() {\n            return Ok(Vec::new());\n        }\n\n        let output_str = String::from_utf8_lossy(&output.stdout);\n        Ok(output_str.lines().map(|s| s.to_string()).collect())\n    }\n\n    /// Get list of repository variables\n    #[allow(dead_code)]\n    pub fn list_variables(&self) -> Result<Vec<String>, RepoLensError> {\n        let output = Command::new(\"gh\")\n            .args([\"variable\", \"list\", \"--json\", \"name\", \"-q\", \".[].name\"])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: \"gh variable list\".to_string(),\n                })\n            })?;\n\n        if !output.status.success() {\n            return Ok(Vec::new());\n        }\n\n        let output_str = String::from_utf8_lossy(&output.stdout);\n        Ok(output_str.lines().map(|s| s.to_string()).collect())\n    }\n\n    /// Get branch protection status\n    #[allow(dead_code)]\n    pub fn get_branch_protection(\n        &self,\n        branch: &str,\n    ) -> Result<Option<BranchProtection>, RepoLensError> {\n        let output = Command::new(\"gh\")\n            .args([\n                \"api\",\n                &format!(\"repos/{}/branches/{}/protection\", self.full_name(), branch),\n            ])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: format!(\n                        \"gh api repos/{}/branches/{}/protection\",\n                        self.full_name(),\n                        branch\n                    ),\n                })\n            })?;\n\n        if !output.status.success() {\n            // 404 means no protection\n            return Ok(None);\n        }\n\n        let protection: BranchProtection = serde_json::from_slice(&output.stdout)?;\n\n        Ok(Some(protection))\n    }\n}\n\n/// Branch protection settings from GitHub API\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct BranchProtection {\n    #[serde(rename = \"required_status_checks\")]\n    pub required_status_checks: Option<StatusChecks>,\n\n    #[serde(rename = \"enforce_admins\")]\n    pub enforce_admins: Option<EnforceAdmins>,\n\n    #[serde(rename = \"required_pull_request_reviews\")]\n    pub required_pull_request_reviews: Option<PullRequestReviews>,\n\n    #[serde(rename = \"required_linear_history\")]\n    pub required_linear_history: Option<RequiredLinearHistory>,\n\n    #[serde(rename = \"allow_force_pushes\")]\n    pub allow_force_pushes: Option<AllowForcePushes>,\n\n    #[serde(rename = \"allow_deletions\")]\n    pub allow_deletions: Option<AllowDeletions>,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct StatusChecks {\n    pub strict: bool,\n    pub contexts: Vec<String>,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct EnforceAdmins {\n    pub enabled: bool,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct PullRequestReviews {\n    #[serde(rename = \"required_approving_review_count\")]\n    pub required_approving_review_count: u32,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct RequiredLinearHistory {\n    pub enabled: bool,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct AllowForcePushes {\n    pub enabled: bool,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct AllowDeletions {\n    pub enabled: bool,\n}\n","traces":[{"line":37,"address":[323232],"length":1,"stats":{"Line":0}},{"line":38,"address":[1001536],"length":1,"stats":{"Line":0}},{"line":39,"address":[323468],"length":1,"stats":{"Line":0}},{"line":47,"address":[323816,323822,323584],"length":1,"stats":{"Line":0}},{"line":48,"address":[323740,323591,323685],"length":1,"stats":{"Line":0}},{"line":49,"address":[323623],"length":1,"stats":{"Line":0}},{"line":51,"address":[603801,603792],"length":1,"stats":{"Line":0}},{"line":57,"address":[323840,325703,325662],"length":1,"stats":{"Line":0}},{"line":58,"address":[323857,324131,324286,324070],"length":1,"stats":{"Line":0}},{"line":59,"address":[323900],"length":1,"stats":{"Line":0}},{"line":68,"address":[603888,604082,604076],"length":1,"stats":{"Line":0}},{"line":69,"address":[1302901],"length":1,"stats":{"Line":0}},{"line":70,"address":[603906],"length":1,"stats":{"Line":0}},{"line":74,"address":[324498],"length":1,"stats":{"Line":0}},{"line":75,"address":[324536],"length":1,"stats":{"Line":0}},{"line":78,"address":[324723,324666],"length":1,"stats":{"Line":0}},{"line":79,"address":[324947],"length":1,"stats":{"Line":0}},{"line":81,"address":[325025,325098],"length":1,"stats":{"Line":0}},{"line":82,"address":[325187],"length":1,"stats":{"Line":0}},{"line":83,"address":[325147],"length":1,"stats":{"Line":0}},{"line":87,"address":[325351,325104],"length":1,"stats":{"Line":0}},{"line":92,"address":[325744],"length":1,"stats":{"Line":0}},{"line":93,"address":[325773],"length":1,"stats":{"Line":0}},{"line":98,"address":[326876,326870,325936],"length":1,"stats":{"Line":0}},{"line":99,"address":[326227,326166,326382,325961],"length":1,"stats":{"Line":0}},{"line":100,"address":[1004284],"length":1,"stats":{"Line":0}},{"line":102,"address":[604284,604096,604290],"length":1,"stats":{"Line":0}},{"line":103,"address":[604181],"length":1,"stats":{"Line":0}},{"line":104,"address":[604114],"length":1,"stats":{"Line":0}},{"line":108,"address":[326582,326710],"length":1,"stats":{"Line":0}},{"line":115,"address":[327205,326912,327199],"length":1,"stats":{"Line":0}},{"line":116,"address":[326937,327162],"length":1,"stats":{"Line":0}},{"line":121,"address":[327232,328266,328272],"length":1,"stats":{"Line":0}},{"line":122,"address":[327462,327523,327678,327257],"length":1,"stats":{"Line":0}},{"line":123,"address":[327292],"length":1,"stats":{"Line":0}},{"line":125,"address":[604492,604498,604304],"length":1,"stats":{"Line":0}},{"line":126,"address":[604389],"length":1,"stats":{"Line":0}},{"line":127,"address":[604322],"length":1,"stats":{"Line":0}},{"line":131,"address":[327878],"length":1,"stats":{"Line":0}},{"line":132,"address":[327907,327957],"length":1,"stats":{"Line":0}},{"line":135,"address":[327926,328033],"length":1,"stats":{"Line":0}},{"line":136,"address":[1303440,1303493],"length":1,"stats":{"Line":0}},{"line":141,"address":[329344,328304,329338],"length":1,"stats":{"Line":0}},{"line":142,"address":[328329,328534,328595,328750],"length":1,"stats":{"Line":0}},{"line":143,"address":[328364],"length":1,"stats":{"Line":0}},{"line":145,"address":[1303520,1303708,1303714],"length":1,"stats":{"Line":0}},{"line":146,"address":[604677],"length":1,"stats":{"Line":0}},{"line":147,"address":[1303538],"length":1,"stats":{"Line":0}},{"line":151,"address":[328950],"length":1,"stats":{"Line":0}},{"line":152,"address":[328979,329029],"length":1,"stats":{"Line":0}},{"line":155,"address":[328998,329105],"length":1,"stats":{"Line":0}},{"line":156,"address":[1303728,1303781],"length":1,"stats":{"Line":0}},{"line":161,"address":[330733,329376,330727],"length":1,"stats":{"Line":0}},{"line":165,"address":[329416,329946,330128],"length":1,"stats":{"Line":0}},{"line":166,"address":[329887],"length":1,"stats":{"Line":0}},{"line":168,"address":[329454,329505],"length":1,"stats":{"Line":0}},{"line":171,"address":[1304298,1303808,1304292],"length":1,"stats":{"Line":0}},{"line":172,"address":[605258],"length":1,"stats":{"Line":0}},{"line":173,"address":[604972],"length":1,"stats":{"Line":0}},{"line":175,"address":[604911],"length":1,"stats":{"Line":0}},{"line":181,"address":[330391],"length":1,"stats":{"Line":0}},{"line":183,"address":[330425],"length":1,"stats":{"Line":0}},{"line":186,"address":[330522,330722,330463],"length":1,"stats":{"Line":0}},{"line":188,"address":[330650],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":64},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","providers","mod.rs"],"content":"//! Provider module - External service integrations\n\npub mod github;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","custom.rs"],"content":"//! Custom rules category\n//!\n//! Allows users to define custom audit rules via regex patterns in configuration.\n\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::{Finding, Severity};\nuse crate::scanner::Scanner;\nuse regex::Regex;\nuse tracing::debug;\n\n/// Custom rules implementation\npub struct CustomRules;\n\n/// Simple glob matching (supports * and **)\nfn glob_match(pattern: &str, text: &str) -> bool {\n    if pattern.contains(\"**\") {\n        return glob_match_double_star(pattern, text);\n    }\n\n    if pattern.contains('*') {\n        return glob_match_single_star(pattern, text);\n    }\n\n    text == pattern\n}\n\n/// Match pattern with double star (**)\nfn glob_match_double_star(pattern: &str, text: &str) -> bool {\n    let parts: Vec<&str> = pattern.split(\"**\").collect();\n\n    if parts.len() == 3 && parts[0].is_empty() && parts[2].is_empty() {\n        let middle = parts[1].trim_matches('/');\n        return text.contains(&format!(\"/{}\", middle)) || text.starts_with(middle);\n    }\n\n    if parts.len() != 2 {\n        return false;\n    }\n\n    let prefix = parts[0].trim_end_matches('/');\n    let suffix_raw = parts[1];\n    let suffix = suffix_raw.trim_start_matches('/');\n\n    if !prefix.is_empty() && !text.starts_with(prefix) {\n        return false;\n    }\n\n    if suffix.is_empty() {\n        return true;\n    }\n\n    if suffix.starts_with('*') {\n        let suffix_pattern = suffix.trim_start_matches('*');\n        return text.ends_with(suffix_pattern);\n    }\n\n    if prefix.is_empty() {\n        if suffix_raw.starts_with('/') {\n            let pattern_to_find = format!(\"/{}\", suffix);\n            if text.contains(&pattern_to_find) {\n                return true;\n            }\n            if text.starts_with(suffix) {\n                return true;\n            }\n            return false;\n        }\n        return text.contains(suffix);\n    }\n\n    if let Some(after_prefix) = text.strip_prefix(prefix) {\n        return after_prefix.contains(suffix) || after_prefix.ends_with(suffix);\n    }\n\n    text.ends_with(suffix) || text.contains(suffix)\n}\n\n/// Match pattern with single star (*)\nfn glob_match_single_star(pattern: &str, text: &str) -> bool {\n    let parts: Vec<&str> = pattern.split('*').collect();\n    let mut pos = 0;\n\n    for (i, part) in parts.iter().enumerate() {\n        if part.is_empty() {\n            continue;\n        }\n\n        if let Some(found_pos) = text[pos..].find(part) {\n            if i == 0 && found_pos != 0 {\n                return false;\n            }\n            pos += found_pos + part.len();\n        } else {\n            return false;\n        }\n    }\n\n    if let Some(last_part) = parts.last() {\n        if !last_part.is_empty() {\n            return text.ends_with(last_part);\n        }\n    }\n\n    true\n}\n\n#[async_trait::async_trait]\nimpl RuleCategory for CustomRules {\n    fn name(&self) -> &'static str {\n        \"custom\"\n    }\n\n    async fn run(\n        &self,\n        scanner: &Scanner,\n        config: &Config,\n    ) -> Result<Vec<Finding>, RepoLensError> {\n        let mut findings = Vec::new();\n\n        // Skip if no custom rules defined\n        if config.custom_rules.rules.is_empty() {\n            debug!(\"No custom rules defined\");\n            return Ok(findings);\n        }\n\n        // Get all files from the scanner\n        let all_files = scanner.all_files();\n\n        for (rule_id, rule) in &config.custom_rules.rules {\n            debug!(rule_id = %rule_id, pattern = %rule.pattern, \"Processing custom rule\");\n\n            // Compile the regex pattern\n            let regex = match Regex::new(&rule.pattern) {\n                Ok(r) => r,\n                Err(e) => {\n                    debug!(\n                        rule_id = %rule_id,\n                        error = %e,\n                        \"Invalid regex pattern in custom rule\"\n                    );\n                    continue;\n                }\n            };\n\n            // Determine severity\n            let severity = match rule.severity.to_lowercase().as_str() {\n                \"critical\" => Severity::Critical,\n                \"warning\" => Severity::Warning,\n                \"info\" => Severity::Info,\n                _ => Severity::Warning,\n            };\n\n            // Filter files based on glob patterns\n            let files_to_check: Vec<_> = if rule.files.is_empty() {\n                all_files.iter().collect()\n            } else {\n                all_files\n                    .iter()\n                    .filter(|file| {\n                        rule.files\n                            .iter()\n                            .any(|pattern| glob_match(pattern, &file.path))\n                    })\n                    .collect()\n            };\n\n            // Check each file\n            for file_info in files_to_check {\n                let file_path = &file_info.path;\n\n                // Read file content\n                let content = match scanner.read_file(file_path) {\n                    Ok(c) => c,\n                    Err(_) => continue, // Skip files that can't be read\n                };\n\n                let pattern_found = regex.is_match(&content);\n\n                // Handle inverted matching\n                let should_report = if rule.invert {\n                    !pattern_found // Report if pattern NOT found\n                } else {\n                    pattern_found // Report if pattern found\n                };\n\n                if should_report {\n                    // Find line numbers for matches (only for non-inverted)\n                    let locations: Vec<(usize, String)> = if !rule.invert {\n                        content\n                            .lines()\n                            .enumerate()\n                            .filter(|(_, line)| regex.is_match(line))\n                            .map(|(i, line)| (i + 1, line.to_string()))\n                            .take(5) // Limit to first 5 matches\n                            .collect()\n                    } else {\n                        vec![]\n                    };\n\n                    let message = rule.message.clone().unwrap_or_else(|| {\n                        if rule.invert {\n                            format!(\"Required pattern '{}' not found\", rule.pattern)\n                        } else {\n                            format!(\"Pattern '{}' matched\", rule.pattern)\n                        }\n                    });\n\n                    let description = rule.description.clone().unwrap_or_else(|| {\n                        if locations.is_empty() {\n                            format!(\"Custom rule '{}' triggered in {}\", rule_id, file_path)\n                        } else {\n                            let lines: Vec<String> = locations\n                                .iter()\n                                .map(|(line_num, _)| format!(\"line {}\", line_num))\n                                .collect();\n                            format!(\n                                \"Custom rule '{}' triggered in {} at {}\",\n                                rule_id,\n                                file_path,\n                                lines.join(\", \")\n                            )\n                        }\n                    });\n\n                    let location = if let Some((line_num, _)) = locations.first() {\n                        Some(format!(\"{}:{}\", file_path, line_num))\n                    } else {\n                        Some(file_path.to_string())\n                    };\n\n                    findings.push(Finding {\n                        rule_id: format!(\"custom/{}\", rule_id),\n                        category: \"custom\".to_string(),\n                        severity,\n                        message,\n                        location,\n                        description: Some(description),\n                        remediation: rule.remediation.clone(),\n                    });\n                }\n            }\n        }\n\n        Ok(findings)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::{CustomRule, CustomRulesConfig};\n    use std::collections::HashMap;\n    use std::fs;\n    use tempfile::TempDir;\n\n    fn create_test_config_with_rule(rule_id: &str, rule: CustomRule) -> Config {\n        let mut rules = HashMap::new();\n        rules.insert(rule_id.to_string(), rule);\n        let mut config = Config::default();\n        config.custom_rules = CustomRulesConfig { rules };\n        config\n    }\n\n    #[tokio::test]\n    async fn test_custom_rule_pattern_match() {\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"test.rs\");\n        fs::write(&test_file, \"// TODO: fix this later\\nfn main() {}\").unwrap();\n\n        let rule = CustomRule {\n            pattern: \"TODO\".to_string(),\n            severity: \"warning\".to_string(),\n            files: vec![\"**/*.rs\".to_string()],\n            message: Some(\"TODO comment found\".to_string()),\n            description: None,\n            remediation: Some(\"Address or remove the TODO\".to_string()),\n            invert: false,\n        };\n\n        let config = create_test_config_with_rule(\"no-todo\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(&scanner, &config).await.unwrap();\n\n        assert_eq!(findings.len(), 1);\n        assert_eq!(findings[0].rule_id, \"custom/no-todo\");\n        assert_eq!(findings[0].severity, Severity::Warning);\n        assert!(findings[0].message.contains(\"TODO\"));\n    }\n\n    #[tokio::test]\n    async fn test_custom_rule_no_match() {\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"test.rs\");\n        fs::write(&test_file, \"fn main() { println!(\\\"Hello\\\"); }\").unwrap();\n\n        let rule = CustomRule {\n            pattern: \"TODO\".to_string(),\n            severity: \"warning\".to_string(),\n            files: vec![\"**/*.rs\".to_string()],\n            message: None,\n            description: None,\n            remediation: None,\n            invert: false,\n        };\n\n        let config = create_test_config_with_rule(\"no-todo\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(&scanner, &config).await.unwrap();\n\n        assert!(findings.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_custom_rule_inverted_match() {\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"lib.rs\");\n        fs::write(&test_file, \"fn helper() {}\").unwrap();\n\n        let rule = CustomRule {\n            pattern: r\"^//!\".to_string(), // Module doc comment\n            severity: \"info\".to_string(),\n            files: vec![\"**/lib.rs\".to_string()],\n            message: Some(\"Missing module documentation\".to_string()),\n            description: None,\n            remediation: Some(\"Add module-level documentation\".to_string()),\n            invert: true, // Fail when NOT found\n        };\n\n        let config = create_test_config_with_rule(\"require-doc\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(&scanner, &config).await.unwrap();\n\n        assert_eq!(findings.len(), 1);\n        assert_eq!(findings[0].rule_id, \"custom/require-doc\");\n        assert!(findings[0].message.contains(\"Missing module documentation\"));\n    }\n\n    #[tokio::test]\n    async fn test_custom_rule_file_filter() {\n        let temp_dir = TempDir::new().unwrap();\n        fs::write(temp_dir.path().join(\"test.rs\"), \"TODO: fix\").unwrap();\n        fs::write(temp_dir.path().join(\"test.js\"), \"// TODO: fix\").unwrap();\n\n        let rule = CustomRule {\n            pattern: \"TODO\".to_string(),\n            severity: \"warning\".to_string(),\n            files: vec![\"**/*.rs\".to_string()], // Only Rust files\n            message: None,\n            description: None,\n            remediation: None,\n            invert: false,\n        };\n\n        let config = create_test_config_with_rule(\"no-todo\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(&scanner, &config).await.unwrap();\n\n        // Should only find in .rs file, not .js\n        assert_eq!(findings.len(), 1);\n        assert!(findings[0].location.as_ref().unwrap().ends_with(\".rs\") \n            || findings[0].location.as_ref().unwrap().contains(\".rs:\"));\n    }\n\n    #[tokio::test]\n    async fn test_custom_rule_severity_levels() {\n        let temp_dir = TempDir::new().unwrap();\n        fs::write(temp_dir.path().join(\"test.rs\"), \"FIXME: urgent\").unwrap();\n\n        let rule = CustomRule {\n            pattern: \"FIXME\".to_string(),\n            severity: \"critical\".to_string(),\n            files: vec![],\n            message: None,\n            description: None,\n            remediation: None,\n            invert: false,\n        };\n\n        let config = create_test_config_with_rule(\"no-fixme\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(&scanner, &config).await.unwrap();\n\n        assert_eq!(findings.len(), 1);\n        assert_eq!(findings[0].severity, Severity::Critical);\n    }\n\n    #[tokio::test]\n    async fn test_no_custom_rules_returns_empty() {\n        let temp_dir = TempDir::new().unwrap();\n        fs::write(temp_dir.path().join(\"test.rs\"), \"fn main() {}\").unwrap();\n\n        let config = Config::default(); // No custom rules\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(&scanner, &config).await.unwrap();\n\n        assert!(findings.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_invalid_regex_is_skipped() {\n        let temp_dir = TempDir::new().unwrap();\n        fs::write(temp_dir.path().join(\"test.rs\"), \"test content\").unwrap();\n\n        let rule = CustomRule {\n            pattern: \"[invalid regex\".to_string(), // Invalid regex\n            severity: \"warning\".to_string(),\n            files: vec![],\n            message: None,\n            description: None,\n            remediation: None,\n            invert: false,\n        };\n\n        let config = create_test_config_with_rule(\"bad-rule\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        // Should not panic, just skip the invalid rule\n        let findings = custom_rules.run(&scanner, &config).await.unwrap();\n        assert!(findings.is_empty());\n    }\n}\n","traces":[{"line":17,"address":[1219184],"length":1,"stats":{"Line":6}},{"line":18,"address":[950839],"length":1,"stats":{"Line":5}},{"line":19,"address":[950896],"length":1,"stats":{"Line":2}},{"line":22,"address":[950870],"length":1,"stats":{"Line":0}},{"line":23,"address":[950950],"length":1,"stats":{"Line":0}},{"line":26,"address":[950928],"length":1,"stats":{"Line":0}},{"line":30,"address":[951867,953329,950992],"length":1,"stats":{"Line":6}},{"line":31,"address":[951056],"length":1,"stats":{"Line":2}},{"line":33,"address":[1219499,1219652,1219570],"length":1,"stats":{"Line":8}},{"line":34,"address":[951398],"length":1,"stats":{"Line":0}},{"line":35,"address":[1219884,1220229],"length":1,"stats":{"Line":0}},{"line":38,"address":[951242,951881],"length":1,"stats":{"Line":8}},{"line":39,"address":[951925],"length":1,"stats":{"Line":0}},{"line":42,"address":[951943,951887],"length":1,"stats":{"Line":8}},{"line":43,"address":[1220402],"length":1,"stats":{"Line":5}},{"line":44,"address":[952115],"length":1,"stats":{"Line":3}},{"line":46,"address":[952261,952168],"length":1,"stats":{"Line":5}},{"line":47,"address":[952267],"length":1,"stats":{"Line":0}},{"line":50,"address":[952230,952284],"length":1,"stats":{"Line":8}},{"line":51,"address":[952326],"length":1,"stats":{"Line":0}},{"line":54,"address":[1220715,1220662],"length":1,"stats":{"Line":7}},{"line":55,"address":[952370,953280],"length":1,"stats":{"Line":6}},{"line":56,"address":[953296],"length":1,"stats":{"Line":3}},{"line":59,"address":[952359,952415],"length":1,"stats":{"Line":4}},{"line":60,"address":[952875,952478],"length":1,"stats":{"Line":4}},{"line":61,"address":[952973,952928],"length":1,"stats":{"Line":4}},{"line":62,"address":[1221469,1221528],"length":1,"stats":{"Line":4}},{"line":63,"address":[953209],"length":1,"stats":{"Line":0}},{"line":65,"address":[953223,953178],"length":1,"stats":{"Line":4}},{"line":70,"address":[952959,952897],"length":1,"stats":{"Line":0}},{"line":73,"address":[1220819,1220883],"length":1,"stats":{"Line":0}},{"line":74,"address":[952682,952600],"length":1,"stats":{"Line":0}},{"line":77,"address":[952764,952647],"length":1,"stats":{"Line":0}},{"line":81,"address":[954461,954467,953344],"length":1,"stats":{"Line":0}},{"line":82,"address":[953408],"length":1,"stats":{"Line":0}},{"line":83,"address":[953479],"length":1,"stats":{"Line":0}},{"line":85,"address":[954438,953491,953578],"length":1,"stats":{"Line":0}},{"line":86,"address":[953855,954130],"length":1,"stats":{"Line":0}},{"line":90,"address":[954156],"length":1,"stats":{"Line":0}},{"line":91,"address":[954290,954316],"length":1,"stats":{"Line":0}},{"line":92,"address":[954346],"length":1,"stats":{"Line":0}},{"line":94,"address":[954327,954369,954443],"length":1,"stats":{"Line":0}},{"line":96,"address":[954298],"length":1,"stats":{"Line":0}},{"line":100,"address":[953879],"length":1,"stats":{"Line":0}},{"line":101,"address":[953995,954041],"length":1,"stats":{"Line":0}},{"line":102,"address":[954068],"length":1,"stats":{"Line":0}},{"line":106,"address":[954013],"length":1,"stats":{"Line":0}},{"line":111,"address":[954480],"length":1,"stats":{"Line":2}},{"line":115,"address":[954531],"length":1,"stats":{"Line":24}},{"line":120,"address":[375375],"length":1,"stats":{"Line":11}},{"line":123,"address":[375462,375382],"length":1,"stats":{"Line":14}},{"line":124,"address":[375503,381359,381023],"length":1,"stats":{"Line":4}},{"line":125,"address":[381246],"length":1,"stats":{"Line":2}},{"line":129,"address":[375468,375550],"length":1,"stats":{"Line":11}},{"line":131,"address":[375588],"length":1,"stats":{"Line":2}},{"line":132,"address":[923270,923746,923447],"length":1,"stats":{"Line":8}},{"line":135,"address":[376232,376709],"length":1,"stats":{"Line":10}},{"line":136,"address":[924318],"length":1,"stats":{"Line":7}},{"line":137,"address":[376759],"length":1,"stats":{"Line":2}},{"line":138,"address":[380605,376791,380360],"length":1,"stats":{"Line":4}},{"line":148,"address":[377091,376894,376981],"length":1,"stats":{"Line":12}},{"line":149,"address":[377113,377194],"length":1,"stats":{"Line":8}},{"line":150,"address":[924699,924656,924747],"length":1,"stats":{"Line":11}},{"line":151,"address":[924780,924764,924721],"length":1,"stats":{"Line":6}},{"line":152,"address":[377282],"length":1,"stats":{"Line":0}},{"line":156,"address":[377327],"length":1,"stats":{"Line":2}},{"line":157,"address":[925071,924905],"length":1,"stats":{"Line":4}},{"line":159,"address":[924866,924960],"length":1,"stats":{"Line":9}},{"line":161,"address":[381616],"length":1,"stats":{"Line":6}},{"line":162,"address":[381634,381676],"length":1,"stats":{"Line":10}},{"line":164,"address":[381696,381673,381726],"length":1,"stats":{"Line":17}},{"line":170,"address":[925215,925080,924992],"length":1,"stats":{"Line":6}},{"line":171,"address":[925270],"length":1,"stats":{"Line":2}},{"line":174,"address":[377910,377790],"length":1,"stats":{"Line":4}},{"line":175,"address":[925488],"length":1,"stats":{"Line":2}},{"line":179,"address":[925648,925739],"length":1,"stats":{"Line":6}},{"line":182,"address":[925803,925778],"length":1,"stats":{"Line":8}},{"line":183,"address":[378324],"length":1,"stats":{"Line":2}},{"line":185,"address":[378306],"length":1,"stats":{"Line":4}},{"line":188,"address":[925823],"length":1,"stats":{"Line":2}},{"line":190,"address":[925863],"length":1,"stats":{"Line":3}},{"line":191,"address":[925949,925880],"length":1,"stats":{"Line":6}},{"line":194,"address":[929280,929296],"length":1,"stats":{"Line":5}},{"line":195,"address":[381856,381878],"length":1,"stats":{"Line":9}},{"line":199,"address":[378415,378633],"length":1,"stats":{"Line":4}},{"line":202,"address":[926098,926183,929504],"length":1,"stats":{"Line":14}},{"line":203,"address":[929525],"length":1,"stats":{"Line":3}},{"line":204,"address":[382172],"length":1,"stats":{"Line":0}},{"line":206,"address":[382051],"length":1,"stats":{"Line":2}},{"line":210,"address":[929776,926309,926229,930523],"length":1,"stats":{"Line":7}},{"line":211,"address":[382310],"length":1,"stats":{"Line":5}},{"line":212,"address":[929897],"length":1,"stats":{"Line":2}},{"line":214,"address":[382327],"length":1,"stats":{"Line":2}},{"line":216,"address":[383089,383056],"length":1,"stats":{"Line":6}},{"line":218,"address":[382619,382713,382378],"length":1,"stats":{"Line":8}},{"line":222,"address":[930130],"length":1,"stats":{"Line":4}},{"line":227,"address":[379003,378915,379420],"length":1,"stats":{"Line":7}},{"line":228,"address":[379138,379081],"length":1,"stats":{"Line":9}},{"line":230,"address":[379108,379364],"length":1,"stats":{"Line":4}},{"line":233,"address":[379880],"length":1,"stats":{"Line":4}},{"line":234,"address":[379337,379463],"length":1,"stats":{"Line":6}},{"line":235,"address":[927051],"length":1,"stats":{"Line":3}},{"line":236,"address":[379646],"length":1,"stats":{"Line":4}},{"line":237,"address":[379657],"length":1,"stats":{"Line":3}},{"line":238,"address":[379697],"length":1,"stats":{"Line":7}},{"line":239,"address":[379737],"length":1,"stats":{"Line":4}},{"line":240,"address":[379809],"length":1,"stats":{"Line":4}},{"line":246,"address":[375813],"length":1,"stats":{"Line":2}}],"covered":79,"coverable":108},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","docs.rs"],"content":"//! Documentation rules\n//!\n//! This module provides rules for checking repository documentation, including:\n//! - README files and their quality\n//! - LICENSE files\n//! - CONTRIBUTING guidelines\n//! - CODE_OF_CONDUCT files\n//! - SECURITY policy files\n\nuse crate::error::RepoLensError;\n\nuse crate::config::Config;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for checking repository documentation\npub struct DocsRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for DocsRules {\n    /// Get the category name\n    fn name(&self) -> &'static str {\n        \"docs\"\n    }\n\n    /// Run all documentation-related rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for documentation issues\n    async fn run(&self, scanner: &Scanner, config: &Config) -> Result<Vec<Finding>, RepoLensError> {\n        let mut findings = Vec::new();\n\n        // Check README\n        if config.is_rule_enabled(\"docs/readme\") {\n            findings.extend(check_readme(scanner).await?);\n        }\n\n        // Check LICENSE\n        if config.is_rule_enabled(\"docs/license\") {\n            findings.extend(check_license(scanner, config).await?);\n        }\n\n        // Check CONTRIBUTING\n        if config.is_rule_enabled(\"docs/contributing\") {\n            findings.extend(check_contributing(scanner).await?);\n        }\n\n        // Check CODE_OF_CONDUCT\n        if config.is_rule_enabled(\"docs/code-of-conduct\") {\n            findings.extend(check_code_of_conduct(scanner).await?);\n        }\n\n        // Check SECURITY\n        if config.is_rule_enabled(\"docs/security\") {\n            findings.extend(check_security(scanner).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for README file and assess its quality\n///\n/// Verifies README existence and checks for recommended sections like\n/// installation, usage, and license information.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for README issues\nasync fn check_readme(scanner: &Scanner) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    let readme_files = [\"README.md\", \"README\", \"README.txt\", \"README.rst\"];\n    let has_readme = readme_files.iter().any(|f| scanner.file_exists(f));\n\n    if !has_readme {\n        findings.push(\n            Finding::new(\n                \"DOC001\",\n                \"docs\",\n                Severity::Warning,\n                \"README file is missing\",\n            )\n            .with_description(\n                \"A README file is essential for explaining what the project does and how to use it.\"\n            )\n            .with_remediation(\n                \"Create a README.md file with project description, installation instructions, and usage examples.\"\n            )\n        );\n        return Ok(findings);\n    }\n\n    // Check README quality\n    if let Ok(content) = scanner.read_file(\"README.md\") {\n        let line_count = content.lines().count();\n\n        if line_count < 10 {\n            findings.push(\n                Finding::new(\n                    \"DOC002\",\n                    \"docs\",\n                    Severity::Warning,\n                    format!(\"README is too short ({} lines)\", line_count),\n                )\n                .with_description(\n                    \"A comprehensive README should include sections for description, installation, usage, and contribution guidelines.\"\n                )\n            );\n        }\n\n        // Check for recommended sections\n        let sections = [\n            (\"installation\", \"Installation instructions\"),\n            (\"usage\", \"Usage examples\"),\n            (\"license\", \"License information\"),\n        ];\n\n        for (keyword, description) in sections {\n            if !content.to_lowercase().contains(keyword) {\n                findings.push(Finding::new(\n                    \"DOC003\",\n                    \"docs\",\n                    Severity::Info,\n                    format!(\"README missing section: {}\", description),\n                ));\n            }\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for LICENSE file\n///\n/// Verifies that a LICENSE file exists. For enterprise preset, LICENSE is optional.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `config` - The configuration (used to check preset)\n///\n/// # Returns\n///\n/// A vector of findings for LICENSE issues\nasync fn check_license(scanner: &Scanner, config: &Config) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    let license_files = [\"LICENSE\", \"LICENSE.md\", \"LICENSE.txt\", \"COPYING\"];\n    let has_license = license_files.iter().any(|f| scanner.file_exists(f));\n\n    // For enterprise preset, LICENSE is optional\n    if config.preset == \"enterprise\" && !has_license {\n        return Ok(findings);\n    }\n\n    if !has_license {\n        findings.push(\n            Finding::new(\n                \"DOC004\",\n                \"docs\",\n                Severity::Critical,\n                \"LICENSE file is missing\",\n            )\n            .with_description(\n                \"A LICENSE file is required for open source projects to define how others can use your code.\"\n            )\n            .with_remediation(\n                \"Add a LICENSE file with an appropriate open source license (MIT, Apache-2.0, GPL-3.0, etc.).\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check for CONTRIBUTING file\n///\n/// Verifies that a CONTRIBUTING file exists to guide contributors.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for CONTRIBUTING issues\nasync fn check_contributing(scanner: &Scanner) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    let contributing_files = [\"CONTRIBUTING.md\", \"CONTRIBUTING\", \".github/CONTRIBUTING.md\"];\n    let has_contributing = contributing_files.iter().any(|f| scanner.file_exists(f));\n\n    if !has_contributing {\n        findings.push(\n            Finding::new(\n                \"DOC005\",\n                \"docs\",\n                Severity::Warning,\n                \"CONTRIBUTING file is missing\",\n            )\n            .with_description(\n                \"A CONTRIBUTING file helps potential contributors understand how to participate in your project.\"\n            )\n            .with_remediation(\n                \"Create a CONTRIBUTING.md file with contribution guidelines, code style, and pull request process.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check for CODE_OF_CONDUCT file\n///\n/// Verifies that a CODE_OF_CONDUCT file exists to establish community standards.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for CODE_OF_CONDUCT issues\nasync fn check_code_of_conduct(scanner: &Scanner) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    let coc_files = [\n        \"CODE_OF_CONDUCT.md\",\n        \"CODE_OF_CONDUCT\",\n        \".github/CODE_OF_CONDUCT.md\",\n    ];\n    let has_coc = coc_files.iter().any(|f| scanner.file_exists(f));\n\n    if !has_coc {\n        findings.push(\n            Finding::new(\n                \"DOC006\",\n                \"docs\",\n                Severity::Warning,\n                \"CODE_OF_CONDUCT file is missing\",\n            )\n            .with_description(\n                \"A Code of Conduct establishes expectations for behavior and helps create a welcoming community.\"\n            )\n            .with_remediation(\n                \"Add a CODE_OF_CONDUCT.md file. Consider using the Contributor Covenant as a starting point.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check for SECURITY policy file\n///\n/// Verifies that a SECURITY.md file exists for reporting vulnerabilities.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for SECURITY policy issues\nasync fn check_security(scanner: &Scanner) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    let security_files = [\"SECURITY.md\", \".github/SECURITY.md\"];\n    let has_security = security_files.iter().any(|f| scanner.file_exists(f));\n\n    if !has_security {\n        findings.push(\n            Finding::new(\n                \"DOC007\",\n                \"docs\",\n                Severity::Warning,\n                \"SECURITY policy file is missing\",\n            )\n            .with_description(\n                \"A SECURITY.md file tells users how to report security vulnerabilities responsibly.\"\n            )\n            .with_remediation(\n                \"Create a SECURITY.md file with instructions for reporting security issues.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::Config;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_readme_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_readme(&scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC001\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_readme_too_short() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let readme = root.join(\"README.md\");\n\n        fs::write(&readme, \"# Test\\n\\nShort.\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_readme(&scanner).await.unwrap();\n\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC002\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_readme_missing_sections() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let readme = root.join(\"README.md\");\n\n        fs::write(&readme, \"# Project\\n\\nDescription here.\\n\\nMore content.\\n\\nEven more.\\n\\nAnd more.\\n\\nAnd more.\\n\\nAnd more.\\n\\nAnd more.\\n\\nAnd more.\\n\\nAnd more.\\n\\nAnd more.\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_readme(&scanner).await.unwrap();\n\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC003\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_license_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config::default();\n        let findings = check_license(&scanner, &config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC004\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_license_enterprise_optional() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config {\n            preset: \"enterprise\".to_string(),\n            ..Default::default()\n        };\n        let findings = check_license(&scanner, &config).await.unwrap();\n\n        assert!(findings.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_check_contributing_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_contributing(&scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC005\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_code_of_conduct_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_code_of_conduct(&scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC006\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_security_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_security(&scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC007\"));\n    }\n}\n","traces":[{"line":23,"address":[349328],"length":1,"stats":{"Line":2}},{"line":37,"address":[523492,523228,523408,524368,526026,523104,523139,523752],"length":1,"stats":{"Line":18}},{"line":38,"address":[523508],"length":1,"stats":{"Line":3}},{"line":41,"address":[523524,523598],"length":1,"stats":{"Line":6}},{"line":42,"address":[284114,284031],"length":1,"stats":{"Line":3}},{"line":46,"address":[523604,524177],"length":1,"stats":{"Line":6}},{"line":47,"address":[615870,616012],"length":1,"stats":{"Line":3}},{"line":51,"address":[524183,524773],"length":1,"stats":{"Line":6}},{"line":52,"address":[616052,615888],"length":1,"stats":{"Line":2}},{"line":56,"address":[524779,525331],"length":1,"stats":{"Line":7}},{"line":57,"address":[525490,525372,523309,526144],"length":1,"stats":{"Line":3}},{"line":61,"address":[525889,525337],"length":1,"stats":{"Line":6}},{"line":62,"address":[29583,32287,32405],"length":1,"stats":{"Line":2}},{"line":65,"address":[525899],"length":1,"stats":{"Line":4}},{"line":81,"address":[1504360,1504352],"length":1,"stats":{"Line":12}},{"line":82,"address":[517085],"length":1,"stats":{"Line":2}},{"line":84,"address":[517161],"length":1,"stats":{"Line":4}},{"line":85,"address":[517269,519728,517361,519745],"length":1,"stats":{"Line":11}},{"line":87,"address":[517412],"length":1,"stats":{"Line":3}},{"line":88,"address":[517602],"length":1,"stats":{"Line":2}},{"line":89,"address":[517532,517424],"length":1,"stats":{"Line":4}},{"line":92,"address":[517416],"length":1,"stats":{"Line":2}},{"line":102,"address":[517632],"length":1,"stats":{"Line":2}},{"line":106,"address":[517502,517829,517920],"length":1,"stats":{"Line":7}},{"line":107,"address":[518047,517968],"length":1,"stats":{"Line":6}},{"line":109,"address":[518091],"length":1,"stats":{"Line":4}},{"line":110,"address":[518719],"length":1,"stats":{"Line":2}},{"line":111,"address":[518621],"length":1,"stats":{"Line":2}},{"line":114,"address":[518486],"length":1,"stats":{"Line":2}},{"line":115,"address":[518494],"length":1,"stats":{"Line":2}},{"line":124,"address":[518268],"length":1,"stats":{"Line":2}},{"line":125,"address":[518106],"length":1,"stats":{"Line":2}},{"line":126,"address":[518160],"length":1,"stats":{"Line":2}},{"line":127,"address":[518214],"length":1,"stats":{"Line":2}},{"line":130,"address":[518843,518364,518754],"length":1,"stats":{"Line":6}},{"line":131,"address":[519086,518956],"length":1,"stats":{"Line":5}},{"line":132,"address":[25651],"length":1,"stats":{"Line":3}},{"line":135,"address":[25516],"length":1,"stats":{"Line":3}},{"line":136,"address":[25524],"length":1,"stats":{"Line":3}},{"line":142,"address":[25814],"length":1,"stats":{"Line":3}},{"line":157,"address":[519776,520682,519895,519806,519917],"length":1,"stats":{"Line":13}},{"line":158,"address":[519888],"length":1,"stats":{"Line":3}},{"line":160,"address":[26217],"length":1,"stats":{"Line":3}},{"line":161,"address":[520146,520720,520063,520737],"length":1,"stats":{"Line":10}},{"line":164,"address":[26504,26455],"length":1,"stats":{"Line":5}},{"line":165,"address":[520254],"length":1,"stats":{"Line":2}},{"line":168,"address":[520231],"length":1,"stats":{"Line":2}},{"line":169,"address":[520650],"length":1,"stats":{"Line":2}},{"line":170,"address":[26662,26836],"length":1,"stats":{"Line":4}},{"line":173,"address":[520398],"length":1,"stats":{"Line":2}},{"line":185,"address":[520476],"length":1,"stats":{"Line":2}},{"line":199,"address":[349280,349288],"length":1,"stats":{"Line":8}},{"line":200,"address":[520858],"length":1,"stats":{"Line":2}},{"line":202,"address":[520931],"length":1,"stats":{"Line":2}},{"line":203,"address":[521006,521521,521504,521089],"length":1,"stats":{"Line":8}},{"line":205,"address":[27396],"length":1,"stats":{"Line":2}},{"line":206,"address":[521439],"length":1,"stats":{"Line":2}},{"line":207,"address":[27625,27408],"length":1,"stats":{"Line":4}},{"line":210,"address":[521144],"length":1,"stats":{"Line":2}},{"line":222,"address":[27486],"length":1,"stats":{"Line":2}},{"line":236,"address":[1504416,1504424],"length":1,"stats":{"Line":8}},{"line":237,"address":[521642],"length":1,"stats":{"Line":2}},{"line":239,"address":[27971],"length":1,"stats":{"Line":2}},{"line":244,"address":[522288,522305,521873,521790],"length":1,"stats":{"Line":8}},{"line":246,"address":[28180],"length":1,"stats":{"Line":2}},{"line":247,"address":[522223],"length":1,"stats":{"Line":2}},{"line":248,"address":[521936,522153],"length":1,"stats":{"Line":4}},{"line":251,"address":[521928],"length":1,"stats":{"Line":2}},{"line":263,"address":[522014],"length":1,"stats":{"Line":2}},{"line":277,"address":[28689,29268,28711,28622,28592],"length":1,"stats":{"Line":8}},{"line":278,"address":[522426],"length":1,"stats":{"Line":2}},{"line":280,"address":[522499],"length":1,"stats":{"Line":2}},{"line":281,"address":[523056,523073,522630,522547],"length":1,"stats":{"Line":8}},{"line":283,"address":[522681],"length":1,"stats":{"Line":2}},{"line":284,"address":[522980],"length":1,"stats":{"Line":2}},{"line":285,"address":[522910,522693],"length":1,"stats":{"Line":4}},{"line":288,"address":[522685],"length":1,"stats":{"Line":2}},{"line":300,"address":[522771],"length":1,"stats":{"Line":2}}],"covered":78,"coverable":78},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","files.rs"],"content":"//! File-related rules\n//!\n//! This module provides rules for checking repository files, including:\n//! - Large files that should use Git LFS\n//! - .gitignore configuration and recommended entries\n//! - Temporary files that shouldn't be committed\n\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for checking repository files\npub struct FilesRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for FilesRules {\n    /// Get the category name\n    fn name(&self) -> &'static str {\n        \"files\"\n    }\n\n    /// Run all file-related rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for file-related issues\n    async fn run(&self, scanner: &Scanner, config: &Config) -> Result<Vec<Finding>, RepoLensError> {\n        let mut findings = Vec::new();\n\n        // Check for large files\n        if config.is_rule_enabled(\"files/large\") {\n            findings.extend(check_large_files(scanner).await?);\n        }\n\n        // Check .gitignore\n        if config.is_rule_enabled(\"files/gitignore\") {\n            findings.extend(check_gitignore(scanner).await?);\n        }\n\n        // Check for temporary files\n        if config.is_rule_enabled(\"files/temp\") {\n            findings.extend(check_temp_files(scanner).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for files larger than the recommended threshold\n///\n/// Large files can slow down repository operations and should use Git LFS.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for large files\nasync fn check_large_files(scanner: &Scanner) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    // 10MB threshold\n    const LARGE_FILE_THRESHOLD: u64 = 10 * 1024 * 1024;\n\n    for file in scanner.files_larger_than(LARGE_FILE_THRESHOLD) {\n        let size_mb = file.size as f64 / 1024.0 / 1024.0;\n\n        findings.push(\n            Finding::new(\n                \"FILE001\",\n                \"files\",\n                Severity::Warning,\n                format!(\"Large file detected ({:.1} MB)\", size_mb),\n            )\n            .with_location(&file.path)\n            .with_description(\n                \"Large files can slow down repository operations and increase clone times.\",\n            )\n            .with_remediation(\n                \"Consider using Git LFS (Large File Storage) for binary or large files.\",\n            ),\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check .gitignore file existence and recommended entries\n///\n/// Verifies that .gitignore exists and contains recommended patterns\n/// to prevent committing unwanted files.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for .gitignore issues\nasync fn check_gitignore(scanner: &Scanner) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    // Check if .gitignore exists\n    if !scanner.file_exists(\".gitignore\") {\n        findings.push(\n            Finding::new(\n                \"FILE002\",\n                \"files\",\n                Severity::Warning,\n                \".gitignore file is missing\",\n            )\n            .with_description(\n                \"A .gitignore file helps prevent accidentally committing unwanted files.\",\n            )\n            .with_remediation(\n                \"Create a .gitignore file with appropriate patterns for your project type.\",\n            ),\n        );\n        return Ok(findings);\n    }\n\n    // Check for recommended entries\n    let gitignore_content = scanner.read_file(\".gitignore\").unwrap_or_else(|e| {\n        tracing::warn!(\"Failed to read .gitignore: {}\", e);\n        String::new()\n    });\n    let recommended_entries = [\n        (\".env\", \"Environment files\"),\n        (\"*.key\", \"Private keys\"),\n        (\"*.pem\", \"Certificates\"),\n        (\"node_modules\", \"Node.js dependencies\"),\n        (\".DS_Store\", \"macOS metadata\"),\n    ];\n\n    for (pattern, description) in recommended_entries {\n        if !gitignore_content.contains(pattern) {\n            findings.push(\n                Finding::new(\n                    \"FILE003\",\n                    \"files\",\n                    Severity::Info,\n                    format!(\".gitignore missing recommended entry: {}\", pattern),\n                )\n                .with_description(format!(\n                    \"Adding '{}' to .gitignore helps prevent committing {}.\",\n                    pattern,\n                    description.to_lowercase()\n                )),\n            );\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for temporary files that shouldn't be committed\n///\n/// Detects common temporary file patterns like .log, .tmp, .swp, etc.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for temporary files\nasync fn check_temp_files(scanner: &Scanner) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    let temp_patterns = [\"*.log\", \"*.tmp\", \"*.temp\", \"*~\", \"*.swp\", \"*.swo\", \"*.bak\"];\n\n    for pattern in temp_patterns {\n        for file in scanner.files_matching_pattern(pattern) {\n            findings.push(\n                Finding::new(\n                    \"FILE004\",\n                    \"files\",\n                    Severity::Warning,\n                    \"Temporary file found in repository\",\n                )\n                .with_location(&file.path)\n                .with_description(\"Temporary files should not be committed to version control.\")\n                .with_remediation(\"Remove the file and add the pattern to .gitignore.\"),\n            );\n        }\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_large_files_detects_large_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let large_file = root.join(\"large.bin\");\n\n        let large_content = vec![0u8; 11 * 1024 * 1024];\n        fs::write(&large_file, large_content).unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_large_files(&scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"FILE001\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_gitignore_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_gitignore(&scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"FILE002\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_gitignore_missing_recommended_entries() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let gitignore = root.join(\".gitignore\");\n\n        fs::write(&gitignore, \"node_modules/\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_gitignore(&scanner).await.unwrap();\n\n        assert!(findings.iter().any(|f| f.rule_id == \"FILE003\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_temp_files_detects_tmp() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let tmp_file = root.join(\"temp.tmp\");\n\n        fs::write(&tmp_file, \"temporary content\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_temp_files(&scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"FILE004\"));\n    }\n}\n","traces":[{"line":20,"address":[1571536],"length":1,"stats":{"Line":2}},{"line":34,"address":[857777,858377,857203,857168,857517,858919,857433,857289],"length":1,"stats":{"Line":14}},{"line":35,"address":[857533],"length":1,"stats":{"Line":2}},{"line":38,"address":[857549,857623],"length":1,"stats":{"Line":4}},{"line":39,"address":[857316,858356,857803,857664],"length":1,"stats":{"Line":2}},{"line":43,"address":[857629,858202],"length":1,"stats":{"Line":4}},{"line":44,"address":[356099,356239,355190,356893],"length":1,"stats":{"Line":2}},{"line":48,"address":[858782,858208],"length":1,"stats":{"Line":4}},{"line":49,"address":[355208,356780,356898],"length":1,"stats":{"Line":3}},{"line":52,"address":[858792],"length":1,"stats":{"Line":2}},{"line":67,"address":[349639,349520,349550,350643,349617],"length":1,"stats":{"Line":8}},{"line":68,"address":[851754],"length":1,"stats":{"Line":2}},{"line":73,"address":[851899,851845,852023],"length":1,"stats":{"Line":6}},{"line":74,"address":[852083],"length":1,"stats":{"Line":2}},{"line":76,"address":[852755],"length":1,"stats":{"Line":2}},{"line":77,"address":[852594],"length":1,"stats":{"Line":2}},{"line":80,"address":[852147],"length":1,"stats":{"Line":2}},{"line":81,"address":[852155,852344],"length":1,"stats":{"Line":4}},{"line":93,"address":[350061],"length":1,"stats":{"Line":2}},{"line":108,"address":[395168,395176],"length":1,"stats":{"Line":8}},{"line":109,"address":[852938],"length":1,"stats":{"Line":2}},{"line":112,"address":[853097,853024],"length":1,"stats":{"Line":5}},{"line":113,"address":[853286],"length":1,"stats":{"Line":2}},{"line":114,"address":[853216,853111],"length":1,"stats":{"Line":4}},{"line":117,"address":[853103],"length":1,"stats":{"Line":2}},{"line":127,"address":[853313],"length":1,"stats":{"Line":2}},{"line":131,"address":[855790,853476,853186,855200,855784],"length":1,"stats":{"Line":4}},{"line":132,"address":[855499,855222,855292],"length":1,"stats":{"Line":0}},{"line":133,"address":[855489],"length":1,"stats":{"Line":0}},{"line":135,"address":[853776],"length":1,"stats":{"Line":2}},{"line":136,"address":[351362],"length":1,"stats":{"Line":2}},{"line":137,"address":[853560],"length":1,"stats":{"Line":2}},{"line":138,"address":[853614],"length":1,"stats":{"Line":2}},{"line":139,"address":[853668],"length":1,"stats":{"Line":2}},{"line":140,"address":[351578],"length":1,"stats":{"Line":2}},{"line":143,"address":[853969,854035,854121],"length":1,"stats":{"Line":6}},{"line":144,"address":[352248,352090],"length":1,"stats":{"Line":4}},{"line":145,"address":[855101],"length":1,"stats":{"Line":2}},{"line":146,"address":[352463,352910],"length":1,"stats":{"Line":4}},{"line":149,"address":[854437],"length":1,"stats":{"Line":2}},{"line":150,"address":[854445,854507],"length":1,"stats":{"Line":4}},{"line":152,"address":[854775,854678],"length":1,"stats":{"Line":4}},{"line":155,"address":[352612],"length":1,"stats":{"Line":2}},{"line":161,"address":[854269],"length":1,"stats":{"Line":2}},{"line":175,"address":[353694,353783,353664,353761,354979],"length":1,"stats":{"Line":8}},{"line":176,"address":[353754],"length":1,"stats":{"Line":2}},{"line":178,"address":[855971],"length":1,"stats":{"Line":2}},{"line":180,"address":[856326,856157,856424],"length":1,"stats":{"Line":6}},{"line":181,"address":[856516,856837,856701],"length":1,"stats":{"Line":6}},{"line":182,"address":[857091],"length":1,"stats":{"Line":2}},{"line":183,"address":[856905,857014],"length":1,"stats":{"Line":4}},{"line":186,"address":[856897],"length":1,"stats":{"Line":2}},{"line":196,"address":[856546],"length":1,"stats":{"Line":2}}],"covered":51,"coverable":53},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","mod.rs"],"content":"//! Rule categories\n\npub mod custom;\npub mod docs;\npub mod files;\npub mod quality;\npub mod secrets;\npub mod security;\npub mod workflows;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","quality.rs"],"content":"//! Code quality rules\n//!\n//! This module provides rules for checking code quality aspects, including:\n//! - Test files and directories\n//! - Linting configuration\n//! - Editor configuration files\n\nuse crate::error::RepoLensError;\n\nuse crate::config::Config;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for checking code quality\npub struct QualityRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for QualityRules {\n    /// Get the category name\n    fn name(&self) -> &'static str {\n        \"quality\"\n    }\n\n    /// Run all quality-related rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for quality issues\n    async fn run(&self, scanner: &Scanner, config: &Config) -> Result<Vec<Finding>, RepoLensError> {\n        let mut findings = Vec::new();\n\n        // Check for tests\n        if config.is_rule_enabled(\"quality/tests\") {\n            findings.extend(check_tests(scanner).await?);\n        }\n\n        // Check for linting configuration\n        if config.is_rule_enabled(\"quality/linting\") {\n            findings.extend(check_linting(scanner).await?);\n        }\n\n        // Check for editor configuration\n        if config.is_rule_enabled(\"files/editorconfig\") {\n            findings.extend(check_editorconfig(scanner).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for test files and test configuration\n///\n/// Verifies that the repository has tests and appropriate test configuration.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for test-related issues\nasync fn check_tests(scanner: &Scanner) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    // Check for test directories\n    let test_dirs = [\"test\", \"tests\", \"__tests__\", \"spec\", \"specs\"];\n    let has_test_dir = test_dirs.iter().any(|d| scanner.directory_exists(d));\n\n    // Check for test files\n    let test_file_patterns = [\"*.test.*\", \"*.spec.*\", \"*_test.*\", \"*Test.*\"];\n    let has_test_files = test_file_patterns\n        .iter()\n        .any(|p| !scanner.files_matching_pattern(p).is_empty());\n\n    if !has_test_dir && !has_test_files {\n        findings.push(\n            Finding::new(\n                \"QUALITY001\",\n                \"quality\",\n                Severity::Info,\n                \"No tests detected\",\n            )\n            .with_description(\n                \"Tests are important for ensuring code quality and catching regressions.\"\n            )\n            .with_remediation(\n                \"Add tests to your project. Consider using a testing framework appropriate for your language.\"\n            )\n        );\n    }\n\n    // Check if package.json has test script\n    if scanner.file_exists(\"package.json\") {\n        if let Ok(content) = scanner.read_file(\"package.json\") {\n            if !content.contains(r#\"\"test\"\"#) || content.contains(r#\"\"test\": \"echo\"#) {\n                findings.push(\n                    Finding::new(\n                        \"QUALITY002\",\n                        \"quality\",\n                        Severity::Info,\n                        \"No test script defined in package.json\",\n                    )\n                    .with_description(\n                        \"A 'test' script in package.json enables running tests with 'npm test'.\",\n                    ),\n                );\n            }\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for linting configuration files\n///\n/// Verifies that appropriate linting tools are configured based on\n/// the project type (JavaScript, Python, Ruby, Go, Rust, etc.).\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for missing linting configuration\nasync fn check_linting(scanner: &Scanner) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    // Linting config files by language/tool\n    let linting_configs = [\n        // JavaScript/TypeScript\n        (\".eslintrc\", \"ESLint\"),\n        (\".eslintrc.js\", \"ESLint\"),\n        (\".eslintrc.json\", \"ESLint\"),\n        (\".eslintrc.yml\", \"ESLint\"),\n        (\"eslint.config.js\", \"ESLint\"),\n        (\"biome.json\", \"Biome\"),\n        // Formatting\n        (\".prettierrc\", \"Prettier\"),\n        (\".prettierrc.js\", \"Prettier\"),\n        (\".prettierrc.json\", \"Prettier\"),\n        // Python\n        (\"pyproject.toml\", \"Python tooling\"),\n        (\".flake8\", \"Flake8\"),\n        (\"setup.cfg\", \"Python tooling\"),\n        (\".pylintrc\", \"Pylint\"),\n        (\"ruff.toml\", \"Ruff\"),\n        // Ruby\n        (\".rubocop.yml\", \"RuboCop\"),\n        // Go\n        (\".golangci.yml\", \"golangci-lint\"),\n        (\".golangci.yaml\", \"golangci-lint\"),\n        // Rust\n        (\"rustfmt.toml\", \"rustfmt\"),\n        (\".rustfmt.toml\", \"rustfmt\"),\n        (\"clippy.toml\", \"Clippy\"),\n    ];\n\n    // Detect project type\n    let is_js_project = scanner.file_exists(\"package.json\");\n    let is_python_project =\n        scanner.file_exists(\"pyproject.toml\") || scanner.file_exists(\"requirements.txt\");\n    let is_ruby_project = scanner.file_exists(\"Gemfile\");\n    let is_go_project = scanner.file_exists(\"go.mod\");\n    let is_rust_project = scanner.file_exists(\"Cargo.toml\");\n\n    let has_linting = linting_configs.iter().any(|(f, _)| scanner.file_exists(f));\n\n    if !has_linting\n        && (is_js_project\n            || is_python_project\n            || is_ruby_project\n            || is_go_project\n            || is_rust_project)\n    {\n        let suggestion = if is_js_project {\n            \"ESLint for linting and Prettier for formatting\"\n        } else if is_python_project {\n            \"Ruff or Flake8 for linting\"\n        } else if is_ruby_project {\n            \"RuboCop for linting\"\n        } else if is_go_project {\n            \"golangci-lint for linting\"\n        } else {\n            \"Clippy for linting and rustfmt for formatting\"\n        };\n\n        findings.push(\n            Finding::new(\n                \"QUALITY003\",\n                \"quality\",\n                Severity::Info,\n                \"No linting configuration detected\",\n            )\n            .with_description(\n                \"Linting tools help maintain consistent code style and catch potential issues.\",\n            )\n            .with_remediation(format!(\"Consider adding {} to your project.\", suggestion)),\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check for .editorconfig file\n///\n/// Verifies that an .editorconfig file exists to maintain consistent\n/// coding styles across editors and IDEs.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for missing .editorconfig\nasync fn check_editorconfig(scanner: &Scanner) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    if !scanner.file_exists(\".editorconfig\") {\n        findings.push(\n            Finding::new(\n                \"QUALITY004\",\n                \"quality\",\n                Severity::Info,\n                \".editorconfig file is missing\",\n            )\n            .with_description(\n                \"EditorConfig helps maintain consistent coding styles across different editors and IDEs.\"\n            )\n            .with_remediation(\n                \"Create a .editorconfig file to define coding style preferences.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_tests_no_tests_detected() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_tests(&scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"QUALITY001\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_tests_package_json_no_test_script() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let package_json = root.join(\"package.json\");\n\n        // Create package.json without test script or with echo test\n        fs::write(\n            &package_json,\n            r#\"{\"name\": \"test\", \"version\": \"1.0.0\", \"scripts\": {\"test\": \"echo \\\"No tests\\\"\"}}\"#,\n        )\n        .unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_tests(&scanner).await.unwrap();\n\n        // Should find QUALITY002 because test script is just \"echo\"\n        assert!(findings.iter().any(|f| f.rule_id == \"QUALITY002\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_linting_no_config() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let package_json = root.join(\"package.json\");\n\n        fs::write(&package_json, r#\"{\"name\": \"test\"}\"#).unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_linting(&scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"QUALITY003\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_editorconfig_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_editorconfig(&scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"QUALITY004\"));\n    }\n}\n","traces":[{"line":21,"address":[1188256],"length":1,"stats":{"Line":2}},{"line":35,"address":[1081523],"length":1,"stats":{"Line":18}},{"line":36,"address":[112461],"length":1,"stats":{"Line":3}},{"line":39,"address":[112551,112477],"length":1,"stats":{"Line":6}},{"line":40,"address":[112592,112244,112731,113284],"length":1,"stats":{"Line":3}},{"line":44,"address":[112557,113130],"length":1,"stats":{"Line":6}},{"line":45,"address":[113311,112262,113171,113965],"length":1,"stats":{"Line":3}},{"line":49,"address":[113710,113136],"length":1,"stats":{"Line":6}},{"line":50,"address":[113852,113970,112280],"length":1,"stats":{"Line":2}},{"line":53,"address":[113720],"length":1,"stats":{"Line":4}},{"line":68,"address":[993424,993553,993463,995128,995217,993575],"length":1,"stats":{"Line":13}},{"line":69,"address":[106394],"length":1,"stats":{"Line":3}},{"line":72,"address":[106470],"length":1,"stats":{"Line":2}},{"line":73,"address":[106694,106605,108096,108113],"length":1,"stats":{"Line":11}},{"line":76,"address":[993894],"length":1,"stats":{"Line":3}},{"line":77,"address":[106850],"length":1,"stats":{"Line":3}},{"line":79,"address":[108161,108144],"length":1,"stats":{"Line":6}},{"line":81,"address":[994104],"length":1,"stats":{"Line":2}},{"line":82,"address":[107145],"length":1,"stats":{"Line":2}},{"line":83,"address":[107005],"length":1,"stats":{"Line":2}},{"line":86,"address":[106997],"length":1,"stats":{"Line":2}},{"line":99,"address":[106971,107184,108041],"length":1,"stats":{"Line":6}},{"line":100,"address":[107361,107514,107423],"length":1,"stats":{"Line":6}},{"line":101,"address":[107756,107562,107633],"length":1,"stats":{"Line":6}},{"line":102,"address":[107881],"length":1,"stats":{"Line":2}},{"line":103,"address":[107846,107678],"length":1,"stats":{"Line":4}},{"line":106,"address":[107670],"length":1,"stats":{"Line":2}},{"line":117,"address":[107202],"length":1,"stats":{"Line":2}},{"line":132,"address":[995440,995470,995545,995567,998561],"length":1,"stats":{"Line":8}},{"line":133,"address":[108386],"length":1,"stats":{"Line":2}},{"line":136,"address":[109481],"length":1,"stats":{"Line":2}},{"line":138,"address":[108464],"length":1,"stats":{"Line":2}},{"line":139,"address":[108518],"length":1,"stats":{"Line":2}},{"line":140,"address":[108565],"length":1,"stats":{"Line":2}},{"line":141,"address":[108612],"length":1,"stats":{"Line":2}},{"line":142,"address":[108659],"length":1,"stats":{"Line":2}},{"line":143,"address":[108706],"length":1,"stats":{"Line":2}},{"line":145,"address":[995912],"length":1,"stats":{"Line":2}},{"line":146,"address":[995966],"length":1,"stats":{"Line":2}},{"line":147,"address":[996013],"length":1,"stats":{"Line":2}},{"line":149,"address":[996060],"length":1,"stats":{"Line":2}},{"line":150,"address":[108962],"length":1,"stats":{"Line":2}},{"line":151,"address":[996168],"length":1,"stats":{"Line":2}},{"line":152,"address":[109063],"length":1,"stats":{"Line":2}},{"line":153,"address":[996269],"length":1,"stats":{"Line":2}},{"line":155,"address":[109171],"length":1,"stats":{"Line":2}},{"line":157,"address":[109225],"length":1,"stats":{"Line":2}},{"line":158,"address":[109279],"length":1,"stats":{"Line":2}},{"line":160,"address":[109326],"length":1,"stats":{"Line":2}},{"line":161,"address":[109380],"length":1,"stats":{"Line":2}},{"line":162,"address":[996579],"length":1,"stats":{"Line":2}},{"line":166,"address":[110118,110187],"length":1,"stats":{"Line":4}},{"line":167,"address":[997348],"length":1,"stats":{"Line":2}},{"line":169,"address":[110285],"length":1,"stats":{"Line":2}},{"line":170,"address":[997478],"length":1,"stats":{"Line":2}},{"line":171,"address":[997519],"length":1,"stats":{"Line":2}},{"line":173,"address":[111472,110413,111456],"length":1,"stats":{"Line":6}},{"line":175,"address":[110496],"length":1,"stats":{"Line":2}},{"line":176,"address":[997656],"length":1,"stats":{"Line":2}},{"line":177,"address":[110661],"length":1,"stats":{"Line":3}},{"line":178,"address":[997837],"length":1,"stats":{"Line":4}},{"line":179,"address":[110695],"length":1,"stats":{"Line":2}},{"line":180,"address":[110705],"length":1,"stats":{"Line":4}},{"line":182,"address":[110675,110753],"length":1,"stats":{"Line":4}},{"line":183,"address":[997878],"length":1,"stats":{"Line":2}},{"line":184,"address":[997947,998111,997866],"length":1,"stats":{"Line":0}},{"line":185,"address":[997920],"length":1,"stats":{"Line":0}},{"line":186,"address":[110837,110762,110927],"length":1,"stats":{"Line":0}},{"line":187,"address":[997962],"length":1,"stats":{"Line":0}},{"line":188,"address":[110804,110866,110895],"length":1,"stats":{"Line":0}},{"line":189,"address":[110868],"length":1,"stats":{"Line":0}},{"line":191,"address":[110839],"length":1,"stats":{"Line":0}},{"line":194,"address":[111359],"length":1,"stats":{"Line":2}},{"line":195,"address":[111104,110999,111312],"length":1,"stats":{"Line":6}},{"line":198,"address":[998143],"length":1,"stats":{"Line":2}},{"line":204,"address":[111399,111069,111351,111174,111147],"length":1,"stats":{"Line":4}},{"line":208,"address":[110522],"length":1,"stats":{"Line":2}},{"line":223,"address":[1188240,1188248],"length":1,"stats":{"Line":8}},{"line":224,"address":[111594],"length":1,"stats":{"Line":2}},{"line":226,"address":[111672,111733],"length":1,"stats":{"Line":4}},{"line":227,"address":[112031],"length":1,"stats":{"Line":2}},{"line":228,"address":[111747,111964],"length":1,"stats":{"Line":4}},{"line":231,"address":[111739],"length":1,"stats":{"Line":2}},{"line":243,"address":[111825],"length":1,"stats":{"Line":2}}],"covered":77,"coverable":84},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","secrets.rs"],"content":"//! Secrets detection rules\n//!\n//! This module provides rules for detecting exposed secrets and credentials\n//! in repository files. It checks for:\n//! - Hardcoded secrets in source files (API keys, tokens, passwords)\n//! - Sensitive files (private keys, certificates, credentials)\n//! - Environment files (.env) that should not be committed\n\nuse rayon::prelude::*;\n\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::patterns::SECRET_PATTERNS;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for detecting secrets and credentials\npub struct SecretsRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for SecretsRules {\n    /// Get the category name\n    fn name(&self) -> &'static str {\n        \"secrets\"\n    }\n\n    /// Run all secrets detection rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for detected secrets\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the scan fails\n    async fn run(&self, scanner: &Scanner, config: &Config) -> Result<Vec<Finding>, RepoLensError> {\n        let mut findings = Vec::new();\n\n        // Check for hardcoded secrets in source files\n        if config.is_rule_enabled(\"secrets/hardcoded\") {\n            findings.extend(check_hardcoded_secrets(scanner, config).await?);\n        }\n\n        // Check for sensitive files\n        if config.is_rule_enabled(\"secrets/files\") {\n            findings.extend(check_sensitive_files(scanner, config).await?);\n        }\n\n        // Check for .env files\n        if config.is_rule_enabled(\"secrets/env\") {\n            findings.extend(check_env_files(scanner, config).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for hardcoded secrets in source files\n///\n/// Scans files with common source code extensions for patterns that indicate\n/// hardcoded secrets like API keys, tokens, and passwords.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `config` - The configuration with ignore patterns\n///\n/// # Returns\n///\n/// A vector of findings for detected secrets\nasync fn check_hardcoded_secrets(\n    scanner: &Scanner,\n    config: &Config,\n) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    // File extensions to scan\n    let extensions = [\n        \"js\", \"ts\", \"jsx\", \"tsx\", \"py\", \"rb\", \"php\", \"java\", \"go\", \"rs\", \"cpp\", \"c\", \"yml\", \"yaml\",\n        \"json\", \"toml\", \"env\", \"config\", \"conf\", \"sql\", \"sh\", \"bash\",\n    ];\n\n    let files: Vec<_> = scanner\n        .files_with_extensions(&extensions)\n        .into_iter()\n        .filter(|file| !config.should_ignore_file(&file.path))\n        .map(|file| file.path.clone())\n        .collect();\n\n    // Process files in parallel\n    let file_findings: Vec<Vec<Finding>> = files\n        .par_iter()\n        .filter_map(|file_path| {\n            let content = match scanner.read_file(file_path) {\n                Ok(c) => c,\n                Err(e) => {\n                    tracing::warn!(\"Failed to read file {}: {}\", file_path, e);\n                    return None;\n                }\n            };\n\n            match check_file_for_secrets(file_path, &content, config) {\n                Ok(f) => Some(f),\n                Err(e) => {\n                    tracing::warn!(\"Error checking file {}: {}\", file_path, e);\n                    None\n                }\n            }\n        })\n        .collect();\n\n    // Flatten results\n    for file_finding in file_findings {\n        findings.extend(file_finding);\n    }\n\n    Ok(findings)\n}\n\n/// Check a single file for secrets\n///\n/// # Arguments\n///\n/// * `file_path` - Path to the file\n/// * `content` - File content\n/// * `config` - Configuration with ignore patterns\n///\n/// # Returns\n///\n/// A vector of findings for secrets found in this file\nfn check_file_for_secrets(\n    file_path: &str,\n    content: &str,\n    config: &Config,\n) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    for pattern in SECRET_PATTERNS.iter() {\n        if let Some(captures) = pattern.regex.captures(content) {\n            if config.should_ignore_pattern(file_path) {\n                continue;\n            }\n\n            let line_num = find_line_number(content, &captures)?;\n\n            findings.push(\n                Finding::new(\n                    \"SEC001\",\n                    \"secrets\",\n                    Severity::Critical,\n                    format!(\"{} detected\", pattern.name),\n                )\n                .with_location(format!(\"{}:{}\", file_path, line_num))\n                .with_description(pattern.description.to_string())\n                .with_remediation(\n                    \"Remove the secret and use environment variables or a secrets manager instead.\",\n                ),\n            );\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Find the line number where a regex match occurs\n///\n/// # Arguments\n///\n/// * `content` - File content\n/// * `captures` - Regex captures from the match\n///\n/// # Returns\n///\n/// The line number (1-indexed)\nfn find_line_number(content: &str, captures: &regex::Captures) -> Result<usize, RepoLensError> {\n    let match_start = captures\n        .get(0)\n        .ok_or_else(|| {\n            RepoLensError::Rule(crate::error::RuleError::ExecutionFailed {\n                message: \"No match found in pattern capture\".to_string(),\n            })\n        })?\n        .start();\n\n    Ok(content[..match_start].matches('\\n').count() + 1)\n}\n\n/// Check for sensitive files that should not be in version control\n///\n/// Detects files like private keys, certificates, and credential files\n/// that pose a security risk if committed to the repository.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `_config` - The configuration (currently unused)\n///\n/// # Returns\n///\n/// A vector of findings for detected sensitive files\nasync fn check_sensitive_files(\n    scanner: &Scanner,\n    _config: &Config,\n) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    // List of sensitive file patterns\n    let sensitive_patterns = [\n        (\"*.pem\", \"Private key file\"),\n        (\"*.key\", \"Private key file\"),\n        (\"*.p12\", \"PKCS#12 certificate bundle\"),\n        (\"*.pfx\", \"PKCS#12 certificate bundle\"),\n        (\"*.jks\", \"Java keystore\"),\n        (\"id_rsa\", \"SSH private key\"),\n        (\"id_dsa\", \"SSH private key\"),\n        (\"id_ecdsa\", \"SSH private key\"),\n        (\"id_ed25519\", \"SSH private key\"),\n        (\".htpasswd\", \"Apache password file\"),\n        (\"credentials.json\", \"Credentials file\"),\n        (\"service-account.json\", \"Service account credentials\"),\n        (\"secrets.yml\", \"Secrets configuration\"),\n        (\"secrets.yaml\", \"Secrets configuration\"),\n        (\"secrets.json\", \"Secrets configuration\"),\n    ];\n\n    for (pattern, description) in sensitive_patterns {\n        for file in scanner.files_matching_pattern(pattern) {\n            findings.push(\n                Finding::new(\n                    \"SEC002\",\n                    \"secrets\",\n                    Severity::Critical,\n                    format!(\"{} found in repository\", description),\n                )\n                .with_location(&file.path)\n                .with_description(format!(\n                    \"The file '{}' appears to contain sensitive data and should not be committed to version control.\",\n                    file.path\n                ))\n                .with_remediation(\n                    \"Remove the file from the repository and add it to .gitignore. If the file was previously committed, consider rotating any contained credentials.\"\n                )\n            );\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for .env files that should not be committed\n///\n/// Detects environment files that may contain secrets. Example files\n/// (.env.example, .env.template) are allowed.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `_config` - The configuration (currently unused)\n///\n/// # Returns\n///\n/// A vector of findings for detected .env files\nasync fn check_env_files(\n    scanner: &Scanner,\n    _config: &Config,\n) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    // Check for .env files (but allow .env.example)\n    let env_patterns = [\n        \".env\",\n        \".env.local\",\n        \".env.production\",\n        \".env.development\",\n        \".env.test\",\n    ];\n\n    for pattern in env_patterns {\n        for file in scanner.files_matching_pattern(pattern) {\n            // Allow example/template files\n            if file.path.contains(\".example\")\n                || file.path.contains(\".template\")\n                || file.path.contains(\".sample\")\n            {\n                continue;\n            }\n\n            findings.push(\n                Finding::new(\n                    \"SEC003\",\n                    \"secrets\",\n                    Severity::Critical,\n                    \"Environment file found in repository\",\n                )\n                .with_location(&file.path)\n                .with_description(\n                    \"Environment files often contain sensitive configuration and secrets that should not be committed.\"\n                )\n                .with_remediation(\n                    \"Add the file to .gitignore and create a .env.example file as a template.\"\n                )\n            );\n        }\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_hardcoded_secrets_detects_api_key() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let config_file = root.join(\"config.js\");\n\n        fs::write(&config_file, \"const apiKey = 'sk_test_1234567890abcdef';\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config::default();\n\n        let findings = check_hardcoded_secrets(&scanner, &config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SEC001\"));\n        assert!(findings.iter().any(|f| f.message.contains(\"detected\")));\n    }\n\n    #[tokio::test]\n    async fn test_check_hardcoded_secrets_ignores_ignored_files() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let config_file = root.join(\"config.js\");\n\n        fs::write(&config_file, \"const apiKey = 'sk_test_1234567890abcdef';\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let mut config = Config::default();\n        config.secrets.ignore_files.push(\"config.js\".to_string());\n\n        let findings = check_hardcoded_secrets(&scanner, &config).await.unwrap();\n\n        assert!(findings.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_check_sensitive_files_detects_pem() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let key_file = root.join(\"private.pem\");\n\n        fs::write(&key_file, \"-----BEGIN PRIVATE KEY-----\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config::default();\n\n        let findings = check_sensitive_files(&scanner, &config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SEC002\"));\n        assert!(findings\n            .iter()\n            .any(|f| f.message.contains(\"Private key file\")));\n    }\n\n    #[tokio::test]\n    async fn test_check_env_files_detects_env() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let env_file = root.join(\".env\");\n\n        fs::write(&env_file, \"API_KEY=secret123\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config::default();\n\n        let findings = check_env_files(&scanner, &config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SEC003\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_env_files_allows_example() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let env_example = root.join(\".env.example\");\n\n        fs::write(&env_example, \"API_KEY=your_key_here\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config::default();\n\n        let findings = check_env_files(&scanner, &config).await.unwrap();\n\n        assert!(findings.is_empty());\n    }\n}\n","traces":[{"line":24,"address":[84400],"length":1,"stats":{"Line":4}},{"line":42,"address":[949555],"length":1,"stats":{"Line":18}},{"line":43,"address":[979901],"length":1,"stats":{"Line":5}},{"line":46,"address":[979917,979991],"length":1,"stats":{"Line":7}},{"line":47,"address":[285343,285297],"length":1,"stats":{"Line":3}},{"line":51,"address":[979997,980586],"length":1,"stats":{"Line":5}},{"line":52,"address":[980783,980627,981453,979702],"length":1,"stats":{"Line":3}},{"line":56,"address":[980592,981182],"length":1,"stats":{"Line":4}},{"line":57,"address":[981324,979720,981458],"length":1,"stats":{"Line":3}},{"line":60,"address":[981192],"length":1,"stats":{"Line":2}},{"line":77,"address":[82064],"length":1,"stats":{"Line":2}},{"line":81,"address":[971608],"length":1,"stats":{"Line":2}},{"line":84,"address":[971694],"length":1,"stats":{"Line":2}},{"line":89,"address":[972366,972302],"length":1,"stats":{"Line":5}},{"line":92,"address":[973054,973040],"length":1,"stats":{"Line":5}},{"line":93,"address":[973139,973104],"length":1,"stats":{"Line":4}},{"line":97,"address":[811447,811536],"length":1,"stats":{"Line":5}},{"line":99,"address":[973168,974498,974492],"length":1,"stats":{"Line":2}},{"line":100,"address":[973215],"length":1,"stats":{"Line":2}},{"line":101,"address":[973363],"length":1,"stats":{"Line":2}},{"line":102,"address":[973316],"length":1,"stats":{"Line":0}},{"line":103,"address":[974822,973332,974559],"length":1,"stats":{"Line":0}},{"line":104,"address":[974790],"length":1,"stats":{"Line":0}},{"line":108,"address":[973536,973427],"length":1,"stats":{"Line":4}},{"line":109,"address":[973718],"length":1,"stats":{"Line":2}},{"line":110,"address":[973634],"length":1,"stats":{"Line":0}},{"line":111,"address":[973864,974126,973682],"length":1,"stats":{"Line":0}},{"line":112,"address":[974105],"length":1,"stats":{"Line":0}},{"line":119,"address":[972590,972724],"length":1,"stats":{"Line":4}},{"line":120,"address":[972793,972988],"length":1,"stats":{"Line":4}},{"line":123,"address":[972838],"length":1,"stats":{"Line":2}},{"line":137,"address":[947200,948848,948972],"length":1,"stats":{"Line":2}},{"line":142,"address":[947272],"length":1,"stats":{"Line":2}},{"line":144,"address":[947309,947379,948948],"length":1,"stats":{"Line":10}},{"line":145,"address":[947571,947699],"length":1,"stats":{"Line":8}},{"line":146,"address":[947828,947940],"length":1,"stats":{"Line":6}},{"line":150,"address":[947972,948017],"length":1,"stats":{"Line":4}},{"line":152,"address":[948778],"length":1,"stats":{"Line":2}},{"line":153,"address":[948286,948568,948743,948696],"length":1,"stats":{"Line":8}},{"line":156,"address":[83055],"length":1,"stats":{"Line":2}},{"line":157,"address":[83063],"length":1,"stats":{"Line":2}},{"line":159,"address":[83280,83508,83253,83758],"length":1,"stats":{"Line":4}},{"line":160,"address":[83551,83631,83734,83524],"length":1,"stats":{"Line":4}},{"line":168,"address":[947595],"length":1,"stats":{"Line":2}},{"line":181,"address":[83888],"length":1,"stats":{"Line":2}},{"line":182,"address":[949056,949159],"length":1,"stats":{"Line":2}},{"line":184,"address":[814128],"length":1,"stats":{"Line":0}},{"line":185,"address":[975181],"length":1,"stats":{"Line":0}},{"line":186,"address":[975149],"length":1,"stats":{"Line":0}},{"line":191,"address":[949401,949319],"length":1,"stats":{"Line":2}},{"line":207,"address":[949440],"length":1,"stats":{"Line":2}},{"line":211,"address":[975379],"length":1,"stats":{"Line":2}},{"line":214,"address":[815205],"length":1,"stats":{"Line":2}},{"line":215,"address":[975452],"length":1,"stats":{"Line":2}},{"line":216,"address":[975506],"length":1,"stats":{"Line":2}},{"line":217,"address":[975553],"length":1,"stats":{"Line":2}},{"line":218,"address":[814599],"length":1,"stats":{"Line":2}},{"line":219,"address":[814646],"length":1,"stats":{"Line":2}},{"line":220,"address":[975708],"length":1,"stats":{"Line":2}},{"line":221,"address":[814754],"length":1,"stats":{"Line":2}},{"line":222,"address":[814801],"length":1,"stats":{"Line":2}},{"line":223,"address":[975856],"length":1,"stats":{"Line":2}},{"line":224,"address":[814895],"length":1,"stats":{"Line":2}},{"line":225,"address":[814949],"length":1,"stats":{"Line":2}},{"line":226,"address":[976011],"length":1,"stats":{"Line":2}},{"line":227,"address":[976065],"length":1,"stats":{"Line":2}},{"line":228,"address":[815111],"length":1,"stats":{"Line":2}},{"line":229,"address":[815158],"length":1,"stats":{"Line":2}},{"line":232,"address":[815768,815854,815709],"length":1,"stats":{"Line":6}},{"line":233,"address":[816147,816283,815962],"length":1,"stats":{"Line":6}},{"line":234,"address":[977885],"length":1,"stats":{"Line":2}},{"line":235,"address":[977850,977539,977803],"length":1,"stats":{"Line":6}},{"line":238,"address":[977351],"length":1,"stats":{"Line":2}},{"line":239,"address":[977359,977439],"length":1,"stats":{"Line":4}},{"line":241,"address":[977635],"length":1,"stats":{"Line":2}},{"line":242,"address":[977703,977643],"length":1,"stats":{"Line":4}},{"line":253,"address":[977000],"length":1,"stats":{"Line":2}},{"line":269,"address":[949472],"length":1,"stats":{"Line":3}},{"line":273,"address":[817097],"length":1,"stats":{"Line":3}},{"line":276,"address":[978181],"length":1,"stats":{"Line":4}},{"line":284,"address":[978459,978316,978557],"length":1,"stats":{"Line":7}},{"line":285,"address":[978652,978991,978855],"length":1,"stats":{"Line":9}},{"line":287,"address":[818043,818088],"length":1,"stats":{"Line":6}},{"line":288,"address":[979142],"length":1,"stats":{"Line":2}},{"line":289,"address":[979215],"length":1,"stats":{"Line":2}},{"line":294,"address":[979459],"length":1,"stats":{"Line":2}},{"line":295,"address":[979291],"length":1,"stats":{"Line":2}},{"line":298,"address":[979283],"length":1,"stats":{"Line":2}},{"line":312,"address":[978685],"length":1,"stats":{"Line":2}}],"covered":80,"coverable":89},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","security.rs"],"content":"//! Security rules\n//!\n//! This module provides rules for checking security-related aspects, including:\n//! - CODEOWNERS file for code review requirements\n//! - Dependency lock files for reproducible builds\n//! - Runtime version files for consistent environments\n\nuse crate::error::RepoLensError;\n\nuse crate::config::Config;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for checking security-related aspects\npub struct SecurityRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for SecurityRules {\n    /// Get the category name\n    fn name(&self) -> &'static str {\n        \"security\"\n    }\n\n    /// Run all security-related rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for security issues\n    async fn run(&self, scanner: &Scanner, config: &Config) -> Result<Vec<Finding>, RepoLensError> {\n        let mut findings = Vec::new();\n\n        // Check CODEOWNERS\n        if config.is_rule_enabled(\"security/codeowners\") {\n            findings.extend(check_codeowners(scanner, config).await?);\n        }\n\n        // Check for dependency files\n        if config.is_rule_enabled(\"security/dependencies\") {\n            findings.extend(check_dependencies(scanner).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for CODEOWNERS file\n///\n/// Verifies that a CODEOWNERS file exists. Required for enterprise preset,\n/// recommended for strict preset.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `config` - The configuration (used to determine severity)\n///\n/// # Returns\n///\n/// A vector of findings for CODEOWNERS issues\nasync fn check_codeowners(\n    scanner: &Scanner,\n    config: &Config,\n) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    let codeowners_files = [\"CODEOWNERS\", \".github/CODEOWNERS\", \"docs/CODEOWNERS\"];\n    let has_codeowners = codeowners_files.iter().any(|f| scanner.file_exists(f));\n\n    // CODEOWNERS is required for enterprise, recommended for strict\n    let severity = if config.preset == \"enterprise\" {\n        Severity::Critical\n    } else {\n        Severity::Info\n    };\n\n    if !has_codeowners {\n        findings.push(\n            Finding::new(\n                \"SECURITY001\",\n                \"security\",\n                severity,\n                \"CODEOWNERS file is missing\",\n            )\n            .with_description(\n                \"A CODEOWNERS file automatically assigns reviewers to pull requests based on file paths.\"\n            )\n            .with_remediation(\n                \"Create a CODEOWNERS file in .github/ to define code ownership and review requirements.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check for dependency lock files and version files\n///\n/// Verifies that lock files exist for reproducible builds and that\n/// runtime version files are specified for consistent environments.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for dependency-related issues\nasync fn check_dependencies(scanner: &Scanner) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    // Check for lock files (indicates dependency management)\n    let _lock_files = [\n        (\"package-lock.json\", \"npm\"),\n        (\"yarn.lock\", \"Yarn\"),\n        (\"pnpm-lock.yaml\", \"pnpm\"),\n        (\"Cargo.lock\", \"Cargo\"),\n        (\"Gemfile.lock\", \"Bundler\"),\n        (\"poetry.lock\", \"Poetry\"),\n        (\"Pipfile.lock\", \"Pipenv\"),\n        (\"composer.lock\", \"Composer\"),\n        (\"go.sum\", \"Go modules\"),\n    ];\n\n    let package_files = [\n        (\"package.json\", \"package-lock.json\"),\n        (\"Cargo.toml\", \"Cargo.lock\"),\n        (\"Gemfile\", \"Gemfile.lock\"),\n        (\"pyproject.toml\", \"poetry.lock\"),\n        (\"Pipfile\", \"Pipfile.lock\"),\n        (\"composer.json\", \"composer.lock\"),\n        (\"go.mod\", \"go.sum\"),\n    ];\n\n    for (package_file, lock_file) in package_files {\n        if scanner.file_exists(package_file) && !scanner.file_exists(lock_file) {\n            findings.push(\n                Finding::new(\n                    \"SECURITY002\",\n                    \"security\",\n                    Severity::Warning,\n                    format!(\"Lock file {} is missing\", lock_file),\n                )\n                .with_description(\n                    \"Lock files ensure reproducible builds and protect against supply chain attacks.\"\n                )\n                .with_remediation(\n                    \"Generate the lock file by running your package manager's install command.\"\n                )\n            );\n        }\n    }\n\n    // Check for .nvmrc or similar version files\n    let version_managers = [\n        (\".nvmrc\", \"Node.js version\"),\n        (\".node-version\", \"Node.js version\"),\n        (\".python-version\", \"Python version\"),\n        (\".ruby-version\", \"Ruby version\"),\n        (\"rust-toolchain.toml\", \"Rust toolchain\"),\n    ];\n\n    let has_any_version_file = version_managers.iter().any(|(f, _)| scanner.file_exists(f));\n\n    // Detect project type\n    let is_node = scanner.file_exists(\"package.json\");\n    let is_python =\n        scanner.file_exists(\"pyproject.toml\") || scanner.file_exists(\"requirements.txt\");\n    let is_ruby = scanner.file_exists(\"Gemfile\");\n    let is_rust = scanner.file_exists(\"Cargo.toml\");\n\n    if !has_any_version_file && (is_node || is_python || is_ruby || is_rust) {\n        findings.push(\n            Finding::new(\n                \"SECURITY003\",\n                \"security\",\n                Severity::Info,\n                \"No runtime version file found\",\n            )\n            .with_description(\n                \"Specifying runtime versions (e.g., .nvmrc, .python-version) ensures consistent development environments.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::Config;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_codeowners_missing_enterprise() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config {\n            preset: \"enterprise\".to_string(),\n            ..Default::default()\n        };\n        let findings = check_codeowners(&scanner, &config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SECURITY001\"));\n        assert!(findings\n            .iter()\n            .any(|f| f.severity == crate::rules::results::Severity::Critical));\n    }\n\n    #[tokio::test]\n    async fn test_check_codeowners_missing_strict() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config {\n            preset: \"strict\".to_string(),\n            ..Default::default()\n        };\n        let findings = check_codeowners(&scanner, &config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SECURITY001\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_dependencies_missing_lock_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let package_json = root.join(\"package.json\");\n\n        fs::write(&package_json, r#\"{\"name\": \"test\"}\"#).unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_dependencies(&scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SECURITY002\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_dependencies_no_version_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let package_json = root.join(\"package.json\");\n\n        fs::write(&package_json, r#\"{\"name\": \"test\"}\"#).unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_dependencies(&scanner).await.unwrap();\n\n        assert!(findings.iter().any(|f| f.rule_id == \"SECURITY003\"));\n    }\n}\n","traces":[{"line":21,"address":[1572416],"length":1,"stats":{"Line":2}},{"line":35,"address":[1436297,1437339,1436417,1436211,1436777,1436501,1437478,1436176],"length":1,"stats":{"Line":19}},{"line":36,"address":[1436517],"length":1,"stats":{"Line":3}},{"line":39,"address":[1436607,1436533],"length":1,"stats":{"Line":6}},{"line":40,"address":[1436648,1436803,1437457,1436324],"length":1,"stats":{"Line":3}},{"line":44,"address":[1436613,1437202],"length":1,"stats":{"Line":6}},{"line":45,"address":[285662,285741],"length":1,"stats":{"Line":2}},{"line":48,"address":[936108],"length":1,"stats":{"Line":3}},{"line":65,"address":[1431792],"length":1,"stats":{"Line":2}},{"line":69,"address":[1432112],"length":1,"stats":{"Line":2}},{"line":71,"address":[1432185],"length":1,"stats":{"Line":3}},{"line":72,"address":[1432833,1432263,1432816,1432346],"length":1,"stats":{"Line":10}},{"line":75,"address":[1432399,1432435],"length":1,"stats":{"Line":4}},{"line":76,"address":[1432437],"length":1,"stats":{"Line":2}},{"line":78,"address":[1432427],"length":1,"stats":{"Line":2}},{"line":81,"address":[1432449],"length":1,"stats":{"Line":2}},{"line":82,"address":[1432742],"length":1,"stats":{"Line":2}},{"line":83,"address":[1432455,1432672],"length":1,"stats":{"Line":6}},{"line":98,"address":[1432533],"length":1,"stats":{"Line":3}},{"line":113,"address":[1431824,1431832],"length":1,"stats":{"Line":9}},{"line":114,"address":[1432954],"length":1,"stats":{"Line":2}},{"line":117,"address":[1433513],"length":1,"stats":{"Line":3}},{"line":118,"address":[1433027],"length":1,"stats":{"Line":2}},{"line":119,"address":[1433081],"length":1,"stats":{"Line":2}},{"line":120,"address":[1433135],"length":1,"stats":{"Line":2}},{"line":121,"address":[1433189],"length":1,"stats":{"Line":3}},{"line":122,"address":[1433243],"length":1,"stats":{"Line":3}},{"line":123,"address":[1433297],"length":1,"stats":{"Line":2}},{"line":124,"address":[1433351],"length":1,"stats":{"Line":3}},{"line":125,"address":[1433405],"length":1,"stats":{"Line":3}},{"line":126,"address":[1433459],"length":1,"stats":{"Line":3}},{"line":129,"address":[1434130],"length":1,"stats":{"Line":3}},{"line":130,"address":[1433801],"length":1,"stats":{"Line":2}},{"line":131,"address":[1433848],"length":1,"stats":{"Line":3}},{"line":132,"address":[1433895],"length":1,"stats":{"Line":3}},{"line":133,"address":[1433942],"length":1,"stats":{"Line":4}},{"line":134,"address":[932885],"length":1,"stats":{"Line":4}},{"line":135,"address":[1434036],"length":1,"stats":{"Line":4}},{"line":136,"address":[932979],"length":1,"stats":{"Line":4}},{"line":139,"address":[1434532,1434387,1434446],"length":1,"stats":{"Line":6}},{"line":140,"address":[1435741,1434632],"length":1,"stats":{"Line":4}},{"line":141,"address":[1436064],"length":1,"stats":{"Line":2}},{"line":142,"address":[934827],"length":1,"stats":{"Line":2}},{"line":145,"address":[1435796],"length":1,"stats":{"Line":2}},{"line":146,"address":[934700],"length":1,"stats":{"Line":2}},{"line":159,"address":[1434924],"length":1,"stats":{"Line":2}},{"line":160,"address":[933557],"length":1,"stats":{"Line":2}},{"line":161,"address":[1434715],"length":1,"stats":{"Line":2}},{"line":162,"address":[1434762],"length":1,"stats":{"Line":2}},{"line":163,"address":[1434816],"length":1,"stats":{"Line":2}},{"line":164,"address":[1434870],"length":1,"stats":{"Line":2}},{"line":167,"address":[1435097,1436128,1436144],"length":1,"stats":{"Line":6}},{"line":170,"address":[934078],"length":1,"stats":{"Line":2}},{"line":171,"address":[1435223],"length":1,"stats":{"Line":2}},{"line":173,"address":[934208],"length":1,"stats":{"Line":2}},{"line":174,"address":[1435353],"length":1,"stats":{"Line":2}},{"line":176,"address":[1435559,1435394,1435651],"length":1,"stats":{"Line":8}},{"line":177,"address":[1435705],"length":1,"stats":{"Line":3}},{"line":178,"address":[1435577,1435670],"length":1,"stats":{"Line":6}},{"line":181,"address":[1435569],"length":1,"stats":{"Line":3}},{"line":190,"address":[1435420],"length":1,"stats":{"Line":3}}],"covered":61,"coverable":61},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","workflows.rs"],"content":"//! GitHub Actions workflow rules\n//!\n//! This module provides rules for checking GitHub Actions workflows, including:\n//! - Hardcoded secrets in workflow files\n//! - Explicit permissions configuration\n//! - Pinned action versions for security\n\nuse crate::error::RepoLensError;\nuse regex::Regex;\n\nuse crate::config::Config;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for checking GitHub Actions workflows\npub struct WorkflowsRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for WorkflowsRules {\n    /// Get the category name\n    fn name(&self) -> &'static str {\n        \"workflows\"\n    }\n\n    /// Run all workflow-related rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for workflow issues\n    async fn run(&self, scanner: &Scanner, config: &Config) -> Result<Vec<Finding>, RepoLensError> {\n        let mut findings = Vec::new();\n\n        // Check for workflows directory\n        if !scanner.directory_exists(\".github/workflows\") {\n            return Ok(findings);\n        }\n\n        // Check workflow security\n        if config.is_rule_enabled(\"workflows/secrets\") {\n            findings.extend(check_workflow_secrets(scanner).await?);\n        }\n\n        // Check permissions\n        if config.is_rule_enabled(\"workflows/permissions\") {\n            findings.extend(check_workflow_permissions(scanner).await?);\n        }\n\n        // Check pinned actions\n        if config.is_rule_enabled(\"workflows/pinned-actions\") {\n            findings.extend(check_pinned_actions(scanner, config).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for hardcoded secrets in workflow files\n///\n/// Detects patterns that suggest hardcoded passwords, tokens, API keys,\n/// or secrets in GitHub Actions workflow files.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for hardcoded secrets in workflows\nasync fn check_workflow_secrets(scanner: &Scanner) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    // Patterns that suggest hardcoded secrets in workflows\n    let secret_patterns = [\n        (r#\"password\\s*:\\s*['\"][^'\"]+['\"]\"#, \"hardcoded password\"),\n        (r#\"token\\s*:\\s*['\"][^'\"]+['\"]\"#, \"hardcoded token\"),\n        (r#\"api[_-]?key\\s*:\\s*['\"][^'\"]+['\"]\"#, \"hardcoded API key\"),\n        (r#\"secret\\s*:\\s*['\"][^'\"]+['\"]\"#, \"hardcoded secret\"),\n    ];\n\n    for file in scanner.files_in_directory(\".github/workflows\") {\n        if !file.path.ends_with(\".yml\") && !file.path.ends_with(\".yaml\") {\n            continue;\n        }\n\n        if let Ok(content) = scanner.read_file(&file.path) {\n            for (pattern, description) in &secret_patterns {\n                let regex = match Regex::new(pattern) {\n                    Ok(r) => r,\n                    Err(e) => {\n                        tracing::warn!(\"Invalid regex pattern '{}': {}\", pattern, e);\n                        continue;\n                    }\n                };\n                if regex.is_match(&content) {\n                    // Find line number\n                    let line_num = content\n                        .lines()\n                        .enumerate()\n                        .find(|(_, line)| regex.is_match(line))\n                        .map(|(i, _)| i + 1)\n                        .unwrap_or(0);\n\n                    findings.push(\n                        Finding::new(\n                            \"WF001\",\n                            \"workflows\",\n                            Severity::Critical,\n                            format!(\"Potential {} in workflow\", description),\n                        )\n                        .with_location(format!(\"{}:{}\", file.path, line_num))\n                        .with_description(\"Secrets should never be hardcoded in workflow files.\")\n                        .with_remediation(\n                            \"Use GitHub Secrets (secrets.SECRET_NAME) instead of hardcoded values.\",\n                        ),\n                    );\n                }\n            }\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for explicit permissions in workflow files\n///\n/// Verifies that workflows define explicit permissions to follow\n/// the principle of least privilege.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for missing permissions\nasync fn check_workflow_permissions(scanner: &Scanner) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    for file in scanner.files_in_directory(\".github/workflows\") {\n        if !file.path.ends_with(\".yml\") && !file.path.ends_with(\".yaml\") {\n            continue;\n        }\n\n        if let Ok(content) = scanner.read_file(&file.path) {\n            // Check if permissions are defined\n            if !content.contains(\"permissions:\") {\n                findings.push(\n                    Finding::new(\n                        \"WF002\",\n                        \"workflows\",\n                        Severity::Warning,\n                        \"Workflow missing explicit permissions\",\n                    )\n                    .with_location(&file.path)\n                    .with_description(\n                        \"Workflows without explicit permissions use the default permissions, which may be more permissive than necessary.\"\n                    )\n                    .with_remediation(\n                        \"Add a 'permissions:' block to explicitly define the minimum required permissions.\"\n                    )\n                );\n            }\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for pinned action versions\n///\n/// In strict mode, verifies that actions are pinned to specific versions\n/// instead of using @main, @master, or @latest.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `config` - The configuration (used to check preset)\n///\n/// # Returns\n///\n/// A vector of findings for unpinned actions\nasync fn check_pinned_actions(\n    scanner: &Scanner,\n    config: &Config,\n) -> Result<Vec<Finding>, RepoLensError> {\n    let mut findings = Vec::new();\n\n    // Only check in strict mode\n    if config.preset != \"strict\" {\n        return Ok(findings);\n    }\n\n    let unpinned_patterns = [\n        r\"uses:\\s+\\S+@main\\b\",\n        r\"uses:\\s+\\S+@master\\b\",\n        r\"uses:\\s+\\S+@latest\\b\",\n    ];\n\n    for file in scanner.files_in_directory(\".github/workflows\") {\n        if !file.path.ends_with(\".yml\") && !file.path.ends_with(\".yaml\") {\n            continue;\n        }\n\n        if let Ok(content) = scanner.read_file(&file.path) {\n            for pattern in &unpinned_patterns {\n                let regex = match Regex::new(pattern) {\n                    Ok(r) => r,\n                    Err(e) => {\n                        tracing::warn!(\"Invalid regex pattern '{}': {}\", pattern, e);\n                        continue;\n                    }\n                };\n                for (line_num, line) in content.lines().enumerate() {\n                    if regex.is_match(line) {\n                        findings.push(\n                            Finding::new(\n                                \"WF003\",\n                                \"workflows\",\n                                Severity::Warning,\n                                \"Workflow uses unpinned action reference\",\n                            )\n                            .with_location(format!(\"{}:{}\", file.path, line_num + 1))\n                            .with_description(\n                                \"Using @main, @master, or @latest for actions can introduce breaking changes or security vulnerabilities.\"\n                            )\n                            .with_remediation(\n                                \"Pin actions to a specific version tag (e.g., @v4) or commit SHA for maximum security.\"\n                            )\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::Config;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_workflow_secrets_detects_hardcoded_password() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let workflows_dir = root.join(\".github\").join(\"workflows\");\n        fs::create_dir_all(&workflows_dir).unwrap();\n\n        let workflow_file = workflows_dir.join(\"ci.yml\");\n        fs::write(\n            &workflow_file,\n            \"name: CI\\non: push\\njobs:\\n  test:\\n    password: 'secret123'\",\n        )\n        .unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_workflow_secrets(&scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"WF001\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_workflow_permissions_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let workflows_dir = root.join(\".github\").join(\"workflows\");\n        fs::create_dir_all(&workflows_dir).unwrap();\n\n        let workflow_file = workflows_dir.join(\"ci.yml\");\n        fs::write(\n            &workflow_file,\n            \"name: CI\\non: push\\njobs:\\n  test:\\n    runs-on: ubuntu-latest\",\n        )\n        .unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_workflow_permissions(&scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"WF002\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_pinned_actions_detects_unpinned() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let workflows_dir = root.join(\".github\").join(\"workflows\");\n        fs::create_dir_all(&workflows_dir).unwrap();\n\n        let workflow_file = workflows_dir.join(\"ci.yml\");\n        fs::write(\n            &workflow_file,\n            \"name: CI\\njobs:\\n  test:\\n    uses: actions/checkout@main\",\n        )\n        .unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config {\n            preset: \"strict\".to_string(),\n            ..Default::default()\n        };\n        let findings = check_pinned_actions(&scanner, &config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"WF003\"));\n    }\n}\n","traces":[{"line":22,"address":[671792],"length":1,"stats":{"Line":2}},{"line":36,"address":[1150813,1150035,1151949,1151390,1150000,1150352,1150268,1150130],"length":1,"stats":{"Line":15}},{"line":37,"address":[1150369],"length":1,"stats":{"Line":2}},{"line":40,"address":[1150493,1150414],"length":1,"stats":{"Line":7}},{"line":41,"address":[1150499],"length":1,"stats":{"Line":3}},{"line":45,"address":[491938,491994],"length":1,"stats":{"Line":0}},{"line":46,"address":[286159,286113],"length":1,"stats":{"Line":0}},{"line":50,"address":[1151238,1150672],"length":1,"stats":{"Line":0}},{"line":51,"address":[1151279,1150175,1151396,1152075],"length":1,"stats":{"Line":0}},{"line":55,"address":[1151795,1151244],"length":1,"stats":{"Line":0}},{"line":56,"address":[1151954,1150193,1152080],"length":1,"stats":{"Line":0}},{"line":59,"address":[1151805],"length":1,"stats":{"Line":0}},{"line":75,"address":[486195,482780,482679,482802,482640,485501],"length":1,"stats":{"Line":8}},{"line":76,"address":[1141445],"length":1,"stats":{"Line":2}},{"line":79,"address":[1141745],"length":1,"stats":{"Line":2}},{"line":80,"address":[1141529],"length":1,"stats":{"Line":2}},{"line":81,"address":[1141583],"length":1,"stats":{"Line":2}},{"line":82,"address":[1141637],"length":1,"stats":{"Line":2}},{"line":83,"address":[1141691],"length":1,"stats":{"Line":2}},{"line":86,"address":[1141873,1141956,1144843,1142098],"length":1,"stats":{"Line":8}},{"line":87,"address":[1142161,1142380,1142501],"length":1,"stats":{"Line":6}},{"line":91,"address":[1142614,1142712,1142462],"length":1,"stats":{"Line":6}},{"line":92,"address":[1142760,1142843],"length":1,"stats":{"Line":4}},{"line":93,"address":[1142965,1143087],"length":1,"stats":{"Line":4}},{"line":94,"address":[1143181],"length":1,"stats":{"Line":2}},{"line":95,"address":[1143118],"length":1,"stats":{"Line":0}},{"line":96,"address":[1143150,1144230,1144475],"length":1,"stats":{"Line":0}},{"line":100,"address":[1143332,1143253],"length":1,"stats":{"Line":4}},{"line":102,"address":[1143383],"length":1,"stats":{"Line":2}},{"line":105,"address":[1144912,1144896],"length":1,"stats":{"Line":4}},{"line":106,"address":[1144960,1144964],"length":1,"stats":{"Line":4}},{"line":109,"address":[1144120],"length":1,"stats":{"Line":2}},{"line":110,"address":[1143721,1144050,1144003],"length":1,"stats":{"Line":6}},{"line":113,"address":[1143551],"length":1,"stats":{"Line":2}},{"line":114,"address":[1143621,1143559],"length":1,"stats":{"Line":4}},{"line":116,"address":[1143586,1144042,1144163,1143800,1143819],"length":1,"stats":{"Line":4}},{"line":127,"address":[1142210],"length":1,"stats":{"Line":2}},{"line":142,"address":[487761,486465,487850,486375,486487,486336],"length":1,"stats":{"Line":8}},{"line":143,"address":[1145130],"length":1,"stats":{"Line":2}},{"line":145,"address":[486619,487826,486755,486539],"length":1,"stats":{"Line":8}},{"line":146,"address":[1145694,1145785,1145487],"length":1,"stats":{"Line":6}},{"line":150,"address":[487211,487309,487086],"length":1,"stats":{"Line":6}},{"line":152,"address":[1146100,1146029],"length":1,"stats":{"Line":4}},{"line":153,"address":[1146335],"length":1,"stats":{"Line":2}},{"line":154,"address":[1146145,1146258],"length":1,"stats":{"Line":4}},{"line":157,"address":[1146137],"length":1,"stats":{"Line":2}},{"line":172,"address":[486858],"length":1,"stats":{"Line":2}},{"line":188,"address":[1168304],"length":1,"stats":{"Line":2}},{"line":192,"address":[488049],"length":1,"stats":{"Line":2}},{"line":195,"address":[1146805,1146870],"length":1,"stats":{"Line":4}},{"line":196,"address":[488320],"length":1,"stats":{"Line":0}},{"line":199,"address":[1146884],"length":1,"stats":{"Line":2}},{"line":205,"address":[491270,488449,488293,488591],"length":1,"stats":{"Line":8}},{"line":206,"address":[1147666,1147545,1147326],"length":1,"stats":{"Line":6}},{"line":210,"address":[1147877,1147627,1147779],"length":1,"stats":{"Line":6}},{"line":211,"address":[1148008,1147925],"length":1,"stats":{"Line":4}},{"line":212,"address":[1148108,1148230],"length":1,"stats":{"Line":4}},{"line":213,"address":[1148321],"length":1,"stats":{"Line":2}},{"line":214,"address":[489589],"length":1,"stats":{"Line":0}},{"line":215,"address":[1149574,1149329,1148293],"length":1,"stats":{"Line":0}},{"line":219,"address":[489800,489721],"length":1,"stats":{"Line":4}},{"line":220,"address":[1148678,1148715],"length":1,"stats":{"Line":4}},{"line":221,"address":[1149222],"length":1,"stats":{"Line":2}},{"line":222,"address":[1149152,1149105,1148732],"length":1,"stats":{"Line":6}},{"line":225,"address":[1148724],"length":1,"stats":{"Line":2}},{"line":228,"address":[1148802,1149144,1149265,1148872,1148853],"length":1,"stats":{"Line":4}},{"line":242,"address":[1147367],"length":1,"stats":{"Line":2}}],"covered":55,"coverable":67},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","engine.rs"],"content":"//! Rules evaluation engine\n\nuse crate::error::RepoLensError;\nuse tracing::{debug, info, span, Level};\n\nuse super::categories::{\n    custom::CustomRules, docs::DocsRules, files::FilesRules, quality::QualityRules,\n    secrets::SecretsRules, security::SecurityRules, workflows::WorkflowsRules,\n};\nuse super::results::AuditResults;\nuse crate::config::Config;\nuse crate::scanner::Scanner;\n\n/// Trait for rule categories\n#[async_trait::async_trait]\npub trait RuleCategory: Send + Sync {\n    /// Get the category name\n    fn name(&self) -> &'static str;\n\n    /// Run the rules in this category\n    async fn run(\n        &self,\n        scanner: &Scanner,\n        config: &Config,\n    ) -> Result<Vec<super::Finding>, RepoLensError>;\n}\n\n/// Main rules evaluation engine\npub struct RulesEngine {\n    config: Config,\n    only_categories: Option<Vec<String>>,\n    skip_categories: Option<Vec<String>>,\n}\n\nimpl RulesEngine {\n    /// Create a new rules engine with the given configuration\n    pub fn new(config: Config) -> Self {\n        Self {\n            config,\n            only_categories: None,\n            skip_categories: None,\n        }\n    }\n\n    /// Set categories to exclusively run\n    pub fn set_only_categories(&mut self, categories: Vec<String>) {\n        self.only_categories = Some(categories);\n    }\n\n    /// Set categories to skip\n    pub fn set_skip_categories(&mut self, categories: Vec<String>) {\n        self.skip_categories = Some(categories);\n    }\n\n    /// Check if a category should be run\n    fn should_run_category(&self, category: &str) -> bool {\n        if let Some(only) = &self.only_categories {\n            return only.iter().any(|c| c == category);\n        }\n\n        if let Some(skip) = &self.skip_categories {\n            return !skip.iter().any(|c| c == category);\n        }\n\n        true\n    }\n\n    /// Run all enabled rules and return results\n    pub async fn run(&self, scanner: &Scanner) -> Result<AuditResults, RepoLensError> {\n        info!(\"Starting audit with preset: {}\", self.config.preset);\n\n        let repo_name = scanner.repository_name();\n        let repo_name_ref = &repo_name;\n        let mut results = AuditResults::new(repo_name.clone(), &self.config.preset);\n\n        // Get all rule categories\n        let categories: Vec<Box<dyn RuleCategory>> = vec![\n            Box::new(SecretsRules),\n            Box::new(FilesRules),\n            Box::new(DocsRules),\n            Box::new(SecurityRules),\n            Box::new(WorkflowsRules),\n            Box::new(QualityRules),\n            Box::new(CustomRules),\n        ];\n\n        // Run each category\n        for category in categories {\n            let category_name = category.name();\n\n            if !self.should_run_category(category_name) {\n                debug!(category = category_name, \"Skipping category\");\n                continue;\n            }\n\n            let span = span!(Level::INFO, \"category\", category = category_name, repository = %repo_name_ref);\n            let _guard = span.enter();\n\n            debug!(category = category_name, \"Running category\");\n\n            match category.run(scanner, &self.config).await {\n                Ok(findings) => {\n                    let count = findings.len();\n                    debug!(\n                        category = category_name,\n                        findings_count = count,\n                        \"Category completed\"\n                    );\n                    results.add_findings(findings);\n                }\n                Err(e) => {\n                    tracing::warn!(\n                        category = category_name,\n                        error = %e,\n                        \"Error running category\"\n                    );\n                }\n            }\n        }\n\n        info!(\n            \"Audit complete: {} critical, {} warnings, {} info\",\n            results.count_by_severity(super::Severity::Critical),\n            results.count_by_severity(super::Severity::Warning),\n            results.count_by_severity(super::Severity::Info),\n        );\n\n        Ok(results)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_rules_engine_runs_all_categories() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Create a basic file structure\n        fs::write(root.join(\"README.md\"), \"# Test Project\").unwrap();\n\n        let config = Config::default();\n        let scanner = Scanner::new(root.to_path_buf());\n        let engine = RulesEngine::new(config);\n\n        let results = engine.run(&scanner).await.unwrap();\n\n        // Verify that results are returned (may be empty if no issues found)\n        let _ = results.findings().len();\n        assert_eq!(results.preset, \"opensource\");\n    }\n\n    #[tokio::test]\n    async fn test_rules_engine_filters_with_only() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        fs::write(root.join(\"README.md\"), \"# Test\").unwrap();\n\n        let config = Config::default();\n        let scanner = Scanner::new(root.to_path_buf());\n        let mut engine = RulesEngine::new(config);\n        engine.set_only_categories(vec![\"secrets\".to_string()]);\n\n        let results = engine.run(&scanner).await.unwrap();\n\n        // Verify that only secrets category was run\n        // All findings should be from secrets category\n        for finding in results.findings() {\n            assert_eq!(finding.category, \"secrets\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_rules_engine_filters_with_skip() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        fs::write(root.join(\"README.md\"), \"# Test\").unwrap();\n\n        let config = Config::default();\n        let scanner = Scanner::new(root.to_path_buf());\n        let mut engine = RulesEngine::new(config);\n        engine.set_skip_categories(vec![\"secrets\".to_string()]);\n\n        let results = engine.run(&scanner).await.unwrap();\n\n        // Verify that secrets category was skipped\n        for finding in results.findings() {\n            assert_ne!(finding.category, \"secrets\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_rules_engine_handles_category_errors_gracefully() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Create a file that might cause issues\n        fs::write(root.join(\"test.txt\"), \"test\").unwrap();\n\n        let config = Config::default();\n        let scanner = Scanner::new(root.to_path_buf());\n        let engine = RulesEngine::new(config);\n\n        // Should not panic even if a category fails\n        let results = engine.run(&scanner).await;\n        assert!(results.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_rules_engine_collects_all_findings() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Create files that should trigger findings\n        fs::write(\n            root.join(\"test.js\"),\n            \"const apiKey = 'sk_test_1234567890abcdef';\",\n        )\n        .unwrap();\n\n        let config = Config::default();\n        let scanner = Scanner::new(root.to_path_buf());\n        let engine = RulesEngine::new(config);\n\n        let results = engine.run(&scanner).await.unwrap();\n\n        // Should have collected findings from multiple categories\n        // (at least secrets should find something)\n        let _ = results.findings().len();\n    }\n\n    #[test]\n    fn test_should_run_category_with_only() {\n        let config = Config::default();\n        let mut engine = RulesEngine::new(config);\n        engine.set_only_categories(vec![\"secrets\".to_string(), \"files\".to_string()]);\n\n        assert!(engine.should_run_category(\"secrets\"));\n        assert!(engine.should_run_category(\"files\"));\n        assert!(!engine.should_run_category(\"docs\"));\n    }\n\n    #[test]\n    fn test_should_run_category_with_skip() {\n        let config = Config::default();\n        let mut engine = RulesEngine::new(config);\n        engine.set_skip_categories(vec![\"secrets\".to_string()]);\n\n        assert!(!engine.should_run_category(\"secrets\"));\n        assert!(engine.should_run_category(\"files\"));\n        assert!(engine.should_run_category(\"docs\"));\n    }\n\n    #[test]\n    fn test_should_run_category_default() {\n        let config = Config::default();\n        let engine = RulesEngine::new(config);\n\n        // By default, all categories should run\n        assert!(engine.should_run_category(\"secrets\"));\n        assert!(engine.should_run_category(\"files\"));\n        assert!(engine.should_run_category(\"docs\"));\n    }\n}\n","traces":[{"line":37,"address":[1198816],"length":1,"stats":{"Line":3}},{"line":46,"address":[1198960,1199046],"length":1,"stats":{"Line":2}},{"line":47,"address":[1199077,1198974],"length":1,"stats":{"Line":4}},{"line":51,"address":[1199120,1199206],"length":1,"stats":{"Line":2}},{"line":52,"address":[1199134,1199237],"length":1,"stats":{"Line":4}},{"line":56,"address":[1199280],"length":1,"stats":{"Line":2}},{"line":57,"address":[1199304],"length":1,"stats":{"Line":2}},{"line":58,"address":[1199364],"length":1,"stats":{"Line":6}},{"line":61,"address":[1199420,1199486],"length":1,"stats":{"Line":4}},{"line":62,"address":[1199491],"length":1,"stats":{"Line":6}},{"line":65,"address":[1199544],"length":1,"stats":{"Line":2}},{"line":69,"address":[893759,893712,893934,895787,893891,895776],"length":1,"stats":{"Line":10}},{"line":70,"address":[1185287,1185415,1185706],"length":1,"stats":{"Line":6}},{"line":72,"address":[1185680],"length":1,"stats":{"Line":3}},{"line":73,"address":[1185992],"length":1,"stats":{"Line":3}},{"line":74,"address":[1186090,1186011],"length":1,"stats":{"Line":6}},{"line":77,"address":[895303,895782,894971,895137,895220,894888,895054,894802,894771,894707,895332],"length":1,"stats":{"Line":11}},{"line":78,"address":[1186203,1186266],"length":1,"stats":{"Line":10}},{"line":79,"address":[894865,894925],"length":1,"stats":{"Line":9}},{"line":80,"address":[1186432,1186372],"length":1,"stats":{"Line":10}},{"line":81,"address":[895031,895091],"length":1,"stats":{"Line":10}},{"line":82,"address":[1186538,1186598],"length":1,"stats":{"Line":10}},{"line":83,"address":[1186681,1186621],"length":1,"stats":{"Line":10}},{"line":84,"address":[895280],"length":1,"stats":{"Line":6}},{"line":88,"address":[1187067,1187142,1189565],"length":1,"stats":{"Line":17}},{"line":89,"address":[1190835,1189646],"length":1,"stats":{"Line":8}},{"line":91,"address":[1190842],"length":1,"stats":{"Line":3}},{"line":92,"address":[899523,899813,899471],"length":1,"stats":{"Line":4}},{"line":96,"address":[1190923,1191544,1191961],"length":1,"stats":{"Line":7}},{"line":97,"address":[900488,900868],"length":1,"stats":{"Line":7}},{"line":99,"address":[1192372,1192295,1192646],"length":1,"stats":{"Line":8}},{"line":101,"address":[303143],"length":1,"stats":{"Line":17}},{"line":102,"address":[896229],"length":1,"stats":{"Line":3}},{"line":103,"address":[1187765,1187701],"length":1,"stats":{"Line":5}},{"line":104,"address":[1188143,1187773],"length":1,"stats":{"Line":3}},{"line":109,"address":[1188073],"length":1,"stats":{"Line":2}},{"line":111,"address":[1187574],"length":1,"stats":{"Line":0}},{"line":112,"address":[1188641,1187622,1188924],"length":1,"stats":{"Line":0}},{"line":121,"address":[1190340],"length":1,"stats":{"Line":1}},{"line":128,"address":[1190032],"length":1,"stats":{"Line":2}}],"covered":38,"coverable":40},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","mod.rs"],"content":"//! Rules module - Audit rules and evaluation engine\n\npub mod categories;\npub mod engine;\npub mod patterns;\npub mod results;\n\npub use results::{Finding, Severity};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","patterns","mod.rs"],"content":"//! Pattern definitions for secret detection\n\nmod secrets;\n\npub use secrets::SECRET_PATTERNS;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","patterns","secrets.rs"],"content":"//! Secret detection patterns\n\nuse lazy_static::lazy_static;\nuse regex::Regex;\n\n/// A pattern for detecting secrets\npub struct SecretPattern {\n    pub name: &'static str,\n    pub description: &'static str,\n    pub regex: Regex,\n}\n\nlazy_static! {\n    /// Collection of secret patterns to detect\n    pub static ref SECRET_PATTERNS: Vec<SecretPattern> = vec![\n        // GitHub tokens\n        SecretPattern {\n            name: \"GitHub Personal Access Token\",\n            description: \"GitHub personal access tokens start with 'ghp_'\",\n            regex: Regex::new(r\"ghp_[A-Za-z0-9]{36}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"GitHub OAuth Token\",\n            description: \"GitHub OAuth tokens start with 'gho_'\",\n            regex: Regex::new(r\"gho_[A-Za-z0-9]{36}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"GitHub User-to-Server Token\",\n            description: \"GitHub user-to-server tokens start with 'ghu_'\",\n            regex: Regex::new(r\"ghu_[A-Za-z0-9]{36}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"GitHub Server-to-Server Token\",\n            description: \"GitHub server-to-server tokens start with 'ghs_'\",\n            regex: Regex::new(r\"ghs_[A-Za-z0-9]{36}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"GitHub Refresh Token\",\n            description: \"GitHub refresh tokens start with 'ghr_'\",\n            regex: Regex::new(r\"ghr_[A-Za-z0-9]{36}\").unwrap(),\n        },\n\n        // AWS\n        SecretPattern {\n            name: \"AWS Access Key ID\",\n            description: \"AWS access keys start with 'AKIA'\",\n            regex: Regex::new(r\"AKIA[0-9A-Z]{16}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"AWS Secret Access Key\",\n            description: \"AWS secret access keys are 40 character strings\",\n            regex: Regex::new(r#\"(?i)(aws_secret_access_key|aws_secret_key)\\s*[=:]\\s*['\"]?[A-Za-z0-9/+=]{40}['\"]?\"#).unwrap(),\n        },\n\n        // Stripe\n        SecretPattern {\n            name: \"Stripe Live Secret Key\",\n            description: \"Stripe live secret keys start with 'sk_live_'\",\n            regex: Regex::new(r\"sk_live_[0-9a-zA-Z]{24,}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"Stripe Test Secret Key\",\n            description: \"Stripe test secret keys start with 'sk_test_'\",\n            regex: Regex::new(r\"sk_test_[0-9a-zA-Z]{24,}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"Stripe Restricted Key\",\n            description: \"Stripe restricted keys start with 'rk_live_' or 'rk_test_'\",\n            regex: Regex::new(r\"rk_(live|test)_[0-9a-zA-Z]{24,}\").unwrap(),\n        },\n\n        // Slack\n        SecretPattern {\n            name: \"Slack Token\",\n            description: \"Slack tokens start with 'xox'\",\n            regex: Regex::new(r\"xox[baprs]-[0-9a-zA-Z-]{10,48}\").unwrap(),\n        },\n\n        // Google\n        SecretPattern {\n            name: \"Google API Key\",\n            description: \"Google API keys start with 'AIza'\",\n            regex: Regex::new(r\"AIza[0-9A-Za-z\\-_]{35}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"Google OAuth Token\",\n            description: \"Google OAuth tokens start with 'ya29.'\",\n            regex: Regex::new(r\"ya29\\.[0-9A-Za-z\\-_]+\").unwrap(),\n        },\n\n        // Firebase\n        SecretPattern {\n            name: \"Firebase Cloud Messaging\",\n            description: \"Firebase server keys\",\n            regex: Regex::new(r\"AAAA[A-Za-z0-9_-]{7}:[A-Za-z0-9_-]{140}\").unwrap(),\n        },\n\n        // Twilio\n        SecretPattern {\n            name: \"Twilio API Key\",\n            description: \"Twilio API keys start with 'SK'\",\n            regex: Regex::new(r\"SK[0-9a-fA-F]{32}\").unwrap(),\n        },\n\n        // SendGrid\n        SecretPattern {\n            name: \"SendGrid API Key\",\n            description: \"SendGrid API keys start with 'SG.'\",\n            regex: Regex::new(r\"SG\\.[0-9A-Za-z\\-_]{22}\\.[0-9A-Za-z\\-_]{43}\").unwrap(),\n        },\n\n        // Mailgun\n        SecretPattern {\n            name: \"Mailgun API Key\",\n            description: \"Mailgun API keys start with 'key-'\",\n            regex: Regex::new(r\"key-[0-9a-zA-Z]{32}\").unwrap(),\n        },\n\n        // npm\n        SecretPattern {\n            name: \"npm Token\",\n            description: \"npm tokens start with 'npm_'\",\n            regex: Regex::new(r\"npm_[A-Za-z0-9]{36}\").unwrap(),\n        },\n\n        // Discord\n        SecretPattern {\n            name: \"Discord Token\",\n            description: \"Discord bot tokens\",\n            regex: Regex::new(r\"[MN][A-Za-z\\d]{23,}\\.[\\w-]{6}\\.[\\w-]{27}\").unwrap(),\n        },\n\n        // Generic patterns\n        SecretPattern {\n            name: \"Private Key\",\n            description: \"PEM encoded private key\",\n            regex: Regex::new(r\"-----BEGIN (RSA|DSA|EC|OPENSSH) PRIVATE KEY-----\").unwrap(),\n        },\n        SecretPattern {\n            name: \"JWT Token\",\n            description: \"JSON Web Token\",\n            regex: Regex::new(r\"eyJ[A-Za-z0-9-_=]+\\.eyJ[A-Za-z0-9-_=]+\\.[A-Za-z0-9-_.+/=]+\").unwrap(),\n        },\n\n        // Database connection strings\n        SecretPattern {\n            name: \"MongoDB Connection String\",\n            description: \"MongoDB connection string with credentials\",\n            regex: Regex::new(r\"mongodb(\\+srv)?://[^:]+:[^@]+@\").unwrap(),\n        },\n        SecretPattern {\n            name: \"PostgreSQL Connection String\",\n            description: \"PostgreSQL connection string with credentials\",\n            regex: Regex::new(r\"postgres(ql)?://[^:]+:[^@]+@\").unwrap(),\n        },\n        SecretPattern {\n            name: \"MySQL Connection String\",\n            description: \"MySQL connection string with credentials\",\n            regex: Regex::new(r\"mysql://[^:]+:[^@]+@\").unwrap(),\n        },\n        SecretPattern {\n            name: \"Redis Connection String\",\n            description: \"Redis connection string with credentials\",\n            regex: Regex::new(r\"redis://[^:]+:[^@]+@\").unwrap(),\n        },\n\n        // Generic credential patterns\n        SecretPattern {\n            name: \"Generic Password Assignment\",\n            description: \"Password assigned in code\",\n            regex: Regex::new(r#\"(?i)(password|passwd|pwd)\\s*[=:]\\s*['\"][^'\"]{8,}['\"]\"#).unwrap(),\n        },\n        SecretPattern {\n            name: \"Generic API Key Assignment\",\n            description: \"API key assigned in code\",\n            regex: Regex::new(r#\"(?i)(api[_-]?key|apikey)\\s*[=:]\\s*['\"][^'\"]{16,}['\"]\"#).unwrap(),\n        },\n        SecretPattern {\n            name: \"Generic Secret Assignment\",\n            description: \"Secret assigned in code\",\n            regex: Regex::new(r#\"(?i)(secret[_-]?key|secretkey)\\s*[=:]\\s*['\"][^'\"]{16,}['\"]\"#).unwrap(),\n        },\n        SecretPattern {\n            name: \"Generic Token Assignment\",\n            description: \"Token assigned in code\",\n            regex: Regex::new(r#\"(?i)(access[_-]?token|auth[_-]?token)\\s*[=:]\\s*['\"][^'\"]{16,}['\"]\"#).unwrap(),\n        },\n\n        // URL with credentials\n        SecretPattern {\n            name: \"URL with Embedded Credentials\",\n            description: \"URL containing username:password\",\n            regex: Regex::new(r\"https?://[^:]+:[^@]+@[^/]+\").unwrap(),\n        },\n    ];\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_github_token_detection() {\n        let pattern = &SECRET_PATTERNS[0]; // GitHub PAT\n        assert!(pattern\n            .regex\n            .is_match(\"ghp_abcdefghijklmnopqrstuvwxyz1234567890\"));\n        assert!(!pattern.regex.is_match(\"ghp_short\"));\n    }\n\n    #[test]\n    fn test_aws_key_detection() {\n        let pattern = &SECRET_PATTERNS[5]; // AWS Access Key\n        assert!(pattern.regex.is_match(\"AKIAIOSFODNN7EXAMPLE\"));\n        assert!(!pattern.regex.is_match(\"NOTANAWSKEY12345678\"));\n    }\n\n    #[test]\n    fn test_stripe_key_detection() {\n        let pattern = &SECRET_PATTERNS[7]; // Stripe Live Key\n        assert!(pattern.regex.is_match(\"sk_live_abcdefghijklmnopqrstuvwx\"));\n        assert!(!pattern.regex.is_match(\"sk_live_short\"));\n    }\n}\n","traces":[{"line":15,"address":[144268,145577,140745,143520,143146,142398,146138,142585,145951,145764,140902,141276,144829,144081,141837,145016,146318,147306,141089,143707,143894,142772,142024,144642,143333,145203,144455,142211,140699,142959,141650,145390,141463],"length":1,"stats":{"Line":4}},{"line":17,"address":[140804],"length":1,"stats":{"Line":2}},{"line":20,"address":[1522521,1522453],"length":1,"stats":{"Line":4}},{"line":22,"address":[1522708],"length":1,"stats":{"Line":2}},{"line":25,"address":[1522610,1522678],"length":1,"stats":{"Line":4}},{"line":27,"address":[1522895],"length":1,"stats":{"Line":2}},{"line":30,"address":[1522865,1522794],"length":1,"stats":{"Line":4}},{"line":32,"address":[1523082],"length":1,"stats":{"Line":2}},{"line":35,"address":[141237,141308],"length":1,"stats":{"Line":4}},{"line":37,"address":[1523269],"length":1,"stats":{"Line":2}},{"line":40,"address":[141424,141495],"length":1,"stats":{"Line":4}},{"line":44,"address":[1523456],"length":1,"stats":{"Line":2}},{"line":47,"address":[1523426,1523355],"length":1,"stats":{"Line":4}},{"line":49,"address":[1523643],"length":1,"stats":{"Line":2}},{"line":52,"address":[1523542,1523613],"length":1,"stats":{"Line":4}},{"line":56,"address":[1523830],"length":1,"stats":{"Line":2}},{"line":59,"address":[1523729,1523800],"length":1,"stats":{"Line":4}},{"line":61,"address":[1524017],"length":1,"stats":{"Line":2}},{"line":64,"address":[1523987,1523916],"length":1,"stats":{"Line":4}},{"line":66,"address":[1524204],"length":1,"stats":{"Line":2}},{"line":69,"address":[1524103,1524174],"length":1,"stats":{"Line":4}},{"line":73,"address":[1524391],"length":1,"stats":{"Line":2}},{"line":76,"address":[1524290,1524361],"length":1,"stats":{"Line":4}},{"line":80,"address":[1524578],"length":1,"stats":{"Line":2}},{"line":83,"address":[1524548,1524477],"length":1,"stats":{"Line":4}},{"line":85,"address":[1524765],"length":1,"stats":{"Line":2}},{"line":88,"address":[1524664,1524735],"length":1,"stats":{"Line":4}},{"line":92,"address":[1524952],"length":1,"stats":{"Line":2}},{"line":95,"address":[1524922,1524851],"length":1,"stats":{"Line":4}},{"line":99,"address":[1525139],"length":1,"stats":{"Line":2}},{"line":102,"address":[1525038,1525109],"length":1,"stats":{"Line":4}},{"line":106,"address":[1525326],"length":1,"stats":{"Line":2}},{"line":109,"address":[1525296,1525225],"length":1,"stats":{"Line":4}},{"line":113,"address":[1525513],"length":1,"stats":{"Line":2}},{"line":116,"address":[1525412,1525483],"length":1,"stats":{"Line":4}},{"line":120,"address":[1525700],"length":1,"stats":{"Line":2}},{"line":123,"address":[1525599,1525670],"length":1,"stats":{"Line":4}},{"line":127,"address":[1525887],"length":1,"stats":{"Line":2}},{"line":130,"address":[1525786,1525857],"length":1,"stats":{"Line":4}},{"line":134,"address":[1526074],"length":1,"stats":{"Line":2}},{"line":137,"address":[144229,144300],"length":1,"stats":{"Line":4}},{"line":139,"address":[1526261],"length":1,"stats":{"Line":2}},{"line":142,"address":[144416,144487],"length":1,"stats":{"Line":4}},{"line":146,"address":[1526448],"length":1,"stats":{"Line":2}},{"line":149,"address":[1526347,1526418],"length":1,"stats":{"Line":4}},{"line":151,"address":[1526635],"length":1,"stats":{"Line":2}},{"line":154,"address":[1526534,1526605],"length":1,"stats":{"Line":4}},{"line":156,"address":[1526822],"length":1,"stats":{"Line":2}},{"line":159,"address":[145048,144977],"length":1,"stats":{"Line":4}},{"line":161,"address":[1527009],"length":1,"stats":{"Line":2}},{"line":164,"address":[1526908,1526979],"length":1,"stats":{"Line":4}},{"line":168,"address":[1527196],"length":1,"stats":{"Line":2}},{"line":171,"address":[145422,145351],"length":1,"stats":{"Line":4}},{"line":173,"address":[1527383],"length":1,"stats":{"Line":2}},{"line":176,"address":[145538,145609],"length":1,"stats":{"Line":4}},{"line":178,"address":[1527570],"length":1,"stats":{"Line":2}},{"line":181,"address":[1527540,1527469],"length":1,"stats":{"Line":4}},{"line":183,"address":[1527757],"length":1,"stats":{"Line":2}},{"line":186,"address":[1527727,1527656],"length":1,"stats":{"Line":4}},{"line":190,"address":[1527944],"length":1,"stats":{"Line":2}},{"line":193,"address":[1527914,1527843],"length":1,"stats":{"Line":4}}],"covered":61,"coverable":61},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","results.rs"],"content":"//! Audit results structures\n\nuse serde::{Deserialize, Serialize};\n\n/// Severity levels for findings\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum Severity {\n    /// Critical issues that must be resolved\n    Critical,\n    /// Warnings that should be addressed\n    Warning,\n    /// Informational suggestions\n    Info,\n}\n\nimpl Severity {\n    #[allow(dead_code)]\n    pub fn from_string(s: &str) -> Option<Self> {\n        match s.to_lowercase().as_str() {\n            \"critical\" | \"error\" => Some(Self::Critical),\n            \"warning\" | \"warn\" => Some(Self::Warning),\n            \"info\" | \"information\" | \"note\" => Some(Self::Info),\n            _ => None,\n        }\n    }\n}\n\n/// A single audit finding\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Finding {\n    /// Unique rule identifier (e.g., \"SEC001\")\n    pub rule_id: String,\n\n    /// Category of the rule (e.g., \"secrets\", \"docs\")\n    pub category: String,\n\n    /// Severity of the finding\n    pub severity: Severity,\n\n    /// Short message describing the finding\n    pub message: String,\n\n    /// Optional file location (e.g., \"src/config.ts:42\")\n    pub location: Option<String>,\n\n    /// Detailed description of the issue\n    pub description: Option<String>,\n\n    /// Suggested remediation steps\n    pub remediation: Option<String>,\n}\n\nimpl Finding {\n    /// Create a new finding\n    pub fn new(\n        rule_id: impl Into<String>,\n        category: impl Into<String>,\n        severity: Severity,\n        message: impl Into<String>,\n    ) -> Self {\n        Self {\n            rule_id: rule_id.into(),\n            category: category.into(),\n            severity,\n            message: message.into(),\n            location: None,\n            description: None,\n            remediation: None,\n        }\n    }\n\n    /// Set the location\n    pub fn with_location(mut self, location: impl Into<String>) -> Self {\n        self.location = Some(location.into());\n        self\n    }\n\n    /// Set the description\n    pub fn with_description(mut self, description: impl Into<String>) -> Self {\n        self.description = Some(description.into());\n        self\n    }\n\n    /// Set the remediation\n    pub fn with_remediation(mut self, remediation: impl Into<String>) -> Self {\n        self.remediation = Some(remediation.into());\n        self\n    }\n}\n\n/// Collection of audit results\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AuditResults {\n    /// Repository name\n    pub repository_name: String,\n\n    /// Preset used for the audit\n    pub preset: String,\n\n    /// List of findings\n    findings: Vec<Finding>,\n}\n\nimpl AuditResults {\n    /// Create new audit results\n    pub fn new(repository_name: impl Into<String>, preset: impl Into<String>) -> Self {\n        Self {\n            repository_name: repository_name.into(),\n            preset: preset.into(),\n            findings: Vec::new(),\n        }\n    }\n\n    /// Add a finding\n    #[allow(dead_code)]\n    pub fn add_finding(&mut self, finding: Finding) {\n        self.findings.push(finding);\n    }\n\n    /// Add multiple findings\n    pub fn add_findings(&mut self, findings: impl IntoIterator<Item = Finding>) {\n        self.findings.extend(findings);\n    }\n\n    /// Get all findings\n    pub fn findings(&self) -> &[Finding] {\n        &self.findings\n    }\n\n    /// Get findings by severity\n    pub fn findings_by_severity(&self, severity: Severity) -> impl Iterator<Item = &Finding> {\n        self.findings.iter().filter(move |f| f.severity == severity)\n    }\n\n    /// Get findings by category\n    pub fn findings_by_category<'a>(\n        &'a self,\n        category: &'a str,\n    ) -> impl Iterator<Item = &'a Finding> {\n        self.findings.iter().filter(move |f| f.category == category)\n    }\n\n    /// Count findings by severity\n    pub fn count_by_severity(&self, severity: Severity) -> usize {\n        self.findings\n            .iter()\n            .filter(|f| f.severity == severity)\n            .count()\n    }\n\n    /// Check if there are any critical findings\n    pub fn has_critical(&self) -> bool {\n        self.findings\n            .iter()\n            .any(|f| f.severity == Severity::Critical)\n    }\n\n    /// Check if there are any warnings\n    pub fn has_warnings(&self) -> bool {\n        self.findings\n            .iter()\n            .any(|f| f.severity == Severity::Warning)\n    }\n\n    /// Get total number of findings\n    #[allow(dead_code)]\n    pub fn total_count(&self) -> usize {\n        self.findings.len()\n    }\n\n    /// Check if there are no findings\n    #[allow(dead_code)]\n    pub fn is_clean(&self) -> bool {\n        self.findings.is_empty()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_finding_builder() {\n        let finding = Finding::new(\"SEC001\", \"secrets\", Severity::Critical, \"Secret detected\")\n            .with_location(\"src/config.ts:42\")\n            .with_description(\"A hardcoded secret was found\")\n            .with_remediation(\"Move the secret to environment variables\");\n\n        assert_eq!(finding.rule_id, \"SEC001\");\n        assert_eq!(finding.location, Some(\"src/config.ts:42\".to_string()));\n    }\n\n    #[test]\n    fn test_audit_results() {\n        let mut results = AuditResults::new(\"test-repo\", \"opensource\");\n\n        results.add_finding(Finding::new(\n            \"SEC001\",\n            \"secrets\",\n            Severity::Critical,\n            \"Secret found\",\n        ));\n        results.add_finding(Finding::new(\n            \"DOC001\",\n            \"docs\",\n            Severity::Warning,\n            \"README missing\",\n        ));\n\n        assert_eq!(results.total_count(), 2);\n        assert!(results.has_critical());\n        assert!(results.has_warnings());\n        assert_eq!(results.count_by_severity(Severity::Critical), 1);\n    }\n}\n","traces":[{"line":19,"address":[1074104,1074098,1073600],"length":1,"stats":{"Line":0}},{"line":20,"address":[1073623,1073712],"length":1,"stats":{"Line":0}},{"line":21,"address":[1073728],"length":1,"stats":{"Line":0}},{"line":22,"address":[1073832],"length":1,"stats":{"Line":0}},{"line":23,"address":[1073936],"length":1,"stats":{"Line":0}},{"line":24,"address":[1074070],"length":1,"stats":{"Line":0}},{"line":56,"address":[1098476,1098496,1097104,1097808,1097746,1097780],"length":1,"stats":{"Line":10}},{"line":63,"address":[],"length":0,"stats":{"Line":10}},{"line":64,"address":[],"length":0,"stats":{"Line":10}},{"line":66,"address":[418442,419197],"length":1,"stats":{"Line":10}},{"line":74,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[420163,420222,419642,419704,419902,419961],"length":1,"stats":{"Line":12}},{"line":76,"address":[1098757,1099011,1099272],"length":1,"stats":{"Line":8}},{"line":80,"address":[420384,420615,420908,420640],"length":1,"stats":{"Line":4}},{"line":81,"address":[420698,420473,420414,420760],"length":1,"stats":{"Line":8}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":87,"address":[420958,421017,421258,421320],"length":1,"stats":{"Line":8}},{"line":88,"address":[1100113,1100383],"length":1,"stats":{"Line":4}},{"line":107,"address":[421504,421855,421888,422196,421861],"length":1,"stats":{"Line":10}},{"line":109,"address":[],"length":0,"stats":{"Line":13}},{"line":110,"address":[421988,421641],"length":1,"stats":{"Line":11}},{"line":111,"address":[1100976,1100600],"length":1,"stats":{"Line":13}},{"line":117,"address":[1074128],"length":1,"stats":{"Line":8}},{"line":118,"address":[1074133],"length":1,"stats":{"Line":8}},{"line":122,"address":[422224],"length":1,"stats":{"Line":3}},{"line":123,"address":[422229],"length":1,"stats":{"Line":3}},{"line":127,"address":[1292448],"length":1,"stats":{"Line":2}},{"line":128,"address":[1292453],"length":1,"stats":{"Line":2}},{"line":132,"address":[1292464],"length":1,"stats":{"Line":0}},{"line":133,"address":[1101184,1101204],"length":1,"stats":{"Line":0}},{"line":137,"address":[1074272],"length":1,"stats":{"Line":8}},{"line":141,"address":[1074324],"length":1,"stats":{"Line":24}},{"line":145,"address":[1074384],"length":1,"stats":{"Line":2}},{"line":146,"address":[1074400],"length":1,"stats":{"Line":2}},{"line":148,"address":[422369,422352],"length":1,"stats":{"Line":4}},{"line":153,"address":[1074464],"length":1,"stats":{"Line":2}},{"line":154,"address":[1074473],"length":1,"stats":{"Line":2}},{"line":156,"address":[422400,422425],"length":1,"stats":{"Line":4}},{"line":160,"address":[1074528],"length":1,"stats":{"Line":2}},{"line":161,"address":[1074537],"length":1,"stats":{"Line":2}},{"line":163,"address":[422464,422489],"length":1,"stats":{"Line":4}},{"line":168,"address":[1074592],"length":1,"stats":{"Line":2}},{"line":169,"address":[1074597],"length":1,"stats":{"Line":2}},{"line":174,"address":[1074608],"length":1,"stats":{"Line":0}},{"line":175,"address":[1074613],"length":1,"stats":{"Line":0}}],"covered":36,"coverable":46},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","scanner","filesystem.rs"],"content":"//! File system scanning utilities\n\nuse ignore::WalkBuilder;\nuse rayon::prelude::*;\nuse std::path::Path;\n\n/// Information about a file in the repository\n#[derive(Debug, Clone)]\npub struct FileInfo {\n    /// Relative path from repository root\n    pub path: String,\n    /// File size in bytes\n    pub size: u64,\n    /// Whether the file is a directory\n    #[allow(dead_code)]\n    pub is_dir: bool,\n}\n\n/// Scan a directory and return information about all files\n///\n/// Uses parallel processing for better performance on large repositories.\npub fn scan_directory(root: &Path) -> Vec<FileInfo> {\n    let walker = WalkBuilder::new(root)\n        .hidden(false)\n        .git_ignore(true)\n        .git_global(true)\n        .git_exclude(true)\n        .ignore(true)\n        .parents(true)\n        .build();\n\n    walker\n        .into_iter()\n        .par_bridge()\n        .filter_map(|entry_result| {\n            let entry = entry_result.ok()?;\n            let path = entry.path();\n\n            // Skip the root directory itself\n            if path == root {\n                return None;\n            }\n\n            // Skip .git directory\n            if path.components().any(|c| c.as_os_str() == \".git\") {\n                return None;\n            }\n\n            // Get relative path - handle errors gracefully\n            let relative_path = match path.strip_prefix(root) {\n                Ok(stripped) => stripped\n                    .to_str()\n                    .map(|s| s.to_string())\n                    .unwrap_or_else(|| stripped.to_string_lossy().to_string()),\n                Err(_) => {\n                    return None;\n                }\n            };\n\n            if relative_path.is_empty() {\n                return None;\n            }\n\n            // Get file metadata\n            let metadata = entry.metadata().ok()?;\n\n            Some(FileInfo {\n                path: relative_path,\n                size: metadata.len(),\n                is_dir: metadata.is_dir(),\n            })\n        })\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_scan_directory() {\n        let dir = tempdir().unwrap();\n        let root = dir.path();\n\n        // Create test files\n        fs::write(root.join(\"test.txt\"), \"hello\").unwrap();\n        fs::create_dir(root.join(\"subdir\")).unwrap();\n        fs::write(root.join(\"subdir/nested.txt\"), \"world\").unwrap();\n\n        let files = scan_directory(root);\n\n        assert!(files.iter().any(|f| f.path == \"test.txt\"));\n        assert!(files\n            .iter()\n            .any(|f| f.path == \"subdir/nested.txt\" || f.path == \"subdir\\\\nested.txt\"));\n    }\n}\n","traces":[{"line":22,"address":[447536,447507,447008],"length":1,"stats":{"Line":2}},{"line":23,"address":[447143,447035],"length":1,"stats":{"Line":5}},{"line":32,"address":[447357],"length":1,"stats":{"Line":3}},{"line":35,"address":[1135479,1135554,1134032],"length":1,"stats":{"Line":2}},{"line":36,"address":[1134090],"length":1,"stats":{"Line":2}},{"line":37,"address":[1134402,1134493],"length":1,"stats":{"Line":4}},{"line":40,"address":[1134509],"length":1,"stats":{"Line":2}},{"line":41,"address":[1134588],"length":1,"stats":{"Line":2}},{"line":45,"address":[1135568,1135577,1134545,1134614],"length":1,"stats":{"Line":8}},{"line":46,"address":[1134694],"length":1,"stats":{"Line":0}},{"line":50,"address":[1134643,1134722],"length":1,"stats":{"Line":4}},{"line":51,"address":[1134795],"length":1,"stats":{"Line":2}},{"line":53,"address":[1135648,1135670],"length":1,"stats":{"Line":4}},{"line":54,"address":[1135696,1135720,1134919],"length":1,"stats":{"Line":2}},{"line":56,"address":[1134777],"length":1,"stats":{"Line":0}},{"line":60,"address":[1134935,1134991],"length":1,"stats":{"Line":4}},{"line":61,"address":[1135032],"length":1,"stats":{"Line":0}},{"line":65,"address":[1134997,1135485,1135050],"length":1,"stats":{"Line":4}},{"line":67,"address":[1135358],"length":1,"stats":{"Line":2}},{"line":68,"address":[1135226],"length":1,"stats":{"Line":2}},{"line":69,"address":[1135266],"length":1,"stats":{"Line":2}},{"line":70,"address":[1135330],"length":1,"stats":{"Line":2}}],"covered":19,"coverable":22},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","scanner","git.rs"],"content":"//! Git repository utilities\n\nuse std::path::Path;\nuse std::process::Command;\n\n/// Get the repository name from git remote\npub fn get_repository_name(root: &Path) -> Option<String> {\n    // Try to get the remote URL\n    let output = Command::new(\"git\")\n        .args([\"remote\", \"get-url\", \"origin\"])\n        .current_dir(root)\n        .output()\n        .ok()?;\n\n    if !output.status.success() {\n        return None;\n    }\n\n    let url = String::from_utf8_lossy(&output.stdout).trim().to_string();\n    parse_repo_name_from_url(&url)\n}\n\n/// Parse repository name from a git URL\nfn parse_repo_name_from_url(url: &str) -> Option<String> {\n    // Handle SSH URLs: git@github.com:owner/repo.git\n    if url.starts_with(\"git@\") {\n        let parts: Vec<&str> = url.split(':').collect();\n        if parts.len() == 2 {\n            let repo_path = parts[1].trim_end_matches(\".git\");\n            return Some(repo_path.to_string());\n        }\n    }\n\n    // Handle HTTPS URLs: https://github.com/owner/repo.git\n    if url.starts_with(\"https://\") || url.starts_with(\"http://\") {\n        let url = url.trim_end_matches(\".git\");\n        let parts: Vec<&str> = url.split('/').collect();\n        if parts.len() >= 2 {\n            let owner = parts[parts.len() - 2];\n            let repo = parts[parts.len() - 1];\n            return Some(format!(\"{}/{}\", owner, repo));\n        }\n    }\n\n    None\n}\n\n/// Get the default branch name\n#[allow(dead_code)]\npub fn get_default_branch(root: &Path) -> Option<String> {\n    // Try to get from git symbolic-ref\n    let output = Command::new(\"git\")\n        .args([\"symbolic-ref\", \"refs/remotes/origin/HEAD\", \"--short\"])\n        .current_dir(root)\n        .output()\n        .ok()?;\n\n    if output.status.success() {\n        let branch = String::from_utf8_lossy(&output.stdout)\n            .trim()\n            .trim_start_matches(\"origin/\")\n            .to_string();\n        if !branch.is_empty() {\n            return Some(branch);\n        }\n    }\n\n    // Fall back to checking for main or master\n    let branches = [\"main\", \"master\"];\n    for branch in branches {\n        let output = Command::new(\"git\")\n            .args([\n                \"show-ref\",\n                \"--verify\",\n                \"--quiet\",\n                &format!(\"refs/heads/{}\", branch),\n            ])\n            .current_dir(root)\n            .output()\n            .ok()?;\n\n        if output.status.success() {\n            return Some(branch.to_string());\n        }\n    }\n\n    None\n}\n\n/// Check if the repository is a git repository\n#[allow(dead_code)]\npub fn is_git_repository(root: &Path) -> bool {\n    root.join(\".git\").exists()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_ssh_url() {\n        let url = \"git@github.com:owner/repo.git\";\n        assert_eq!(\n            parse_repo_name_from_url(url),\n            Some(\"owner/repo\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_parse_https_url() {\n        let url = \"https://github.com/owner/repo.git\";\n        assert_eq!(\n            parse_repo_name_from_url(url),\n            Some(\"owner/repo\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_parse_https_url_without_git() {\n        let url = \"https://github.com/owner/repo\";\n        assert_eq!(\n            parse_repo_name_from_url(url),\n            Some(\"owner/repo\".to_string())\n        );\n    }\n}\n","traces":[{"line":7,"address":[1129850,1128880,1129856],"length":1,"stats":{"Line":3}},{"line":9,"address":[1129118,1128923,1129047],"length":1,"stats":{"Line":12}},{"line":10,"address":[1128958],"length":1,"stats":{"Line":3}},{"line":15,"address":[1129443],"length":1,"stats":{"Line":3}},{"line":16,"address":[1129477],"length":1,"stats":{"Line":3}},{"line":19,"address":[1129505,1129557],"length":1,"stats":{"Line":0}},{"line":20,"address":[1129776],"length":1,"stats":{"Line":0}},{"line":24,"address":[1129888,1131133,1131139],"length":1,"stats":{"Line":3}},{"line":26,"address":[1129959],"length":1,"stats":{"Line":3}},{"line":27,"address":[1130038],"length":1,"stats":{"Line":2}},{"line":28,"address":[1130162,1130097],"length":1,"stats":{"Line":4}},{"line":29,"address":[1130228,1130168],"length":1,"stats":{"Line":4}},{"line":30,"address":[1130290],"length":1,"stats":{"Line":2}},{"line":35,"address":[1129994,1130395],"length":1,"stats":{"Line":2}},{"line":36,"address":[1130432],"length":1,"stats":{"Line":3}},{"line":37,"address":[903567],"length":1,"stats":{"Line":3}},{"line":38,"address":[1130527,1130618],"length":1,"stats":{"Line":7}},{"line":39,"address":[1130640],"length":1,"stats":{"Line":4}},{"line":40,"address":[1130771],"length":1,"stats":{"Line":4}},{"line":41,"address":[1130901],"length":1,"stats":{"Line":4}},{"line":45,"address":[903650],"length":1,"stats":{"Line":0}},{"line":50,"address":[1133602,1133558,1131152],"length":1,"stats":{"Line":0}},{"line":52,"address":[1131207,1131337,1131420],"length":1,"stats":{"Line":0}},{"line":53,"address":[1131248],"length":1,"stats":{"Line":0}},{"line":58,"address":[904858],"length":1,"stats":{"Line":0}},{"line":59,"address":[1131901,1132042],"length":1,"stats":{"Line":0}},{"line":63,"address":[1132202],"length":1,"stats":{"Line":0}},{"line":64,"address":[1132231],"length":1,"stats":{"Line":0}},{"line":69,"address":[1131789],"length":1,"stats":{"Line":0}},{"line":70,"address":[1131843,1132457,1132356],"length":1,"stats":{"Line":0}},{"line":71,"address":[906095,905640],"length":1,"stats":{"Line":0}},{"line":72,"address":[1132878],"length":1,"stats":{"Line":0}},{"line":76,"address":[1132628,1132699],"length":1,"stats":{"Line":0}},{"line":82,"address":[1133412],"length":1,"stats":{"Line":0}},{"line":83,"address":[1133459],"length":1,"stats":{"Line":0}},{"line":87,"address":[1132586],"length":1,"stats":{"Line":0}},{"line":92,"address":[1133803,1133648,1133797],"length":1,"stats":{"Line":0}},{"line":93,"address":[1133764,1133668],"length":1,"stats":{"Line":0}}],"covered":18,"coverable":38},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","scanner","mod.rs"],"content":"//! Scanner module - File system and repository scanning\n\nmod filesystem;\nmod git;\n\nuse std::path::PathBuf;\n\npub use filesystem::FileInfo;\n\n/// Main scanner for repository analysis\n///\n/// The `Scanner` provides access to repository files and metadata.\n/// It caches file information for efficient access during rule execution.\npub struct Scanner {\n    /// Root directory of the repository\n    root: PathBuf,\n    /// Cached file information\n    file_cache: Vec<FileInfo>,\n}\n\nimpl Scanner {\n    /// Create a new scanner for the given root directory\n    ///\n    /// Scans the directory and caches file information for later use.\n    ///\n    /// # Arguments\n    ///\n    /// * `root` - The root directory of the repository to scan\n    ///\n    /// # Returns\n    ///\n    /// A new `Scanner` instance with cached file information\n    pub fn new(root: PathBuf) -> Self {\n        let file_cache = filesystem::scan_directory(&root);\n\n        Self { root, file_cache }\n    }\n\n    /// Get the repository name from the root path or git remote\n    ///\n    /// First attempts to get the repository name from git remote.\n    /// Falls back to the directory name if git information is unavailable.\n    ///\n    /// # Returns\n    ///\n    /// The repository name as a string\n    pub fn repository_name(&self) -> String {\n        // Try to get from git remote first\n        if let Some(name) = git::get_repository_name(&self.root) {\n            return name;\n        }\n\n        // Fall back to directory name\n        self.root\n            .file_name()\n            .and_then(|n| n.to_str())\n            .map(|s| s.to_string())\n            .unwrap_or_else(|| {\n                // If directory name contains non-UTF8, use lossy conversion\n                self.root.to_string_lossy().to_string()\n            })\n    }\n\n    /// Check if a file exists in the repository\n    ///\n    /// # Arguments\n    ///\n    /// * `path` - Relative path to the file from repository root\n    ///\n    /// # Returns\n    ///\n    /// `true` if the file exists, `false` otherwise\n    pub fn file_exists(&self, path: &str) -> bool {\n        self.root.join(path).exists()\n    }\n\n    /// Check if a directory exists in the repository\n    ///\n    /// # Arguments\n    ///\n    /// * `path` - Relative path to the directory from repository root\n    ///\n    /// # Returns\n    ///\n    /// `true` if the directory exists, `false` otherwise\n    pub fn directory_exists(&self, path: &str) -> bool {\n        let full_path = self.root.join(path);\n        full_path.exists() && full_path.is_dir()\n    }\n\n    /// Read file content as a string\n    ///\n    /// # Arguments\n    ///\n    /// * `path` - Relative path to the file from repository root\n    ///\n    /// # Returns\n    ///\n    /// The file content as a string, or an I/O error if reading fails\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the file cannot be read or is not valid UTF-8\n    pub fn read_file(&self, path: &str) -> std::io::Result<String> {\n        std::fs::read_to_string(self.root.join(path))\n    }\n\n    /// Get files with specific extensions\n    ///\n    /// # Arguments\n    ///\n    /// * `extensions` - Slice of file extensions (without the dot), e.g., `[\"rs\", \"toml\"]`\n    ///\n    /// # Returns\n    ///\n    /// A vector of references to `FileInfo` for matching files\n    pub fn files_with_extensions(&self, extensions: &[&str]) -> Vec<&FileInfo> {\n        self.file_cache\n            .iter()\n            .filter(|f| {\n                extensions\n                    .iter()\n                    .any(|ext| f.path.ends_with(&format!(\".{}\", ext)))\n            })\n            .collect()\n    }\n\n    /// Get files matching a glob pattern\n    ///\n    /// Supports simple glob patterns like `*.rs`, `**/test/**`, etc.\n    ///\n    /// # Arguments\n    ///\n    /// * `pattern` - Glob pattern to match against file paths\n    ///\n    /// # Returns\n    ///\n    /// A vector of references to `FileInfo` for matching files\n    pub fn files_matching_pattern(&self, pattern: &str) -> Vec<&FileInfo> {\n        self.file_cache\n            .iter()\n            .filter(|f| {\n                if pattern.contains('*') {\n                    glob_match(pattern, &f.path)\n                } else {\n                    f.path.ends_with(pattern) || f.path.contains(pattern)\n                }\n            })\n            .collect()\n    }\n\n    /// Get files larger than a given size in bytes\n    ///\n    /// # Arguments\n    ///\n    /// * `size` - Minimum file size in bytes\n    ///\n    /// # Returns\n    ///\n    /// A vector of references to `FileInfo` for files larger than the specified size\n    pub fn files_larger_than(&self, size: u64) -> Vec<&FileInfo> {\n        self.file_cache.iter().filter(|f| f.size > size).collect()\n    }\n\n    /// Get files in a specific directory\n    ///\n    /// # Arguments\n    ///\n    /// * `dir` - Directory path (with or without trailing slash)\n    ///\n    /// # Returns\n    ///\n    /// A vector of references to `FileInfo` for files in the specified directory\n    pub fn files_in_directory(&self, dir: &str) -> Vec<&FileInfo> {\n        let dir_path = if dir.ends_with('/') {\n            dir.to_string()\n        } else {\n            format!(\"{}/\", dir)\n        };\n\n        self.file_cache\n            .iter()\n            .filter(|f| f.path.starts_with(&dir_path) || f.path.starts_with(dir))\n            .collect()\n    }\n\n    /// Get all files in the repository\n    ///\n    /// # Returns\n    ///\n    /// A slice of all `FileInfo` entries\n    #[allow(dead_code)]\n    pub fn all_files(&self) -> &[FileInfo] {\n        &self.file_cache\n    }\n}\n\n/// Simple glob matching\nfn glob_match(pattern: &str, text: &str) -> bool {\n    if pattern == \"*\" {\n        return true;\n    }\n\n    if pattern.starts_with(\"*.\") {\n        let ext = &pattern[1..];\n        return text.ends_with(ext);\n    }\n\n    if pattern.contains(\"**\") {\n        let parts: Vec<&str> = pattern.split(\"**\").collect();\n        if parts.len() == 2 {\n            let prefix = parts[0].trim_end_matches('/');\n            let suffix = parts[1].trim_start_matches('/');\n\n            if !prefix.is_empty() && !text.starts_with(prefix) {\n                return false;\n            }\n            if !suffix.is_empty() {\n                return text.ends_with(suffix) || text.contains(&format!(\"/{}\", suffix));\n            }\n            return true;\n        }\n    }\n\n    text.contains(pattern.trim_start_matches('*').trim_end_matches('*'))\n}\n","traces":[{"line":33,"address":[1161008,1161204],"length":1,"stats":{"Line":2}},{"line":34,"address":[1161033,1161099],"length":1,"stats":{"Line":4}},{"line":47,"address":[1161232],"length":1,"stats":{"Line":3}},{"line":49,"address":[1161262],"length":1,"stats":{"Line":5}},{"line":50,"address":[1161349],"length":1,"stats":{"Line":0}},{"line":54,"address":[1161392],"length":1,"stats":{"Line":3}},{"line":56,"address":[859680,859694],"length":1,"stats":{"Line":4}},{"line":57,"address":[859734,859712],"length":1,"stats":{"Line":4}},{"line":58,"address":[859879,859885,859760],"length":1,"stats":{"Line":0}},{"line":60,"address":[1584034],"length":1,"stats":{"Line":0}},{"line":73,"address":[1161641,1161472,1161635],"length":1,"stats":{"Line":2}},{"line":74,"address":[1161602,1161501],"length":1,"stats":{"Line":4}},{"line":86,"address":[1161664,1161927,1161921],"length":1,"stats":{"Line":2}},{"line":87,"address":[1161699],"length":1,"stats":{"Line":2}},{"line":88,"address":[1161741,1161809,1161894],"length":1,"stats":{"Line":4}},{"line":104,"address":[1161952],"length":1,"stats":{"Line":2}},{"line":105,"address":[1162002],"length":1,"stats":{"Line":2}},{"line":117,"address":[1162064],"length":1,"stats":{"Line":2}},{"line":118,"address":[1162116],"length":1,"stats":{"Line":2}},{"line":120,"address":[859904],"length":1,"stats":{"Line":2}},{"line":121,"address":[859925,859955],"length":1,"stats":{"Line":5}},{"line":123,"address":[1584240,1584260,1584208],"length":1,"stats":{"Line":9}},{"line":139,"address":[1162192],"length":1,"stats":{"Line":3}},{"line":140,"address":[468952],"length":1,"stats":{"Line":3}},{"line":142,"address":[860256],"length":1,"stats":{"Line":4}},{"line":143,"address":[860280],"length":1,"stats":{"Line":6}},{"line":144,"address":[860361],"length":1,"stats":{"Line":3}},{"line":146,"address":[860430,860310],"length":1,"stats":{"Line":6}},{"line":161,"address":[1162304],"length":1,"stats":{"Line":2}},{"line":162,"address":[860506,860496],"length":1,"stats":{"Line":6}},{"line":174,"address":[1162791,1162416,1162797],"length":1,"stats":{"Line":3}},{"line":175,"address":[1162456],"length":1,"stats":{"Line":3}},{"line":176,"address":[1162597],"length":1,"stats":{"Line":0}},{"line":178,"address":[1162481],"length":1,"stats":{"Line":3}},{"line":181,"address":[1162695,1162623],"length":1,"stats":{"Line":6}},{"line":183,"address":[1584784,1584807],"length":1,"stats":{"Line":4}},{"line":193,"address":[1162816],"length":1,"stats":{"Line":10}},{"line":194,"address":[1162821],"length":1,"stats":{"Line":2}},{"line":199,"address":[1164027,1162832,1164004],"length":1,"stats":{"Line":3}},{"line":200,"address":[469601],"length":1,"stats":{"Line":2}},{"line":201,"address":[1162946],"length":1,"stats":{"Line":0}},{"line":204,"address":[469626],"length":1,"stats":{"Line":2}},{"line":205,"address":[1163003],"length":1,"stats":{"Line":2}},{"line":206,"address":[469796],"length":1,"stats":{"Line":2}},{"line":209,"address":[1162959],"length":1,"stats":{"Line":2}},{"line":210,"address":[469902],"length":1,"stats":{"Line":0}},{"line":211,"address":[1163322,1163257],"length":1,"stats":{"Line":0}},{"line":212,"address":[1163328,1163387],"length":1,"stats":{"Line":0}},{"line":213,"address":[1163462],"length":1,"stats":{"Line":0}},{"line":215,"address":[1163655,1163568],"length":1,"stats":{"Line":0}},{"line":216,"address":[1163661],"length":1,"stats":{"Line":0}},{"line":218,"address":[1163692,1163624],"length":1,"stats":{"Line":0}},{"line":219,"address":[1163708,1163753],"length":1,"stats":{"Line":0}},{"line":221,"address":[1163739],"length":1,"stats":{"Line":0}},{"line":225,"address":[1163096],"length":1,"stats":{"Line":2}}],"covered":41,"coverable":55},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","utils","mod.rs"],"content":"//! Utility modules for RepoLens\n\npub mod prerequisites;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","utils","prerequisites.rs"],"content":"//! Prerequisites checking for RepoLens initialization\n//!\n//! This module verifies that required tools and configurations are available\n//! before running RepoLens commands.\n\nuse anyhow::{bail, Context, Result};\nuse colored::Colorize;\nuse std::path::Path;\nuse std::process::Command;\n\n/// Level of importance for a prerequisite check\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum CheckLevel {\n    /// Required for operation - failure blocks execution\n    Required,\n    /// Optional - failure generates a warning\n    Optional,\n}\n\n/// Status of a prerequisite check\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum CheckStatus {\n    /// Check passed successfully\n    Ok,\n    /// Check failed\n    Failed,\n    /// Check was skipped (due to dependency failure)\n    Skipped,\n}\n\n/// Result of a single prerequisite check\n#[derive(Debug, Clone)]\npub struct CheckResult {\n    /// Name of the check\n    pub name: String,\n    /// Whether this check is required or optional\n    pub level: CheckLevel,\n    /// Status of the check\n    pub status: CheckStatus,\n    /// Human-readable message (shown on failure)\n    pub message: Option<String>,\n    /// Suggested fix for the issue\n    pub fix: Option<String>,\n}\n\nimpl CheckResult {\n    /// Create a successful check result\n    pub fn ok(name: &str, level: CheckLevel) -> Self {\n        Self {\n            name: name.to_string(),\n            level,\n            status: CheckStatus::Ok,\n            message: None,\n            fix: None,\n        }\n    }\n\n    /// Create a failed check result\n    pub fn failed(name: &str, level: CheckLevel, message: &str, fix: Option<&str>) -> Self {\n        Self {\n            name: name.to_string(),\n            level,\n            status: CheckStatus::Failed,\n            message: Some(message.to_string()),\n            fix: fix.map(|s| s.to_string()),\n        }\n    }\n\n    /// Create a skipped check result\n    pub fn skipped(name: &str, level: CheckLevel) -> Self {\n        Self {\n            name: name.to_string(),\n            level,\n            status: CheckStatus::Skipped,\n            message: None,\n            fix: None,\n        }\n    }\n\n    /// Check if this result represents a failure\n    #[allow(dead_code)]\n    pub fn is_failed(&self) -> bool {\n        self.status == CheckStatus::Failed\n    }\n\n    /// Check if this is a required check that failed\n    pub fn is_required_failure(&self) -> bool {\n        self.level == CheckLevel::Required && self.status == CheckStatus::Failed\n    }\n\n    /// Check if this is an optional check that failed\n    pub fn is_optional_failure(&self) -> bool {\n        self.level == CheckLevel::Optional && self.status == CheckStatus::Failed\n    }\n}\n\n/// Aggregated report of all prerequisite checks\n#[derive(Debug, Clone)]\npub struct PrerequisitesReport {\n    /// All check results\n    pub checks: Vec<CheckResult>,\n}\n\nimpl PrerequisitesReport {\n    /// Create a new empty report\n    pub fn new() -> Self {\n        Self { checks: Vec::new() }\n    }\n\n    /// Add a check result to the report\n    pub fn add(&mut self, result: CheckResult) {\n        self.checks.push(result);\n    }\n\n    /// Check if all required checks passed\n    pub fn all_required_passed(&self) -> bool {\n        !self.checks.iter().any(|c| c.is_required_failure())\n    }\n\n    /// Get all failed required checks\n    pub fn required_failures(&self) -> Vec<&CheckResult> {\n        self.checks\n            .iter()\n            .filter(|c| c.is_required_failure())\n            .collect()\n    }\n\n    /// Get all failed optional checks (warnings)\n    pub fn optional_failures(&self) -> Vec<&CheckResult> {\n        self.checks\n            .iter()\n            .filter(|c| c.is_optional_failure())\n            .collect()\n    }\n\n    /// Check if there are any warnings\n    pub fn has_warnings(&self) -> bool {\n        self.checks.iter().any(|c| c.is_optional_failure())\n    }\n}\n\nimpl Default for PrerequisitesReport {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n// ============================================================================\n// Check functions\n// ============================================================================\n\n/// Check if git is installed\npub fn check_git_installed() -> CheckResult {\n    let output = Command::new(\"git\").arg(\"--version\").output();\n\n    match output {\n        Ok(o) if o.status.success() => CheckResult::ok(\"Git installed\", CheckLevel::Required),\n        _ => CheckResult::failed(\n            \"Git installed\",\n            CheckLevel::Required,\n            \"Git is not installed\",\n            Some(\"Install git: https://git-scm.com/downloads\"),\n        ),\n    }\n}\n\n/// Check if the current directory is a git repository\npub fn check_is_git_repo(root: &Path) -> CheckResult {\n    let git_dir = root.join(\".git\");\n\n    if git_dir.exists() {\n        CheckResult::ok(\"Git repository\", CheckLevel::Required)\n    } else {\n        CheckResult::failed(\n            \"Git repository\",\n            CheckLevel::Required,\n            \"Not a git repository\",\n            Some(\"Run: git init\"),\n        )\n    }\n}\n\n/// Check if GitHub CLI (gh) is installed\npub fn check_gh_installed() -> CheckResult {\n    let output = Command::new(\"gh\").arg(\"--version\").output();\n\n    match output {\n        Ok(o) if o.status.success() => {\n            CheckResult::ok(\"GitHub CLI installed\", CheckLevel::Required)\n        }\n        _ => CheckResult::failed(\n            \"GitHub CLI installed\",\n            CheckLevel::Required,\n            \"GitHub CLI (gh) is not installed\",\n            Some(\"Install gh: https://cli.github.com/\"),\n        ),\n    }\n}\n\n/// Check if GitHub CLI is authenticated\npub fn check_gh_authenticated() -> CheckResult {\n    let output = Command::new(\"gh\").args([\"auth\", \"status\"]).output();\n\n    match output {\n        Ok(o) if o.status.success() => {\n            CheckResult::ok(\"GitHub CLI authenticated\", CheckLevel::Required)\n        }\n        _ => CheckResult::failed(\n            \"GitHub CLI authenticated\",\n            CheckLevel::Required,\n            \"GitHub CLI is not authenticated\",\n            Some(\"Run: gh auth login\"),\n        ),\n    }\n}\n\n/// Check if a remote origin is configured\npub fn check_remote_origin(root: &Path) -> CheckResult {\n    let output = Command::new(\"git\")\n        .args([\"remote\", \"get-url\", \"origin\"])\n        .current_dir(root)\n        .output();\n\n    match output {\n        Ok(o) if o.status.success() => {\n            CheckResult::ok(\"Remote origin configured\", CheckLevel::Optional)\n        }\n        _ => CheckResult::failed(\n            \"Remote origin configured\",\n            CheckLevel::Optional,\n            \"No remote origin configured\",\n            Some(\"Run: git remote add origin <url>\"),\n        ),\n    }\n}\n\n/// Check if the remote origin is a GitHub repository\npub fn check_remote_is_github(root: &Path) -> CheckResult {\n    let output = Command::new(\"git\")\n        .args([\"remote\", \"get-url\", \"origin\"])\n        .current_dir(root)\n        .output();\n\n    match output {\n        Ok(o) if o.status.success() => {\n            let url = String::from_utf8_lossy(&o.stdout);\n            if url.contains(\"github.com\") {\n                CheckResult::ok(\"Remote is GitHub\", CheckLevel::Optional)\n            } else {\n                CheckResult::failed(\n                    \"Remote is GitHub\",\n                    CheckLevel::Optional,\n                    \"Remote origin is not a GitHub repository\",\n                    Some(\"RepoLens works best with GitHub repositories\"),\n                )\n            }\n        }\n        _ => CheckResult::skipped(\"Remote is GitHub\", CheckLevel::Optional),\n    }\n}\n\n// ============================================================================\n// Run all checks\n// ============================================================================\n\n/// Options for running prerequisite checks\n#[derive(Debug, Clone, Default)]\npub struct CheckOptions {\n    /// Skip optional checks\n    #[allow(dead_code)]\n    pub skip_optional: bool,\n}\n\n/// Run all prerequisite checks\npub fn run_all_checks(root: &Path, _options: &CheckOptions) -> PrerequisitesReport {\n    let mut report = PrerequisitesReport::new();\n\n    // Required checks\n    let git_installed = check_git_installed();\n    let git_ok = git_installed.status == CheckStatus::Ok;\n    report.add(git_installed);\n\n    if git_ok {\n        report.add(check_is_git_repo(root));\n    } else {\n        report.add(CheckResult::skipped(\"Git repository\", CheckLevel::Required));\n    }\n\n    let gh_installed = check_gh_installed();\n    let gh_ok = gh_installed.status == CheckStatus::Ok;\n    report.add(gh_installed);\n\n    if gh_ok {\n        report.add(check_gh_authenticated());\n    } else {\n        report.add(CheckResult::skipped(\n            \"GitHub CLI authenticated\",\n            CheckLevel::Required,\n        ));\n    }\n\n    // Optional checks (only if git repo exists)\n    let is_repo = report\n        .checks\n        .iter()\n        .find(|c| c.name == \"Git repository\")\n        .map(|c| c.status == CheckStatus::Ok)\n        .unwrap_or(false);\n\n    if is_repo {\n        let remote_result = check_remote_origin(root);\n        let has_remote = remote_result.status == CheckStatus::Ok;\n        report.add(remote_result);\n\n        if has_remote {\n            report.add(check_remote_is_github(root));\n        } else {\n            report.add(CheckResult::skipped(\n                \"Remote is GitHub\",\n                CheckLevel::Optional,\n            ));\n        }\n    } else {\n        report.add(CheckResult::skipped(\n            \"Remote origin configured\",\n            CheckLevel::Optional,\n        ));\n        report.add(CheckResult::skipped(\n            \"Remote is GitHub\",\n            CheckLevel::Optional,\n        ));\n    }\n\n    report\n}\n\n// ============================================================================\n// Display functions\n// ============================================================================\n\n/// Display the full prerequisites report\npub fn display_report(report: &PrerequisitesReport, _verbose: bool) {\n    println!(\"{}\\n\", \"Checking prerequisites...\".bold());\n\n    for check in &report.checks {\n        let icon = match check.status {\n            CheckStatus::Ok => \"‚úì\".green(),\n            CheckStatus::Failed if check.level == CheckLevel::Required => \"‚úó\".red(),\n            CheckStatus::Failed => \"!\".yellow(),\n            CheckStatus::Skipped => \"‚óã\".dimmed(),\n        };\n\n        let name = match check.status {\n            CheckStatus::Ok => check.name.normal(),\n            CheckStatus::Failed if check.level == CheckLevel::Required => check.name.red(),\n            CheckStatus::Failed => check.name.yellow(),\n            CheckStatus::Skipped => check.name.dimmed(),\n        };\n\n        let suffix = match check.status {\n            CheckStatus::Skipped => \" (skipped)\".dimmed().to_string(),\n            CheckStatus::Failed if check.level == CheckLevel::Optional => {\n                \" (optional)\".dimmed().to_string()\n            }\n            _ => String::new(),\n        };\n\n        println!(\"  {} {}{}\", icon, name, suffix);\n\n        // Show message and fix for failures\n        if check.status == CheckStatus::Failed {\n            if let Some(msg) = &check.message {\n                println!(\"    {}\", msg.dimmed());\n            }\n            if let Some(fix) = &check.fix {\n                println!(\"    {}: {}\", \"Fix\".cyan(), fix);\n            }\n        }\n    }\n\n    println!();\n}\n\n/// Display error summary for failed required checks\npub fn display_error_summary(report: &PrerequisitesReport) {\n    let failures = report.required_failures();\n    if failures.is_empty() {\n        return;\n    }\n\n    eprintln!(\n        \"{} {} required prerequisite(s) failed:\",\n        \"Error:\".red().bold(),\n        failures.len()\n    );\n\n    for check in failures {\n        eprintln!(\"  {} {}\", \"‚Ä¢\".red(), check.name);\n        if let Some(fix) = &check.fix {\n            eprintln!(\"    {}: {}\", \"Fix\".cyan(), fix);\n        }\n    }\n}\n\n/// Display warnings for failed optional checks\npub fn display_warnings(report: &PrerequisitesReport) {\n    let warnings = report.optional_failures();\n    if warnings.is_empty() {\n        return;\n    }\n\n    println!(\n        \"{} {} optional check(s) failed:\",\n        \"Warning:\".yellow().bold(),\n        warnings.len()\n    );\n\n    for check in warnings {\n        if let Some(msg) = &check.message {\n            println!(\"  {} {}\", \"‚Ä¢\".yellow(), msg);\n        }\n    }\n\n    println!();\n}\n\n// ============================================================================\n// Centralized utility functions (used by other modules)\n// ============================================================================\n\n/// Check if gh CLI is available and authenticated\npub fn is_gh_available() -> bool {\n    Command::new(\"gh\")\n        .args([\"auth\", \"status\"])\n        .output()\n        .map(|o| o.status.success())\n        .unwrap_or(false)\n}\n\n/// Get repository info (owner/name) from GitHub CLI\npub fn get_repo_info() -> Result<String> {\n    let output = Command::new(\"gh\")\n        .args([\n            \"repo\",\n            \"view\",\n            \"--json\",\n            \"nameWithOwner\",\n            \"-q\",\n            \".nameWithOwner\",\n        ])\n        .output()\n        .context(\"Failed to get repository info\")?;\n\n    if !output.status.success() {\n        bail!(\"Failed to get repository info. Make sure you're in a git repository.\");\n    }\n\n    Ok(String::from_utf8_lossy(&output.stdout).trim().to_string())\n}\n","traces":[{"line":48,"address":[956400],"length":1,"stats":{"Line":0}},{"line":50,"address":[1269482],"length":1,"stats":{"Line":0}},{"line":59,"address":[957035,957041,956608],"length":1,"stats":{"Line":0}},{"line":61,"address":[956731],"length":1,"stats":{"Line":0}},{"line":64,"address":[956778,956833],"length":1,"stats":{"Line":0}},{"line":65,"address":[956867],"length":1,"stats":{"Line":0}},{"line":70,"address":[1270096],"length":1,"stats":{"Line":0}},{"line":72,"address":[957098],"length":1,"stats":{"Line":0}},{"line":82,"address":[957264],"length":1,"stats":{"Line":0}},{"line":83,"address":[957269],"length":1,"stats":{"Line":0}},{"line":87,"address":[957296],"length":1,"stats":{"Line":0}},{"line":88,"address":[957309],"length":1,"stats":{"Line":0}},{"line":92,"address":[957376],"length":1,"stats":{"Line":0}},{"line":93,"address":[957389],"length":1,"stats":{"Line":0}},{"line":106,"address":[957456],"length":1,"stats":{"Line":0}},{"line":107,"address":[957469],"length":1,"stats":{"Line":0}},{"line":111,"address":[957520],"length":1,"stats":{"Line":0}},{"line":112,"address":[957525],"length":1,"stats":{"Line":0}},{"line":116,"address":[957552],"length":1,"stats":{"Line":0}},{"line":117,"address":[957561],"length":1,"stats":{"Line":0}},{"line":121,"address":[957616],"length":1,"stats":{"Line":0}},{"line":122,"address":[957648],"length":1,"stats":{"Line":0}},{"line":124,"address":[1073312,1073326],"length":1,"stats":{"Line":0}},{"line":129,"address":[957712],"length":1,"stats":{"Line":0}},{"line":130,"address":[957744],"length":1,"stats":{"Line":0}},{"line":132,"address":[993086,993072],"length":1,"stats":{"Line":0}},{"line":137,"address":[957808],"length":1,"stats":{"Line":0}},{"line":138,"address":[1270857],"length":1,"stats":{"Line":0}},{"line":143,"address":[957872],"length":1,"stats":{"Line":0}},{"line":144,"address":[957880],"length":1,"stats":{"Line":0}},{"line":153,"address":[957904,958597,958510],"length":1,"stats":{"Line":0}},{"line":154,"address":[957921],"length":1,"stats":{"Line":0}},{"line":156,"address":[1271174],"length":1,"stats":{"Line":0}},{"line":157,"address":[958282],"length":1,"stats":{"Line":0}},{"line":160,"address":[958173],"length":1,"stats":{"Line":0}},{"line":162,"address":[958181],"length":1,"stats":{"Line":0}},{"line":168,"address":[958624,958936,958930],"length":1,"stats":{"Line":0}},{"line":169,"address":[958654],"length":1,"stats":{"Line":0}},{"line":171,"address":[958691,958759],"length":1,"stats":{"Line":0}},{"line":172,"address":[958928,958873],"length":1,"stats":{"Line":0}},{"line":176,"address":[1271825],"length":1,"stats":{"Line":0}},{"line":178,"address":[958790],"length":1,"stats":{"Line":0}},{"line":184,"address":[959566,959653,958960],"length":1,"stats":{"Line":0}},{"line":185,"address":[1272017],"length":1,"stats":{"Line":0}},{"line":187,"address":[959190],"length":1,"stats":{"Line":0}},{"line":188,"address":[1272378],"length":1,"stats":{"Line":0}},{"line":189,"address":[959440],"length":1,"stats":{"Line":0}},{"line":193,"address":[959229],"length":1,"stats":{"Line":0}},{"line":195,"address":[959237],"length":1,"stats":{"Line":0}},{"line":201,"address":[960423,959680,960336],"length":1,"stats":{"Line":0}},{"line":202,"address":[959697],"length":1,"stats":{"Line":0}},{"line":204,"address":[959960],"length":1,"stats":{"Line":0}},{"line":205,"address":[960108],"length":1,"stats":{"Line":0}},{"line":206,"address":[960210],"length":1,"stats":{"Line":0}},{"line":210,"address":[959999],"length":1,"stats":{"Line":0}},{"line":212,"address":[960007],"length":1,"stats":{"Line":0}},{"line":218,"address":[961286,960448,961199],"length":1,"stats":{"Line":0}},{"line":219,"address":[960491,960623,960694],"length":1,"stats":{"Line":0}},{"line":220,"address":[1273574],"length":1,"stats":{"Line":0}},{"line":224,"address":[960817],"length":1,"stats":{"Line":0}},{"line":225,"address":[1274005],"length":1,"stats":{"Line":0}},{"line":226,"address":[961073],"length":1,"stats":{"Line":0}},{"line":230,"address":[960856],"length":1,"stats":{"Line":0}},{"line":232,"address":[960864],"length":1,"stats":{"Line":0}},{"line":238,"address":[962391,961312,962304],"length":1,"stats":{"Line":0}},{"line":239,"address":[961487,961558,961355],"length":1,"stats":{"Line":0}},{"line":240,"address":[1274438],"length":1,"stats":{"Line":0}},{"line":244,"address":[961681],"length":1,"stats":{"Line":0}},{"line":245,"address":[1274803],"length":1,"stats":{"Line":0}},{"line":246,"address":[961948,961869],"length":1,"stats":{"Line":0}},{"line":247,"address":[961967,962047],"length":1,"stats":{"Line":0}},{"line":248,"address":[962251,962195],"length":1,"stats":{"Line":0}},{"line":252,"address":[962089],"length":1,"stats":{"Line":0}},{"line":254,"address":[962097],"length":1,"stats":{"Line":0}},{"line":258,"address":[962310,961720],"length":1,"stats":{"Line":0}},{"line":275,"address":[963905,963944,962416],"length":1,"stats":{"Line":0}},{"line":276,"address":[962467],"length":1,"stats":{"Line":0}},{"line":279,"address":[962506],"length":1,"stats":{"Line":0}},{"line":280,"address":[962626,962550],"length":1,"stats":{"Line":0}},{"line":281,"address":[1275675],"length":1,"stats":{"Line":0}},{"line":283,"address":[962744],"length":1,"stats":{"Line":0}},{"line":284,"address":[962811,962868],"length":1,"stats":{"Line":0}},{"line":286,"address":[1275871,1275790],"length":1,"stats":{"Line":0}},{"line":289,"address":[1275888],"length":1,"stats":{"Line":0}},{"line":290,"address":[962956,962877],"length":1,"stats":{"Line":0}},{"line":291,"address":[1276005],"length":1,"stats":{"Line":0}},{"line":293,"address":[1276117],"length":1,"stats":{"Line":0}},{"line":294,"address":[1276238,1276174],"length":1,"stats":{"Line":0}},{"line":296,"address":[963154,963091],"length":1,"stats":{"Line":0}},{"line":298,"address":[963083],"length":1,"stats":{"Line":0}},{"line":303,"address":[1276257,1276208],"length":1,"stats":{"Line":0}},{"line":306,"address":[993152,993166],"length":1,"stats":{"Line":0}},{"line":307,"address":[1073472,1073481],"length":1,"stats":{"Line":0}},{"line":310,"address":[963860,963336],"length":1,"stats":{"Line":0}},{"line":311,"address":[963556,963401],"length":1,"stats":{"Line":0}},{"line":312,"address":[963635,963564],"length":1,"stats":{"Line":0}},{"line":313,"address":[1276684],"length":1,"stats":{"Line":0}},{"line":315,"address":[1276796],"length":1,"stats":{"Line":0}},{"line":316,"address":[963823,963878],"length":1,"stats":{"Line":0}},{"line":318,"address":[963770,963843],"length":1,"stats":{"Line":0}},{"line":320,"address":[1276802],"length":1,"stats":{"Line":0}},{"line":324,"address":[963348,963424],"length":1,"stats":{"Line":0}},{"line":326,"address":[1276380],"length":1,"stats":{"Line":0}},{"line":328,"address":[963439],"length":1,"stats":{"Line":0}},{"line":330,"address":[1276471],"length":1,"stats":{"Line":0}},{"line":334,"address":[1276546],"length":1,"stats":{"Line":0}},{"line":342,"address":[1277008,1279229,1278253],"length":1,"stats":{"Line":0}},{"line":343,"address":[964003],"length":1,"stats":{"Line":0}},{"line":345,"address":[964202,964223],"length":1,"stats":{"Line":0}},{"line":346,"address":[1277339],"length":1,"stats":{"Line":0}},{"line":347,"address":[1277421],"length":1,"stats":{"Line":0}},{"line":348,"address":[1277572,1277457],"length":1,"stats":{"Line":0}},{"line":349,"address":[1277544],"length":1,"stats":{"Line":0}},{"line":350,"address":[1277479],"length":1,"stats":{"Line":0}},{"line":353,"address":[964473],"length":1,"stats":{"Line":0}},{"line":354,"address":[1277608,1277740],"length":1,"stats":{"Line":0}},{"line":355,"address":[1277633,1277915,1277815,1277854],"length":1,"stats":{"Line":0}},{"line":356,"address":[964789,964841],"length":1,"stats":{"Line":0}},{"line":357,"address":[964626,964909],"length":1,"stats":{"Line":0}},{"line":360,"address":[1277769],"length":1,"stats":{"Line":0}},{"line":361,"address":[1278275,1278003],"length":1,"stats":{"Line":0}},{"line":362,"address":[1278103,1277981],"length":1,"stats":{"Line":0}},{"line":363,"address":[1278109],"length":1,"stats":{"Line":0}},{"line":365,"address":[965305,965005],"length":1,"stats":{"Line":0}},{"line":368,"address":[965183,965351],"length":1,"stats":{"Line":0}},{"line":371,"address":[1278554],"length":1,"stats":{"Line":0}},{"line":372,"address":[965576],"length":1,"stats":{"Line":0}},{"line":373,"address":[965634,965722],"length":1,"stats":{"Line":0}},{"line":375,"address":[965907,965659],"length":1,"stats":{"Line":0}},{"line":376,"address":[1278955],"length":1,"stats":{"Line":0}},{"line":381,"address":[964336],"length":1,"stats":{"Line":0}},{"line":385,"address":[966208,967441,967447],"length":1,"stats":{"Line":0}},{"line":386,"address":[1279266],"length":1,"stats":{"Line":0}},{"line":387,"address":[1279358,1279302],"length":1,"stats":{"Line":0}},{"line":391,"address":[1279418,1279364],"length":1,"stats":{"Line":0}},{"line":397,"address":[1279671,1279857],"length":1,"stats":{"Line":0}},{"line":398,"address":[966877,966939],"length":1,"stats":{"Line":0}},{"line":399,"address":[1280183],"length":1,"stats":{"Line":0}},{"line":400,"address":[967205],"length":1,"stats":{"Line":0}},{"line":406,"address":[1281543,1280512,1281549],"length":1,"stats":{"Line":0}},{"line":407,"address":[967490],"length":1,"stats":{"Line":0}},{"line":408,"address":[967526,967582],"length":1,"stats":{"Line":0}},{"line":412,"address":[967745],"length":1,"stats":{"Line":0}},{"line":418,"address":[968075,967889],"length":1,"stats":{"Line":0}},{"line":419,"address":[968130,968259],"length":1,"stats":{"Line":0}},{"line":420,"address":[968267],"length":1,"stats":{"Line":0}},{"line":424,"address":[968194],"length":1,"stats":{"Line":0}},{"line":432,"address":[968544,968776,968782],"length":1,"stats":{"Line":0}},{"line":433,"address":[968645,968551,968700],"length":1,"stats":{"Line":0}},{"line":434,"address":[1281623],"length":1,"stats":{"Line":0}},{"line":436,"address":[1073504,1073513],"length":1,"stats":{"Line":0}},{"line":441,"address":[969824,968800,969818],"length":1,"stats":{"Line":0}},{"line":442,"address":[969022,969218,968817,969083],"length":1,"stats":{"Line":0}},{"line":443,"address":[968852],"length":1,"stats":{"Line":0}},{"line":454,"address":[969413],"length":1,"stats":{"Line":0}},{"line":455,"address":[969502,969442],"length":1,"stats":{"Line":0}},{"line":458,"address":[969582,969468,969674],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":157}],"coverage":50.983436853002075,"covered":985,"coverable":1932}