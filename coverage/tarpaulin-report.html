<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 72px;
}
.code-line {
  margin: 0;
  height: 1em;
  counter-increment: line;

  position: absolute;
  padding: 0 0.3em 0.3em 0.3em;
  display: inherit;
  width: 100%;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

.code-text-container {
  position: relative;
  height: 1em;
  padding: 0.3em 0;
}

.cover-indicator {
  display: flex;
  width: 100%;
  position: absolute;
  justify-content: end;
  height: 1em;
  align-items: center;
  padding: 0 0.3em 0.3em 0.3em;
}

.cover-indicator.check-cover::after {
  content: "\2713";
  font-weight: bold;
  background-color: var(--green);
  height: 1em;
}

.cover-indicator.no-cover::after {
  content: "\2716";
  font-weight: bold;
  background-color: var(--red);
  height: 1em;
}

.stat-line-hit {
  max-width: 48px;
  overflow: hidden;
  font-weight: bold;
  margin-right: 4px;
  background-color: var(--green);
  position: relative;
  top: 0.1em;
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","scripts","check-quality-gates.rs"],"content":"//! Script de v√©rification des seuils de qualit√©\n//! \n//! Ce script v√©rifie que tous les seuils d√©finis dans `.github/quality-gates.toml`\n//! sont respect√©s avant de permettre la cr√©ation d'une nightly build.\n\nuse std::fs;\nuse std::path::Path;\nuse std::process::{Command, Stdio};\n\nuse anyhow::{Context, Result};\nuse serde::Deserialize;\nuse toml;\n\n#[derive(Debug, Deserialize)]\nstruct QualityGates {\n    coverage: Option\u003cCoverage\u003e,\n    clippy: Option\u003cClippy\u003e,\n    security: Option\u003cSecurity\u003e,\n    dependencies: Option\u003cDependencies\u003e,\n    code_metrics: Option\u003cCodeMetrics\u003e,\n    documentation: Option\u003cDocumentation\u003e,\n    tests: Option\u003cTests\u003e,\n    build: Option\u003cBuild\u003e,\n    nightly: Option\u003cNightly\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Coverage {\n    minimum: Option\u003cf64\u003e,\n    target: Option\u003cf64\u003e,\n    exclude: Option\u003cVec\u003cString\u003e\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Clippy {\n    max_warnings: Option\u003cu32\u003e,\n    severity: Option\u003cString\u003e,\n    strict: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Security {\n    max_critical_vulnerabilities: Option\u003cu32\u003e,\n    max_high_vulnerabilities: Option\u003cu32\u003e,\n    max_medium_vulnerabilities: Option\u003cu32\u003e,\n    allow_unpatched: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Dependencies {\n    max_outdated: Option\u003cu32\u003e,\n    max_duplicates: Option\u003cu32\u003e,\n    check_licenses: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct CodeMetrics {\n    max_binary_size: Option\u003cu64\u003e,\n    min_tests: Option\u003cu32\u003e,\n    min_integration_tests: Option\u003cu32\u003e,\n    max_cyclomatic_complexity: Option\u003cu32\u003e,\n    max_unsafe_percentage: Option\u003cf64\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Documentation {\n    min_documentation_coverage: Option\u003cf64\u003e,\n    require_public_docs: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Tests {\n    require_all_tests_pass: Option\u003cbool\u003e,\n    max_test_duration: Option\u003cu32\u003e,\n    enable_performance_tests: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Build {\n    require_build_success: Option\u003cbool\u003e,\n    max_build_duration: Option\u003cu32\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Nightly {\n    strict_mode: Option\u003cbool\u003e,\n    block_on_coverage_decrease: Option\u003cbool\u003e,\n    block_on_new_vulnerabilities: Option\u003cbool\u003e,\n    block_on_new_warnings: Option\u003cbool\u003e,\n}\n\nstruct CheckResult {\n    name: String,\n    passed: bool,\n    message: String,\n}\n\nfn main() -\u003e Result\u003c()\u003e {\n    println!(\"üîç V√©rification des seuils de qualit√©...\\n\");\n\n    let gates = load_quality_gates()?;\n    let mut results = Vec::new();\n    let mut failed_checks = 0;\n\n    // V√©rifier la couverture\n    if let Some(coverage) = \u0026gates.coverage {\n        if let Some(minimum) = coverage.minimum {\n            match check_coverage(minimum) {\n                Ok(result) =\u003e {\n                    if !result.passed {\n                        failed_checks += 1;\n                    }\n                    results.push(result);\n                }\n                Err(e) =\u003e {\n                    println!(\"‚ö†Ô∏è  V√©rification de couverture ignor√©e: {}\", e);\n                }\n            }\n        }\n    }\n\n    // V√©rifier Clippy\n    if let Some(clippy) = \u0026gates.clippy {\n        if let Some(max_warnings) = clippy.max_warnings {\n            match check_clippy(max_warnings) {\n                Ok(result) =\u003e {\n                    if !result.passed {\n                        failed_checks += 1;\n                    }\n                    results.push(result);\n                }\n                Err(e) =\u003e {\n                    println!(\"‚ö†Ô∏è  V√©rification Clippy ignor√©e: {}\", e);\n                }\n            }\n        }\n    }\n\n    // V√©rifier la s√©curit√©\n    if let Some(security) = \u0026gates.security {\n        match check_security(security) {\n            Ok(result) =\u003e {\n                if !result.passed {\n                    failed_checks += 1;\n                }\n                results.push(result);\n            }\n            Err(e) =\u003e {\n                println!(\"‚ö†Ô∏è  V√©rification de s√©curit√© ignor√©e: {}\", e);\n            }\n        }\n    }\n\n    // V√©rifier les d√©pendances\n    if let Some(deps) = \u0026gates.dependencies {\n        match check_dependencies(deps) {\n            Ok(result) =\u003e {\n                if !result.passed {\n                    failed_checks += 1;\n                }\n                results.push(result);\n            }\n            Err(e) =\u003e {\n                println!(\"‚ö†Ô∏è  V√©rification des d√©pendances ignor√©e: {}\", e);\n            }\n        }\n    }\n\n    // V√©rifier les m√©triques de code\n    if let Some(metrics) = \u0026gates.code_metrics {\n        match check_code_metrics(metrics) {\n            Ok(result) =\u003e {\n                for r in result {\n                    if !r.passed {\n                        failed_checks += 1;\n                    }\n                    results.push(r);\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"‚ö†Ô∏è  V√©rification des m√©triques ignor√©e: {}\", e);\n            }\n        }\n    }\n\n    // Afficher les r√©sultats\n    println!();\n    for result in \u0026results {\n        if result.passed {\n            println!(\"‚úÖ {}: {}\", result.name, result.message);\n        } else {\n            println!(\"‚ùå {}: {}\", result.name, result.message);\n        }\n    }\n\n    println!();\n    if failed_checks == 0 {\n        println!(\"‚úÖ Tous les seuils de qualit√© sont respect√©s !\");\n        Ok(())\n    } else {\n        println!(\"‚ùå {} seuil(s) de qualit√© non respect√©(s)\", failed_checks);\n        println!(\"La nightly build ne peut pas √™tre cr√©√©e.\");\n        std::process::exit(1);\n    }\n}\n\nfn load_quality_gates() -\u003e Result\u003cQualityGates\u003e {\n    let content = fs::read_to_string(\".github/quality-gates.toml\")\n        .context(\"Impossible de lire le fichier de configuration des seuils\")?;\n    let gates: QualityGates = toml::from_str(\u0026content)\n        .context(\"Erreur lors du parsing du fichier de configuration\")?;\n    Ok(gates)\n}\n\nfn check_coverage(minimum: f64) -\u003e Result\u003cCheckResult\u003e {\n    // Essayer de lire depuis un fichier XML de couverture\n    let coverage_file = \"coverage/cobertura.xml\";\n    if Path::new(coverage_file).exists() {\n        // Pour une impl√©mentation compl√®te, il faudrait parser le XML\n        // Ici, on utilise une approche simplifi√©e\n        let coverage = extract_coverage_from_xml(coverage_file)?;\n        let passed = coverage \u003e= minimum;\n        Ok(CheckResult {\n            name: \"Couverture de code\".to_string(),\n            passed,\n            message: format!(\"{:.2}% (minimum: {:.2}%)\", coverage, minimum),\n        })\n    } else {\n        // Essayer avec cargo-tarpaulin directement\n        let output = Command::new(\"cargo\")\n            .args(\u0026[\"tarpaulin\", \"--out\", \"Xml\", \"--output-dir\", \"/tmp\"])\n            .stderr(Stdio::null())\n            .output()?;\n\n        if output.status.success() {\n            // Parser la sortie pour extraire le pourcentage\n            let stdout = String::from_utf8_lossy(\u0026output.stdout);\n            let coverage = extract_coverage_from_output(\u0026stdout)?;\n            let passed = coverage \u003e= minimum;\n            Ok(CheckResult {\n                name: \"Couverture de code\".to_string(),\n                passed,\n                message: format!(\"{:.2}% (minimum: {:.2}%)\", coverage, minimum),\n            })\n        } else {\n            Err(anyhow::anyhow!(\"cargo-tarpaulin non disponible\"))\n        }\n    }\n}\n\nfn extract_coverage_from_xml(_file: \u0026str) -\u003e Result\u003cf64\u003e {\n    // Impl√©mentation simplifi√©e - dans un vrai projet, utiliser un parser XML\n    // Pour l'instant, on retourne une valeur par d√©faut\n    Ok(0.0)\n}\n\nfn extract_coverage_from_output(output: \u0026str) -\u003e Result\u003cf64\u003e {\n    // Extraire le pourcentage depuis la sortie de cargo-tarpaulin\n    for line in output.lines() {\n        if line.contains(\"%\") {\n            if let Some(percent_str) = line.split('%').next() {\n                if let Ok(coverage) = percent_str.trim().parse::\u003cf64\u003e() {\n                    return Ok(coverage);\n                }\n            }\n        }\n    }\n    Err(anyhow::anyhow!(\"Impossible d'extraire la couverture\"))\n}\n\nfn check_clippy(max_warnings: u32) -\u003e Result\u003cCheckResult\u003e {\n    let output = Command::new(\"cargo\")\n        .args(\u0026[\"clippy\", \"--all-targets\", \"--all-features\", \"--message-format=json\"])\n        .output()?;\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    let warnings = stdout\n        .lines()\n        .filter(|line| line.contains(r#\"\"level\":\"warning\"\"#))\n        .count() as u32;\n\n    let passed = warnings \u003c= max_warnings;\n    Ok(CheckResult {\n        name: \"Clippy warnings\".to_string(),\n        passed,\n        message: format!(\"{} warnings (maximum: {})\", warnings, max_warnings),\n    })\n}\n\nfn check_security(security: \u0026Security) -\u003e Result\u003cCheckResult\u003e {\n    let output = Command::new(\"cargo\")\n        .args(\u0026[\"audit\", \"--json\"])\n        .output();\n\n    match output {\n        Ok(output) =\u003e {\n            let stdout = String::from_utf8_lossy(\u0026output.stdout);\n            let critical = stdout.matches(r#\"\"severity\":\"critical\"\"#).count() as u32;\n            let high = stdout.matches(r#\"\"severity\":\"high\"\"#).count() as u32;\n\n            let max_critical = security.max_critical_vulnerabilities.unwrap_or(0);\n            let max_high = security.max_high_vulnerabilities.unwrap_or(0);\n\n            let passed = critical \u003c= max_critical \u0026\u0026 high \u003c= max_high;\n            Ok(CheckResult {\n                name: \"Vuln√©rabilit√©s de s√©curit√©\".to_string(),\n                passed,\n                message: format!(\n                    \"Critiques: {} (max: {}), Importantes: {} (max: {})\",\n                    critical, max_critical, high, max_high\n                ),\n            })\n        }\n        Err(_) =\u003e Err(anyhow::anyhow!(\"cargo-audit non disponible\")),\n    }\n}\n\nfn check_dependencies(deps: \u0026Dependencies) -\u003e Result\u003cCheckResult\u003e {\n    if let Some(max_outdated) = deps.max_outdated {\n        let output = Command::new(\"cargo\")\n            .args(\u0026[\"outdated\", \"--format\", \"json\"])\n            .output();\n\n        match output {\n            Ok(output) =\u003e {\n                let stdout = String::from_utf8_lossy(\u0026output.stdout);\n                let outdated = stdout.matches(r#\"\"name\"\"#).count() as u32;\n\n                let passed = outdated \u003c= max_outdated;\n                Ok(CheckResult {\n                    name: \"D√©pendances obsol√®tes\".to_string(),\n                    passed,\n                    message: format!(\"{} d√©pendances (maximum: {})\", outdated, max_outdated),\n                })\n            }\n            Err(_) =\u003e Err(anyhow::anyhow!(\"cargo-outdated non disponible\")),\n        }\n    } else {\n        Ok(CheckResult {\n            name: \"D√©pendances obsol√®tes\".to_string(),\n            passed: true,\n            message: \"V√©rification d√©sactiv√©e\".to_string(),\n        })\n    }\n}\n\nfn check_code_metrics(metrics: \u0026CodeMetrics) -\u003e Result\u003cVec\u003cCheckResult\u003e\u003e {\n    let mut results = Vec::new();\n\n    // V√©rifier le nombre de tests\n    if let Some(min_tests) = metrics.min_tests {\n        let output = Command::new(\"cargo\")\n            .args(\u0026[\"test\", \"--all-features\", \"--lib\", \"--tests\", \"--no-run\", \"--message-format=json\"])\n            .output()?;\n\n        let stdout = String::from_utf8_lossy(\u0026output.stdout);\n        let test_count = stdout.matches(r#\"\"type\":\"test\"\"#).count() as u32;\n\n        results.push(CheckResult {\n            name: \"Nombre de tests\".to_string(),\n            passed: test_count \u003e= min_tests,\n            message: format!(\"{} tests (minimum: {})\", test_count, min_tests),\n        });\n    }\n\n    // V√©rifier la taille du binaire\n    if let Some(max_size) = metrics.max_binary_size {\n        let binary_path = \"target/release/repolens\";\n        if Path::new(binary_path).exists() {\n            let metadata = fs::metadata(binary_path)?;\n            let size = metadata.len();\n            results.push(CheckResult {\n                name: \"Taille du binaire\".to_string(),\n                passed: size \u003c= max_size,\n                message: format!(\"{} bytes (maximum: {} bytes)\", size, max_size),\n            });\n        }\n    }\n\n    Ok(results)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","branch_protection.rs"],"content":"//! Branch protection configuration via GitHub API\n\nuse crate::error::{ActionError, ProviderError, RepoLensError};\nuse std::process::Command;\n\nuse super::plan::BranchProtectionSettings;\nuse crate::utils::prerequisites::{get_repo_info, is_gh_available};\n\n/// Configure branch protection for a branch\npub async fn configure(\n    branch: \u0026str,\n    settings: \u0026BranchProtectionSettings,\n) -\u003e Result\u003c(), RepoLensError\u003e {\n    // Check if gh CLI is available\n    if !is_gh_available() {\n        return Err(RepoLensError::Provider(\n            ProviderError::GitHubCliNotAvailable,\n        ));\n    }\n\n    // Get repository info\n    let repo = get_repo_info().map_err(|e| {\n        RepoLensError::Action(ActionError::ExecutionFailed {\n            message: format!(\"Failed to get repository info: {}\", e),\n        })\n    })?;\n\n    // Build the API request\n    let required_pr_reviews = if settings.required_approvals \u003e 0 {\n        format!(\n            r#\"{{\"required_approving_review_count\":{},\"dismiss_stale_reviews\":true}}\"#,\n            settings.required_approvals\n        )\n    } else {\n        \"null\".to_string()\n    };\n\n    let required_status_checks = if settings.require_status_checks {\n        r#\"{\"strict\":true,\"contexts\":[]}\"#.to_string()\n    } else {\n        \"null\".to_string()\n    };\n\n    // Execute the API call\n    let output = Command::new(\"gh\")\n        .args([\n            \"api\",\n            \u0026format!(\"repos/{}/branches/{}/protection\", repo, branch),\n            \"--method\",\n            \"PUT\",\n            \"--field\",\n            \u0026format!(\"required_status_checks={}\", required_status_checks),\n            \"--field\",\n            \u0026format!(\"enforce_admins={}\", settings.enforce_admins),\n            \"--field\",\n            \u0026format!(\"required_pull_request_reviews={}\", required_pr_reviews),\n            \"--field\",\n            \"restrictions=null\",\n            \"--field\",\n            \u0026format!(\n                \"required_linear_history={}\",\n                settings.require_linear_history\n            ),\n            \"--field\",\n            \u0026format!(\"allow_force_pushes={}\", !settings.block_force_push),\n            \"--field\",\n            \u0026format!(\"allow_deletions={}\", !settings.block_deletions),\n            \"--field\",\n            \u0026format!(\n                \"required_conversation_resolution={}\",\n                settings.require_conversation_resolution\n            ),\n        ])\n        .output()\n        .map_err(|_| {\n            RepoLensError::Provider(ProviderError::CommandFailed {\n                command: format!(\"gh api repos/{}/branches/{}/protection\", repo, branch),\n            })\n        })?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n\n        // Check for common errors\n        if stderr.contains(\"Resource not accessible\") {\n            return Err(RepoLensError::Action(ActionError::ExecutionFailed {\n                message: \"Cannot configure branch protection. This may require admin access or \\\n                the repository may not support this feature (e.g., free private repos).\"\n                    .to_string(),\n            }));\n        }\n\n        return Err(RepoLensError::Action(ActionError::ExecutionFailed {\n            message: format!(\"Failed to configure branch protection: {}\", stderr),\n        }));\n    }\n\n    // Configure signed commits if required (separate API call)\n    if settings.require_signed_commits {\n        let output = Command::new(\"gh\")\n            .args([\n                \"api\",\n                \u0026format!(\n                    \"repos/{}/branches/{}/protection/required_signatures\",\n                    repo, branch\n                ),\n                \"--method\",\n                \"POST\",\n            ])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: format!(\n                        \"gh api repos/{}/branches/{}/protection/required_signatures\",\n                        repo, branch\n                    ),\n                })\n            })?;\n\n        if !output.status.success() {\n            // Non-fatal: signed commits may not be available\n            tracing::warn!(\"Could not enable signed commits requirement (may require GitHub Pro)\");\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":10,"address":[150768],"length":1,"stats":{"Line":0}},{"line":15,"address":[1169747,1169837],"length":1,"stats":{"Line":0}},{"line":16,"address":[1169855],"length":1,"stats":{"Line":0}},{"line":17,"address":[1169843],"length":1,"stats":{"Line":0}},{"line":22,"address":[1169967,1170054,1170160,1176580,1176873,1176624,1176879],"length":1,"stats":{"Line":0}},{"line":23,"address":[1176795],"length":1,"stats":{"Line":0}},{"line":24,"address":[791874,791826],"length":1,"stats":{"Line":0}},{"line":29,"address":[1170297],"length":1,"stats":{"Line":0}},{"line":30,"address":[1170341,1170426],"length":1,"stats":{"Line":0}},{"line":35,"address":[1170404,1170302],"length":1,"stats":{"Line":0}},{"line":38,"address":[1170414],"length":1,"stats":{"Line":0}},{"line":39,"address":[1170559,1170663],"length":1,"stats":{"Line":0}},{"line":41,"address":[1170528,1170634],"length":1,"stats":{"Line":0}},{"line":45,"address":[1173241,1170636,1173430],"length":1,"stats":{"Line":0}},{"line":46,"address":[1172798],"length":1,"stats":{"Line":0}},{"line":48,"address":[785942,785874],"length":1,"stats":{"Line":0}},{"line":52,"address":[1171024],"length":1,"stats":{"Line":0}},{"line":54,"address":[1171266],"length":1,"stats":{"Line":0}},{"line":56,"address":[1171496],"length":1,"stats":{"Line":0}},{"line":60,"address":[1171738],"length":1,"stats":{"Line":0}},{"line":65,"address":[1171976],"length":1,"stats":{"Line":0}},{"line":67,"address":[1172232],"length":1,"stats":{"Line":0}},{"line":69,"address":[1172488],"length":1,"stats":{"Line":0}},{"line":75,"address":[792064,792409,792403],"length":1,"stats":{"Line":0}},{"line":76,"address":[1177129],"length":1,"stats":{"Line":0}},{"line":77,"address":[1176993,1176928],"length":1,"stats":{"Line":0}},{"line":81,"address":[1174130],"length":1,"stats":{"Line":0}},{"line":82,"address":[1174227,1174165],"length":1,"stats":{"Line":0}},{"line":85,"address":[789414,789497],"length":1,"stats":{"Line":0}},{"line":86,"address":[1174658],"length":1,"stats":{"Line":0}},{"line":87,"address":[789561],"length":1,"stats":{"Line":0}},{"line":93,"address":[1174527],"length":1,"stats":{"Line":0}},{"line":94,"address":[1174366,1174427],"length":1,"stats":{"Line":0}},{"line":99,"address":[1174202],"length":1,"stats":{"Line":0}},{"line":100,"address":[789997,790613,790430],"length":1,"stats":{"Line":0}},{"line":101,"address":[1175149],"length":1,"stats":{"Line":0}},{"line":103,"address":[790095,790024],"length":1,"stats":{"Line":0}},{"line":111,"address":[1177264,1177609,1177603],"length":1,"stats":{"Line":0}},{"line":112,"address":[1177497],"length":1,"stats":{"Line":0}},{"line":113,"address":[1177296,1177361],"length":1,"stats":{"Line":0}},{"line":120,"address":[1175725],"length":1,"stats":{"Line":0}},{"line":122,"address":[1175801,1175754],"length":1,"stats":{"Line":0}},{"line":126,"address":[1174799],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":43},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","executor.rs"],"content":"//! Action executor - Executes planned actions\n//!\n//! This module provides functionality to execute actions from an action plan.\n//! It handles the actual execution of file creation, .gitignore updates,\n//! branch protection configuration, and GitHub settings updates.\n\nuse crate::error::RepoLensError;\nuse tracing::{debug, info};\n\nuse crate::config::Config;\n\nuse super::plan::{Action, ActionOperation, ActionPlan};\nuse super::{branch_protection, github_settings, gitignore, templates};\n\n/// Result of executing a single action\n///\n/// Contains information about whether an action succeeded or failed,\n/// along with any error message if it failed.\n#[derive(Debug)]\npub struct ActionResult {\n    /// Name/description of the action that was executed\n    pub action_name: String,\n    /// Whether the action succeeded\n    pub success: bool,\n    /// Error message if the action failed, `None` if it succeeded\n    pub error: Option\u003cString\u003e,\n}\n\n/// Executes actions from an action plan\n///\n/// The `ActionExecutor` takes an `ActionPlan` and executes each action\n/// sequentially. It handles different types of operations like file creation,\n/// .gitignore updates, and GitHub API calls.\npub struct ActionExecutor {\n    /// Configuration (currently unused but kept for future extensibility)\n    _config: Config,\n}\n\nimpl ActionExecutor {\n    /// Create a new action executor with the given configuration\n    ///\n    /// # Arguments\n    ///\n    /// * `config` - The configuration to use for execution\n    ///\n    /// # Returns\n    ///\n    /// A new `ActionExecutor` instance\n    pub fn new(config: Config) -\u003e Self {\n        Self { _config: config }\n    }\n\n    /// Execute all actions in the plan\n    ///\n    /// Executes each action sequentially and collects results. If an action\n    /// fails, execution continues with the next action.\n    ///\n    /// # Arguments\n    ///\n    /// * `plan` - The action plan to execute\n    ///\n    /// # Returns\n    ///\n    /// A vector of `ActionResult` for each action, indicating success or failure\n    ///\n    /// # Errors\n    ///\n    /// Returns an error only if there's a critical failure in the executor itself\n    pub async fn execute(\u0026self, plan: \u0026ActionPlan) -\u003e Result\u003cVec\u003cActionResult\u003e, RepoLensError\u003e {\n        let mut results = Vec::new();\n\n        for action in plan.actions() {\n            info!(\"Executing action: {}\", action.id());\n\n            let result = self.execute_action(action).await;\n\n            results.push(ActionResult {\n                action_name: action.description().to_string(),\n                success: result.is_ok(),\n                error: result.err().map(|e| e.to_string()),\n            });\n        }\n\n        Ok(results)\n    }\n\n    /// Execute a single action\n    ///\n    /// # Arguments\n    ///\n    /// * `action` - The action to execute\n    ///\n    /// # Returns\n    ///\n    /// `Ok(())` if the action succeeded, or an error if it failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the action execution fails\n    async fn execute_action(\u0026self, action: \u0026Action) -\u003e Result\u003c(), RepoLensError\u003e {\n        match action.operation() {\n            ActionOperation::UpdateGitignore { entries } =\u003e {\n                debug!(\"Updating .gitignore with {} entries\", entries.len());\n                // Get current directory at the start to avoid race conditions in parallel tests\n                let current_dir = std::env::current_dir().map_err(|e| {\n                    RepoLensError::Action(crate::error::ActionError::ExecutionFailed {\n                        message: format!(\"Failed to get current directory: {}\", e),\n                    })\n                })?;\n                gitignore::update_gitignore_at(\u0026current_dir, entries)?;\n            }\n\n            ActionOperation::CreateFile {\n                path,\n                template,\n                variables,\n            } =\u003e {\n                debug!(\"Creating file {} from template {}\", path, template);\n                templates::create_file_from_template(path, template, variables)?;\n            }\n\n            ActionOperation::ConfigureBranchProtection { branch, settings } =\u003e {\n                debug!(\"Configuring branch protection for {}\", branch);\n                branch_protection::configure(branch, settings).await?;\n            }\n\n            ActionOperation::UpdateGitHubSettings { settings } =\u003e {\n                debug!(\"Updating GitHub repository settings\");\n                github_settings::update(settings).await?;\n            }\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::actions::plan::{ActionOperation, ActionPlan};\n    use std::collections::HashMap;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_execute_action_update_gitignore() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let root_abs = root.canonicalize().unwrap_or_else(|_| root.to_path_buf());\n\n        // Save current directory (fallback to /tmp if current dir is invalid)\n        let original_dir =\n            std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from(\"/tmp\"));\n\n        // Ensure we're in a valid directory before changing\n        if std::env::current_dir().is_err() {\n            let _ = std::env::set_current_dir(\"/tmp\");\n        }\n\n        // Change to temp directory\n        std::env::set_current_dir(\u0026root_abs).expect(\"Failed to change to temp directory\");\n\n        let config = Config::default();\n        let executor = ActionExecutor::new(config);\n\n        let action = Action::new(\n            \"test-gitignore\",\n            \"gitignore\",\n            \"Test gitignore update\",\n            ActionOperation::UpdateGitignore {\n                entries: vec![\".env\".to_string(), \"*.key\".to_string()],\n            },\n        );\n\n        // Execute action - it will get current_dir at start, but we ensure it's correct\n        // by setting it just before execution. However, parallel tests might still interfere,\n        // so we also verify the file was created using absolute path.\n        std::env::set_current_dir(\u0026root_abs)\n            .expect(\"Failed to restore temp directory before execution\");\n\n        let result = executor.execute_action(\u0026action).await;\n\n        // Restore directory immediately after execution\n        let _ = std::env::set_current_dir(\u0026original_dir);\n\n        // Check result after restoring directory\n        assert!(\n            result.is_ok(),\n            \"Action execution failed: {:?}\",\n            result.err()\n        );\n\n        // Verify file was created in the temp directory using absolute path\n        // This works regardless of what the current directory is\n        let gitignore_path = root_abs.join(\".gitignore\");\n        assert!(\n            gitignore_path.exists(),\n            \".gitignore not found at {:?}. Root was: {:?}\",\n            gitignore_path,\n            root_abs\n        );\n    }\n\n    #[tokio::test]\n    async fn test_execute_action_create_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Save current directory (fallback to /tmp if current dir is invalid)\n        let original_dir =\n            std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from(\"/tmp\"));\n\n        // Ensure we're in a valid directory before changing\n        if std::env::current_dir().is_err() {\n            let _ = std::env::set_current_dir(\"/tmp\");\n        }\n\n        std::env::set_current_dir(root).expect(\"Failed to change to temp directory\");\n\n        let config = Config::default();\n        let executor = ActionExecutor::new(config);\n\n        let action = Action::new(\n            \"test-create\",\n            \"file\",\n            \"Test file creation\",\n            ActionOperation::CreateFile {\n                path: \"TEST.md\".to_string(),\n                template: \"CONTRIBUTING.md\".to_string(),\n                variables: HashMap::new(),\n            },\n        );\n\n        let result = executor.execute_action(\u0026action).await;\n\n        // May fail if template doesn't exist, but that's ok for test\n        // We're testing that the function handles it gracefully\n        let _ = result;\n\n        // Restore directory (ignore errors if directory no longer exists)\n        let _ = std::env::set_current_dir(\u0026original_dir);\n    }\n\n    #[tokio::test]\n    async fn test_execute_all_actions() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Save current directory (fallback to /tmp if current dir is invalid)\n        let original_dir =\n            std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from(\"/tmp\"));\n\n        // Ensure we're in a valid directory before changing\n        if std::env::current_dir().is_err() {\n            let _ = std::env::set_current_dir(\"/tmp\");\n        }\n\n        std::env::set_current_dir(root).expect(\"Failed to change to temp directory\");\n\n        let config = Config::default();\n        let executor = ActionExecutor::new(config);\n\n        let mut plan = ActionPlan::new();\n        plan.add(Action::new(\n            \"test-1\",\n            \"gitignore\",\n            \"Test 1\",\n            ActionOperation::UpdateGitignore {\n                entries: vec![\".env\".to_string()],\n            },\n        ));\n\n        let results = executor.execute(\u0026plan).await.unwrap();\n\n        assert_eq!(results.len(), 1);\n        assert!(results[0].success);\n\n        // Restore directory (ignore errors if directory no longer exists)\n        let _ = std::env::set_current_dir(\u0026original_dir);\n    }\n\n    #[tokio::test]\n    async fn test_execute_handles_errors_gracefully() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Save current directory (fallback to /tmp if current dir is invalid)\n        let original_dir =\n            std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from(\"/tmp\"));\n\n        // Ensure we're in a valid directory before changing\n        if std::env::current_dir().is_err() {\n            let _ = std::env::set_current_dir(\"/tmp\");\n        }\n\n        std::env::set_current_dir(root).expect(\"Failed to change to temp directory\");\n\n        let config = Config::default();\n        let executor = ActionExecutor::new(config);\n\n        let mut plan = ActionPlan::new();\n        // Add an action that will fail (invalid template)\n        plan.add(Action::new(\n            \"test-fail\",\n            \"file\",\n            \"Test failure\",\n            ActionOperation::CreateFile {\n                path: \"INVALID.md\".to_string(),\n                template: \"NONEXISTENT_TEMPLATE.md\".to_string(),\n                variables: HashMap::new(),\n            },\n        ));\n\n        let results = executor.execute(\u0026plan).await.unwrap();\n\n        assert_eq!(results.len(), 1);\n        assert!(!results[0].success);\n        assert!(results[0].error.is_some());\n\n        // Restore directory (ignore errors if directory no longer exists)\n        let _ = std::env::set_current_dir(\u0026original_dir);\n    }\n}\n","traces":[{"line":49,"address":[436032],"length":1,"stats":{"Line":5}},{"line":69,"address":[983615,983793,984001,983568,985637,983750],"length":1,"stats":{"Line":16}},{"line":70,"address":[983731],"length":1,"stats":{"Line":4}},{"line":72,"address":[984737,983851,983931],"length":1,"stats":{"Line":10}},{"line":73,"address":[984999,985256,984806],"length":1,"stats":{"Line":8}},{"line":75,"address":[269031],"length":1,"stats":{"Line":12}},{"line":77,"address":[984634,984355],"length":1,"stats":{"Line":4}},{"line":78,"address":[984444,984375],"length":1,"stats":{"Line":4}},{"line":79,"address":[984471],"length":1,"stats":{"Line":2}},{"line":80,"address":[984523,985664,985680],"length":1,"stats":{"Line":6}},{"line":84,"address":[984842],"length":1,"stats":{"Line":3}},{"line":100,"address":[989780,985807,985987,987646,985923,985760],"length":1,"stats":{"Line":12}},{"line":101,"address":[986042,985908],"length":1,"stats":{"Line":6}},{"line":102,"address":[986114],"length":1,"stats":{"Line":2}},{"line":103,"address":[986134,986391,986678],"length":1,"stats":{"Line":4}},{"line":105,"address":[987019,990765,987125,990771,987652,990512,986656],"length":1,"stats":{"Line":4}},{"line":106,"address":[482207],"length":1,"stats":{"Line":0}},{"line":107,"address":[990598,990533],"length":1,"stats":{"Line":0}},{"line":110,"address":[478857,478750],"length":1,"stats":{"Line":4}},{"line":113,"address":[986196],"length":1,"stats":{"Line":2}},{"line":118,"address":[987661,987960,986216],"length":1,"stats":{"Line":4}},{"line":119,"address":[988317,987926,988537],"length":1,"stats":{"Line":6}},{"line":122,"address":[477775],"length":1,"stats":{"Line":0}},{"line":123,"address":[988810,988549,986294],"length":1,"stats":{"Line":0}},{"line":124,"address":[269553],"length":1,"stats":{"Line":0}},{"line":127,"address":[986333],"length":1,"stats":{"Line":0}},{"line":128,"address":[986353,989230,989479],"length":1,"stats":{"Line":0}},{"line":129,"address":[269569],"length":1,"stats":{"Line":0}},{"line":133,"address":[987559],"length":1,"stats":{"Line":2}}],"covered":21,"coverable":29},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","github_settings.rs"],"content":"//! GitHub repository settings management\n\nuse crate::error::{ActionError, ProviderError, RepoLensError};\nuse std::process::Command;\n\nuse super::plan::GitHubRepoSettings;\nuse crate::utils::prerequisites::{get_repo_info, is_gh_available};\n\n/// Update GitHub repository settings\npub async fn update(settings: \u0026GitHubRepoSettings) -\u003e Result\u003c(), RepoLensError\u003e {\n    // Check if gh CLI is available\n    if !is_gh_available() {\n        return Err(RepoLensError::Provider(\n            ProviderError::GitHubCliNotAvailable,\n        ));\n    }\n\n    // Get repository info\n    let repo = get_repo_info().map_err(|e| {\n        RepoLensError::Action(ActionError::ExecutionFailed {\n            message: format!(\"Failed to get repository info: {}\", e),\n        })\n    })?;\n\n    // Update repository settings\n    let mut args = vec![\"repo\", \"edit\"];\n\n    if let Some(true) = settings.enable_discussions {\n        args.push(\"--enable-discussions\");\n    }\n\n    if let Some(false) = settings.enable_wiki {\n        args.push(\"--enable-wiki=false\");\n    }\n\n    // Execute repository edit\n    if args.len() \u003e 2 {\n        let output = Command::new(\"gh\").args(\u0026args).output().map_err(|_| {\n            RepoLensError::Provider(ProviderError::CommandFailed {\n                command: format!(\"gh {}\", args.join(\" \")),\n            })\n        })?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(\u0026output.stderr);\n            tracing::warn!(\"Could not update some repository settings: {}\", stderr);\n        }\n    }\n\n    // Enable vulnerability alerts\n    if let Some(true) = settings.enable_vulnerability_alerts {\n        let output = Command::new(\"gh\")\n            .args([\n                \"api\",\n                \u0026format!(\"repos/{}/vulnerability-alerts\", repo),\n                \"--method\",\n                \"PUT\",\n            ])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: format!(\"gh api repos/{}/vulnerability-alerts\", repo),\n                })\n            })?;\n\n        if !output.status.success() {\n            tracing::warn!(\n                \"Could not enable vulnerability alerts (may require specific permissions)\"\n            );\n        }\n    }\n\n    // Enable automated security fixes\n    if let Some(true) = settings.enable_automated_security_fixes {\n        let output = Command::new(\"gh\")\n            .args([\n                \"api\",\n                \u0026format!(\"repos/{}/automated-security-fixes\", repo),\n                \"--method\",\n                \"PUT\",\n            ])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: format!(\"gh api repos/{}/automated-security-fixes\", repo),\n                })\n            })?;\n\n        if !output.status.success() {\n            tracing::warn!(\n                \"Could not enable automated security fixes (may require specific permissions)\"\n            );\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":10,"address":[121304,121296],"length":1,"stats":{"Line":0}},{"line":12,"address":[1487575,1487485],"length":1,"stats":{"Line":0}},{"line":13,"address":[1487593],"length":1,"stats":{"Line":0}},{"line":14,"address":[574909],"length":1,"stats":{"Line":0}},{"line":19,"address":[1493081,1493087,1492786,1487782,1487705,1492832,1487888],"length":1,"stats":{"Line":0}},{"line":20,"address":[1493003],"length":1,"stats":{"Line":0}},{"line":21,"address":[1492866,1492914],"length":1,"stats":{"Line":0}},{"line":26,"address":[1488062,1487995],"length":1,"stats":{"Line":0}},{"line":28,"address":[1488213],"length":1,"stats":{"Line":0}},{"line":29,"address":[1488363,1488281],"length":1,"stats":{"Line":0}},{"line":32,"address":[1488256,1488373],"length":1,"stats":{"Line":0}},{"line":33,"address":[1488406],"length":1,"stats":{"Line":0}},{"line":37,"address":[1488379,1488454],"length":1,"stats":{"Line":0}},{"line":38,"address":[1488610,1493608,1493104,1493614,1488500,1488768],"length":1,"stats":{"Line":0}},{"line":39,"address":[1493502],"length":1,"stats":{"Line":0}},{"line":40,"address":[1493208,1493131],"length":1,"stats":{"Line":0}},{"line":44,"address":[1488988],"length":1,"stats":{"Line":0}},{"line":45,"address":[1489092,1489023],"length":1,"stats":{"Line":0}},{"line":46,"address":[1489111,1489190,1489477],"length":1,"stats":{"Line":0}},{"line":51,"address":[1488468,1489773],"length":1,"stats":{"Line":0}},{"line":52,"address":[1490402,1489819,1490221],"length":1,"stats":{"Line":0}},{"line":53,"address":[577436],"length":1,"stats":{"Line":0}},{"line":55,"address":[1489917,1489846],"length":1,"stats":{"Line":0}},{"line":60,"address":[1493918,1493924,1493632],"length":1,"stats":{"Line":0}},{"line":61,"address":[1493812],"length":1,"stats":{"Line":0}},{"line":62,"address":[1493723,1493658],"length":1,"stats":{"Line":0}},{"line":66,"address":[1490682],"length":1,"stats":{"Line":0}},{"line":67,"address":[578098,578045],"length":1,"stats":{"Line":0}},{"line":74,"address":[1489787,1491279],"length":1,"stats":{"Line":0}},{"line":75,"address":[1491709,1491884,1491319],"length":1,"stats":{"Line":0}},{"line":76,"address":[1491596],"length":1,"stats":{"Line":0}},{"line":78,"address":[1491346,1491417],"length":1,"stats":{"Line":0}},{"line":83,"address":[1494244,1493952,1494238],"length":1,"stats":{"Line":0}},{"line":84,"address":[1494132],"length":1,"stats":{"Line":0}},{"line":85,"address":[1493978,1494043],"length":1,"stats":{"Line":0}},{"line":89,"address":[1492164],"length":1,"stats":{"Line":0}},{"line":90,"address":[1492193,1492240],"length":1,"stats":{"Line":0}},{"line":96,"address":[1491285],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":38},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","gitignore.rs"],"content":"//! Gitignore file management\n\nuse crate::error::{ActionError, RepoLensError};\nuse std::fs;\nuse std::path::Path;\n\n/// Update .gitignore with new entries at the given root path\npub fn update_gitignore_at(root: \u0026Path, entries: \u0026[String]) -\u003e Result\u003c(), RepoLensError\u003e {\n    let gitignore_path = root.join(\".gitignore\");\n\n    // Read existing content or create empty\n    let mut content = if gitignore_path.exists() {\n        fs::read_to_string(\u0026gitignore_path).map_err(|e| {\n            RepoLensError::Scan(crate::error::ScanError::FileRead {\n                path: gitignore_path.display().to_string(),\n                source: e,\n            })\n        })?\n    } else {\n        String::new()\n    };\n\n    // Track what we add\n    let mut added = Vec::new();\n\n    for entry in entries {\n        // Check if entry already exists (handle various formats)\n        let entry_clean = entry.trim_end_matches('/');\n        let entry_patterns = [\n            entry.as_str(),\n            \u0026format!(\"/{}\", entry),\n            \u0026format!(\"{}/\", entry),\n            entry_clean,\n            \u0026format!(\"/{}\", entry_clean),\n            \u0026format!(\"{}/\", entry_clean),\n        ];\n\n        let exists = content.lines().any(|line| {\n            let line = line.trim();\n            let line_clean = line.trim_end_matches('/');\n            entry_patterns\n                .iter()\n                .any(|p| line == *p || line_clean == entry_clean)\n        });\n\n        if !exists {\n            added.push(entry.clone());\n        }\n    }\n\n    if added.is_empty() {\n        return Ok(());\n    }\n\n    // Add a newline if the file doesn't end with one\n    if !content.is_empty() \u0026\u0026 !content.ends_with('\\n') {\n        content.push('\\n');\n    }\n\n    // Add comment separator if there's existing content\n    if !content.is_empty() {\n        content.push_str(\"\\n# Added by repolens\\n\");\n    }\n\n    // Add new entries\n    for entry in \u0026added {\n        content.push_str(entry);\n        content.push('\\n');\n    }\n\n    // Write back\n    fs::write(\u0026gitignore_path, content).map_err(|e| {\n        RepoLensError::Action(ActionError::FileWrite {\n            path: gitignore_path.display().to_string(),\n            source: e,\n        })\n    })?;\n\n    Ok(())\n}\n\n/// Update .gitignore with new entries in current directory\n#[allow(dead_code)] // Kept for public API, may be used by external code\npub fn update_gitignore(entries: \u0026[String]) -\u003e Result\u003c(), RepoLensError\u003e {\n    let current_dir = std::env::current_dir().map_err(|e| {\n        RepoLensError::Action(ActionError::ExecutionFailed {\n            message: format!(\"Failed to get current directory: {}\", e),\n        })\n    })?;\n    update_gitignore_at(\u0026current_dir, entries)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_update_gitignore_new_file() {\n        let dir = tempdir().unwrap();\n\n        update_gitignore_at(dir.path(), \u0026[\".env\".to_string(), \"*.key\".to_string()]).unwrap();\n\n        let content = fs::read_to_string(dir.path().join(\".gitignore\")).unwrap();\n        assert!(content.contains(\".env\"));\n        assert!(content.contains(\"*.key\"));\n    }\n\n    #[test]\n    fn test_update_gitignore_existing_file() {\n        let dir = tempdir().unwrap();\n\n        fs::write(dir.path().join(\".gitignore\"), \"node_modules/\\n\").unwrap();\n\n        update_gitignore_at(\n            dir.path(),\n            \u0026[\".env\".to_string(), \"node_modules\".to_string()],\n        )\n        .unwrap();\n\n        let content = fs::read_to_string(dir.path().join(\".gitignore\")).unwrap();\n        assert!(content.contains(\"node_modules\"));\n        assert!(content.contains(\".env\"));\n        // Should not duplicate\n        assert_eq!(content.matches(\"node_modules\").count(), 1);\n    }\n}\n","traces":[{"line":8,"address":[348623,348656,345472],"length":1,"stats":{"Line":4}},{"line":9,"address":[1515128],"length":1,"stats":{"Line":4}},{"line":12,"address":[1515182,1515265,1515627],"length":1,"stats":{"Line":10}},{"line":13,"address":[30070,29808,30064],"length":1,"stats":{"Line":4}},{"line":14,"address":[29978],"length":1,"stats":{"Line":0}},{"line":15,"address":[267780,267707],"length":1,"stats":{"Line":0}},{"line":16,"address":[29973],"length":1,"stats":{"Line":0}},{"line":20,"address":[1515330,1515300],"length":1,"stats":{"Line":4}},{"line":24,"address":[1515338],"length":1,"stats":{"Line":2}},{"line":26,"address":[1515689,1515773],"length":1,"stats":{"Line":8}},{"line":28,"address":[1516809,1515879],"length":1,"stats":{"Line":8}},{"line":29,"address":[1517848],"length":1,"stats":{"Line":4}},{"line":30,"address":[1516873],"length":1,"stats":{"Line":4}},{"line":31,"address":[1516936],"length":1,"stats":{"Line":4}},{"line":32,"address":[1517164],"length":1,"stats":{"Line":4}},{"line":34,"address":[1517380],"length":1,"stats":{"Line":4}},{"line":35,"address":[1517596],"length":1,"stats":{"Line":4}},{"line":38,"address":[348384],"length":1,"stats":{"Line":6}},{"line":39,"address":[30144],"length":1,"stats":{"Line":2}},{"line":40,"address":[30159],"length":1,"stats":{"Line":2}},{"line":41,"address":[30195,30253],"length":1,"stats":{"Line":4}},{"line":43,"address":[268160,268179,268096],"length":1,"stats":{"Line":6}},{"line":46,"address":[1518061],"length":1,"stats":{"Line":2}},{"line":47,"address":[348481,348527],"length":1,"stats":{"Line":4}},{"line":51,"address":[1515913],"length":1,"stats":{"Line":2}},{"line":52,"address":[1515982],"length":1,"stats":{"Line":0}},{"line":56,"address":[346376,346417,346492],"length":1,"stats":{"Line":6}},{"line":57,"address":[1516125],"length":1,"stats":{"Line":0}},{"line":61,"address":[346557,346462],"length":1,"stats":{"Line":4}},{"line":62,"address":[1516147,1516209],"length":1,"stats":{"Line":4}},{"line":66,"address":[1516174,1516227],"length":1,"stats":{"Line":4}},{"line":67,"address":[1516708,1516333],"length":1,"stats":{"Line":8}},{"line":68,"address":[347144],"length":1,"stats":{"Line":5}},{"line":72,"address":[30622,30368,30616],"length":1,"stats":{"Line":5}},{"line":73,"address":[30541],"length":1,"stats":{"Line":0}},{"line":74,"address":[30395,30468],"length":1,"stats":{"Line":0}},{"line":75,"address":[268408],"length":1,"stats":{"Line":0}},{"line":79,"address":[347014],"length":1,"stats":{"Line":6}},{"line":84,"address":[1518256,1518590,1518596],"length":1,"stats":{"Line":0}},{"line":85,"address":[30899,30893,30640],"length":1,"stats":{"Line":0}},{"line":86,"address":[30815],"length":1,"stats":{"Line":0}},{"line":87,"address":[30726,30661],"length":1,"stats":{"Line":0}},{"line":90,"address":[1518481,1518559],"length":1,"stats":{"Line":0}}],"covered":30,"coverable":43},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","mod.rs"],"content":"//! Actions module - Planned changes and execution\n\nmod branch_protection;\npub mod executor;\nmod github_settings;\nmod gitignore;\npub mod plan;\npub mod planner;\nmod templates;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","plan.rs"],"content":"//! Action plan structures\n\nuse serde::{Deserialize, Serialize};\n\n/// A single action to be performed\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Action {\n    /// Action identifier\n    id: String,\n    /// Action category\n    category: String,\n    /// Human-readable description\n    description: String,\n    /// Additional details about what will be changed\n    details: Vec\u003cString\u003e,\n    /// The actual operation to perform\n    operation: ActionOperation,\n}\n\nimpl Action {\n    /// Create a new action\n    pub fn new(\n        id: impl Into\u003cString\u003e,\n        category: impl Into\u003cString\u003e,\n        description: impl Into\u003cString\u003e,\n        operation: ActionOperation,\n    ) -\u003e Self {\n        Self {\n            id: id.into(),\n            category: category.into(),\n            description: description.into(),\n            details: Vec::new(),\n            operation,\n        }\n    }\n\n    /// Add a detail line\n    pub fn with_detail(mut self, detail: impl Into\u003cString\u003e) -\u003e Self {\n        self.details.push(detail.into());\n        self\n    }\n\n    /// Add multiple details\n    pub fn with_details(mut self, details: impl IntoIterator\u003cItem = impl Into\u003cString\u003e\u003e) -\u003e Self {\n        self.details.extend(details.into_iter().map(|d| d.into()));\n        self\n    }\n\n    /// Get the action ID\n    pub fn id(\u0026self) -\u003e \u0026str {\n        \u0026self.id\n    }\n\n    /// Get the category\n    pub fn category(\u0026self) -\u003e \u0026str {\n        \u0026self.category\n    }\n\n    /// Get the description\n    pub fn description(\u0026self) -\u003e \u0026str {\n        \u0026self.description\n    }\n\n    /// Get the details\n    pub fn details(\u0026self) -\u003e \u0026[String] {\n        \u0026self.details\n    }\n\n    /// Get the operation\n    pub fn operation(\u0026self) -\u003e \u0026ActionOperation {\n        \u0026self.operation\n    }\n}\n\n/// The type of operation to perform\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ActionOperation {\n    /// Update .gitignore file\n    UpdateGitignore { entries: Vec\u003cString\u003e },\n\n    /// Create a file from template\n    CreateFile {\n        path: String,\n        template: String,\n        variables: std::collections::HashMap\u003cString, String\u003e,\n    },\n\n    /// Configure branch protection\n    ConfigureBranchProtection {\n        branch: String,\n        settings: BranchProtectionSettings,\n    },\n\n    /// Update GitHub repository settings\n    UpdateGitHubSettings { settings: GitHubRepoSettings },\n}\n\n/// Branch protection settings\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BranchProtectionSettings {\n    pub required_approvals: u32,\n    pub require_status_checks: bool,\n    pub require_conversation_resolution: bool,\n    pub require_linear_history: bool,\n    pub block_force_push: bool,\n    pub block_deletions: bool,\n    pub enforce_admins: bool,\n    pub require_signed_commits: bool,\n}\n\nimpl Default for BranchProtectionSettings {\n    fn default() -\u003e Self {\n        Self {\n            required_approvals: 1,\n            require_status_checks: true,\n            require_conversation_resolution: true,\n            require_linear_history: true,\n            block_force_push: true,\n            block_deletions: true,\n            enforce_admins: true,\n            require_signed_commits: false,\n        }\n    }\n}\n\n/// GitHub repository settings\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct GitHubRepoSettings {\n    pub enable_discussions: Option\u003cbool\u003e,\n    pub enable_issues: Option\u003cbool\u003e,\n    pub enable_wiki: Option\u003cbool\u003e,\n    pub enable_vulnerability_alerts: Option\u003cbool\u003e,\n    pub enable_automated_security_fixes: Option\u003cbool\u003e,\n}\n\n/// A collection of actions to perform\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ActionPlan {\n    actions: Vec\u003cAction\u003e,\n}\n\nimpl ActionPlan {\n    /// Create a new empty action plan\n    pub fn new() -\u003e Self {\n        Self {\n            actions: Vec::new(),\n        }\n    }\n\n    /// Add an action to the plan\n    pub fn add(\u0026mut self, action: Action) {\n        self.actions.push(action);\n    }\n\n    /// Get all actions\n    pub fn actions(\u0026self) -\u003e \u0026[Action] {\n        \u0026self.actions\n    }\n\n    /// Check if the plan is empty\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.actions.is_empty()\n    }\n\n    /// Get the number of actions\n    #[allow(dead_code)]\n    pub fn len(\u0026self) -\u003e usize {\n        self.actions.len()\n    }\n\n    /// Filter to only include specific action categories\n    pub fn filter_only(\u0026mut self, categories: \u0026[String]) {\n        self.actions\n            .retain(|a| categories.contains(\u0026a.category.to_string()));\n    }\n\n    /// Filter to skip specific action categories\n    pub fn filter_skip(\u0026mut self, categories: \u0026[String]) {\n        self.actions\n            .retain(|a| !categories.contains(\u0026a.category.to_string()));\n    }\n}\n\nimpl Default for ActionPlan {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":22,"address":[1140221,1139587,1139617,1138992,1139632,1140265],"length":1,"stats":{"Line":6}},{"line":29,"address":[48618,49229],"length":1,"stats":{"Line":8}},{"line":30,"address":[],"length":0,"stats":{"Line":8}},{"line":31,"address":[],"length":0,"stats":{"Line":10}},{"line":32,"address":[1139348,1139985],"length":1,"stats":{"Line":10}},{"line":38,"address":[1140288,1140464,1140438,1140635],"length":1,"stats":{"Line":2}},{"line":39,"address":[1140517,1140385,1140320,1140582],"length":1,"stats":{"Line":4}},{"line":40,"address":[49938,50135],"length":1,"stats":{"Line":2}},{"line":44,"address":[1140656,1140810],"length":1,"stats":{"Line":3}},{"line":45,"address":[50380,50206,50352,50269],"length":1,"stats":{"Line":16}},{"line":46,"address":[1140790],"length":1,"stats":{"Line":5}},{"line":50,"address":[482032],"length":1,"stats":{"Line":3}},{"line":51,"address":[482037],"length":1,"stats":{"Line":3}},{"line":55,"address":[482048],"length":1,"stats":{"Line":0}},{"line":56,"address":[1017925],"length":1,"stats":{"Line":0}},{"line":60,"address":[482064],"length":1,"stats":{"Line":2}},{"line":61,"address":[482069],"length":1,"stats":{"Line":2}},{"line":65,"address":[482080],"length":1,"stats":{"Line":0}},{"line":66,"address":[1017957],"length":1,"stats":{"Line":0}},{"line":70,"address":[482112],"length":1,"stats":{"Line":3}},{"line":71,"address":[1017992],"length":1,"stats":{"Line":3}},{"line":112,"address":[482128],"length":1,"stats":{"Line":0}},{"line":144,"address":[482176],"length":1,"stats":{"Line":4}},{"line":146,"address":[1018061],"length":1,"stats":{"Line":4}},{"line":151,"address":[482240],"length":1,"stats":{"Line":4}},{"line":152,"address":[1018117],"length":1,"stats":{"Line":4}},{"line":156,"address":[482272],"length":1,"stats":{"Line":4}},{"line":157,"address":[1018149],"length":1,"stats":{"Line":4}},{"line":161,"address":[482288],"length":1,"stats":{"Line":2}},{"line":162,"address":[1018165],"length":1,"stats":{"Line":2}},{"line":167,"address":[482304],"length":1,"stats":{"Line":0}},{"line":168,"address":[482309],"length":1,"stats":{"Line":0}},{"line":172,"address":[482320],"length":1,"stats":{"Line":0}},{"line":173,"address":[1018210],"length":1,"stats":{"Line":0}},{"line":174,"address":[1140896,1140910],"length":1,"stats":{"Line":0}},{"line":178,"address":[482352],"length":1,"stats":{"Line":0}},{"line":179,"address":[482370],"length":1,"stats":{"Line":0}},{"line":180,"address":[1141070,1141056],"length":1,"stats":{"Line":0}},{"line":185,"address":[482384],"length":1,"stats":{"Line":0}},{"line":186,"address":[482392],"length":1,"stats":{"Line":0}}],"covered":25,"coverable":40},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","planner.rs"],"content":"//! Action planner - Creates action plans based on audit results\n//!\n//! This module provides functionality to generate action plans from audit results.\n//! It analyzes findings and creates appropriate actions to fix issues.\n\nuse std::collections::HashMap;\n\nuse crate::config::Config;\nuse crate::rules::results::AuditResults;\n\nuse super::plan::{\n    Action, ActionOperation, ActionPlan, BranchProtectionSettings, GitHubRepoSettings,\n};\n\n/// Parameters for planning file creation\nstruct FileCreationParams\u003c'a\u003e {\n    rule_id: \u0026'a str,\n    file_path: \u0026'a str,\n    template: \u0026'a str,\n    action_id: \u0026'a str,\n    action_description: \u0026'a str,\n    detail: Option\u003c\u0026'a str\u003e,\n}\n\n/// Creates action plans based on audit results and configuration\n///\n/// The `ActionPlanner` analyzes audit findings and generates a plan of actions\n/// to fix detected issues. Actions can include:\n/// - Creating missing files (LICENSE, CONTRIBUTING.md, etc.)\n/// - Updating .gitignore\n/// - Configuring branch protection\n/// - Updating GitHub repository settings\npub struct ActionPlanner {\n    /// Configuration for action planning\n    config: Config,\n}\n\nimpl ActionPlanner {\n    /// Create a new action planner with the given configuration\n    ///\n    /// # Arguments\n    ///\n    /// * `config` - The configuration that determines which actions to plan\n    ///\n    /// # Returns\n    ///\n    /// A new `ActionPlanner` instance\n    pub fn new(config: Config) -\u003e Self {\n        Self { config }\n    }\n\n    /// Create an action plan based on audit results\n    ///\n    /// Analyzes the audit results and generates actions to fix detected issues.\n    /// Only actions enabled in the configuration will be included.\n    ///\n    /// # Arguments\n    ///\n    /// * `results` - The audit results to analyze\n    ///\n    /// # Returns\n    ///\n    /// An `ActionPlan` containing all planned actions\n    pub fn create_plan(\u0026self, results: \u0026AuditResults) -\u003e ActionPlan {\n        let mut plan = ActionPlan::new();\n\n        // Plan gitignore updates\n        if self.config.actions.gitignore {\n            if let Some(action) = self.plan_gitignore_update(results) {\n                plan.add(action);\n            }\n        }\n\n        // Plan license creation\n        if self.config.actions.license.enabled {\n            if let Some(action) = self.plan_license_creation(results) {\n                plan.add(action);\n            }\n        }\n\n        // Plan CONTRIBUTING creation\n        if self.config.actions.contributing {\n            if let Some(action) = self.plan_contributing_creation(results) {\n                plan.add(action);\n            }\n        }\n\n        // Plan CODE_OF_CONDUCT creation\n        if self.config.actions.code_of_conduct {\n            if let Some(action) = self.plan_code_of_conduct_creation(results) {\n                plan.add(action);\n            }\n        }\n\n        // Plan SECURITY.md creation\n        if self.config.actions.security_policy {\n            if let Some(action) = self.plan_security_creation(results) {\n                plan.add(action);\n            }\n        }\n\n        // Plan branch protection\n        if self.config.actions.branch_protection.enabled {\n            plan.add(self.plan_branch_protection());\n        }\n\n        // Plan GitHub settings\n        plan.add(self.plan_github_settings());\n\n        plan\n    }\n\n    /// Plan .gitignore updates based on findings\n    ///\n    /// Collects entries that should be added to .gitignore from audit findings\n    /// and adds standard entries if they're missing.\n    ///\n    /// # Arguments\n    ///\n    /// * `results` - The audit results\n    ///\n    /// # Returns\n    ///\n    /// An `Action` to update .gitignore, or `None` if no updates are needed\n    fn plan_gitignore_update(\u0026self, results: \u0026AuditResults) -\u003e Option\u003cAction\u003e {\n        // Collect entries that should be added to .gitignore\n        let mut entries = Vec::new();\n\n        // Check findings for missing gitignore entries\n        for finding in results.findings_by_category(\"files\") {\n            if finding.rule_id == \"FILE003\" {\n                // Extract the pattern from the message\n                if let Some(pattern) = finding.message.split(\"entry: \").nth(1) {\n                    entries.push(pattern.to_string());\n                }\n            }\n        }\n\n        // Add standard entries if not present\n        let standard_entries = [\".env\", \"*.key\", \"*.pem\", \".DS_Store\"];\n        for entry in standard_entries {\n            if !entries.contains(\u0026entry.to_string()) {\n                entries.push(entry.to_string());\n            }\n        }\n\n        if entries.is_empty() {\n            return None;\n        }\n\n        Some(\n            Action::new(\n                \"gitignore-update\",\n                \"gitignore\",\n                \"Add entries to .gitignore\",\n                ActionOperation::UpdateGitignore {\n                    entries: entries.clone(),\n                },\n            )\n            .with_details(entries),\n        )\n    }\n\n    /// Plan LICENSE file creation\n    ///\n    /// Creates a LICENSE file if one is missing and license creation is enabled.\n    ///\n    /// # Arguments\n    ///\n    /// * `results` - The audit results\n    ///\n    /// # Returns\n    ///\n    /// An `Action` to create LICENSE, or `None` if not needed\n    fn plan_license_creation(\u0026self, results: \u0026AuditResults) -\u003e Option\u003cAction\u003e {\n        // Check if LICENSE is missing\n        let needs_license = results\n            .findings_by_category(\"docs\")\n            .any(|f| f.rule_id == \"DOC004\");\n\n        if !needs_license {\n            return None;\n        }\n\n        let license_type = \u0026self.config.actions.license.license_type;\n        let mut variables = HashMap::new();\n\n        if let Some(author) = \u0026self.config.actions.license.author {\n            variables.insert(\"author\".to_string(), author.clone());\n        }\n\n        let year = self\n            .config\n            .actions\n            .license\n            .year\n            .clone()\n            .unwrap_or_else(|| chrono::Utc::now().format(\"%Y\").to_string());\n        variables.insert(\"year\".to_string(), year);\n\n        Some(\n            Action::new(\n                \"license-create\",\n                \"file\",\n                \"Create LICENSE file\",\n                ActionOperation::CreateFile {\n                    path: \"LICENSE\".to_string(),\n                    template: format!(\"LICENSE/{}\", license_type),\n                    variables,\n                },\n            )\n            .with_detail(format!(\"License type: {}\", license_type)),\n        )\n    }\n\n    /// Generic helper to plan file creation from template\n    ///\n    /// # Arguments\n    ///\n    /// * `results` - The audit results\n    /// * `params` - Parameters for file creation\n    ///\n    /// # Returns\n    ///\n    /// An `Action` if the file needs to be created, `None` otherwise\n    fn plan_file_creation(\n        \u0026self,\n        results: \u0026AuditResults,\n        params: FileCreationParams\u003c'_\u003e,\n    ) -\u003e Option\u003cAction\u003e {\n        let needs_file = results\n            .findings_by_category(\"docs\")\n            .any(|f| f.rule_id == params.rule_id);\n\n        if !needs_file {\n            return None;\n        }\n\n        let mut action = Action::new(\n            params.action_id,\n            \"file\",\n            params.action_description,\n            ActionOperation::CreateFile {\n                path: params.file_path.to_string(),\n                template: params.template.to_string(),\n                variables: HashMap::new(),\n            },\n        );\n\n        if let Some(detail) = params.detail {\n            action = action.with_detail(detail);\n        }\n\n        Some(action)\n    }\n\n    fn plan_contributing_creation(\u0026self, results: \u0026AuditResults) -\u003e Option\u003cAction\u003e {\n        self.plan_file_creation(\n            results,\n            FileCreationParams {\n                rule_id: \"DOC005\",\n                file_path: \"CONTRIBUTING.md\",\n                template: \"CONTRIBUTING.md\",\n                action_id: \"contributing-create\",\n                action_description: \"Create CONTRIBUTING.md\",\n                detail: None,\n            },\n        )\n    }\n\n    fn plan_code_of_conduct_creation(\u0026self, results: \u0026AuditResults) -\u003e Option\u003cAction\u003e {\n        self.plan_file_creation(\n            results,\n            FileCreationParams {\n                rule_id: \"DOC006\",\n                file_path: \"CODE_OF_CONDUCT.md\",\n                template: \"CODE_OF_CONDUCT.md\",\n                action_id: \"coc-create\",\n                action_description: \"Create CODE_OF_CONDUCT.md\",\n                detail: Some(\"Using Contributor Covenant template\"),\n            },\n        )\n    }\n\n    fn plan_security_creation(\u0026self, results: \u0026AuditResults) -\u003e Option\u003cAction\u003e {\n        self.plan_file_creation(\n            results,\n            FileCreationParams {\n                rule_id: \"DOC007\",\n                file_path: \"SECURITY.md\",\n                template: \"SECURITY.md\",\n                action_id: \"security-create\",\n                action_description: \"Create SECURITY.md\",\n                detail: None,\n            },\n        )\n    }\n\n    /// Plan branch protection configuration\n    ///\n    /// Creates an action to configure branch protection settings based on\n    /// the configuration.\n    ///\n    /// # Returns\n    ///\n    /// An `Action` to configure branch protection\n    fn plan_branch_protection(\u0026self) -\u003e Action {\n        let bp = \u0026self.config.actions.branch_protection;\n\n        let settings = BranchProtectionSettings {\n            required_approvals: bp.required_approvals,\n            require_status_checks: bp.require_status_checks,\n            require_conversation_resolution: true,\n            require_linear_history: true,\n            block_force_push: bp.block_force_push,\n            block_deletions: true,\n            enforce_admins: true,\n            require_signed_commits: bp.require_signed_commits,\n        };\n\n        let mut details = vec![\n            format!(\"Require PR reviews: {}\", bp.required_approvals),\n            format!(\"Require status checks: {}\", bp.require_status_checks),\n            format!(\"Block force push: {}\", bp.block_force_push),\n        ];\n\n        if bp.require_signed_commits {\n            details.push(\"Require signed commits\".to_string());\n        }\n\n        Action::new(\n            \"branch-protection\",\n            \"github\",\n            format!(\"Enable branch protection on '{}'\", bp.branch),\n            ActionOperation::ConfigureBranchProtection {\n                branch: bp.branch.clone(),\n                settings,\n            },\n        )\n        .with_details(details)\n    }\n\n    /// Plan GitHub repository settings updates\n    ///\n    /// Creates an action to update GitHub repository settings like discussions,\n    /// vulnerability alerts, etc.\n    ///\n    /// # Returns\n    ///\n    /// An `Action` to update GitHub settings\n    fn plan_github_settings(\u0026self) -\u003e Action {\n        let gs = \u0026self.config.actions.github_settings;\n\n        let settings = GitHubRepoSettings {\n            enable_discussions: Some(gs.discussions),\n            enable_issues: Some(gs.issues),\n            enable_wiki: Some(gs.wiki),\n            enable_vulnerability_alerts: Some(gs.vulnerability_alerts),\n            enable_automated_security_fixes: Some(gs.automated_security_fixes),\n        };\n\n        let mut details = Vec::new();\n\n        if gs.discussions {\n            details.push(\"Enable discussions\".to_string());\n        }\n        if gs.vulnerability_alerts {\n            details.push(\"Enable vulnerability alerts\".to_string());\n        }\n        if gs.automated_security_fixes {\n            details.push(\"Enable automated security fixes\".to_string());\n        }\n\n        Action::new(\n            \"github-settings\",\n            \"github\",\n            \"Update repository settings\",\n            ActionOperation::UpdateGitHubSettings { settings },\n        )\n        .with_details(details)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::Config;\n    use crate::rules::results::{AuditResults, Finding, Severity};\n\n    #[test]\n    fn test_create_plan_includes_gitignore() {\n        let config = Config::default();\n        let planner = ActionPlanner::new(config);\n\n        let mut results = AuditResults::new(\"test-repo\", \"opensource\");\n        results.add_finding(Finding::new(\n            \"FILE003\",\n            \"files\",\n            Severity::Info,\n            \".gitignore missing recommended entry: .env\",\n        ));\n\n        let plan = planner.create_plan(\u0026results);\n\n        assert!(!plan.is_empty());\n        assert!(plan.actions().iter().any(|a| a.id() == \"gitignore-update\"));\n    }\n\n    #[test]\n    fn test_create_plan_includes_license() {\n        let config = Config::default();\n        let planner = ActionPlanner::new(config);\n\n        let mut results = AuditResults::new(\"test-repo\", \"opensource\");\n        results.add_finding(Finding::new(\n            \"DOC004\",\n            \"docs\",\n            Severity::Critical,\n            \"LICENSE file is missing\",\n        ));\n\n        let plan = planner.create_plan(\u0026results);\n\n        assert!(plan.actions().iter().any(|a| a.id() == \"license-create\"));\n    }\n\n    #[test]\n    fn test_create_plan_includes_contributing() {\n        let config = Config::default();\n        let planner = ActionPlanner::new(config);\n\n        let mut results = AuditResults::new(\"test-repo\", \"opensource\");\n        results.add_finding(Finding::new(\n            \"DOC005\",\n            \"docs\",\n            Severity::Warning,\n            \"CONTRIBUTING file is missing\",\n        ));\n\n        let plan = planner.create_plan(\u0026results);\n\n        assert!(plan\n            .actions()\n            .iter()\n            .any(|a| a.id() == \"contributing-create\"));\n    }\n\n    #[test]\n    fn test_create_plan_filters_by_config() {\n        let mut config = Config::default();\n        config.actions.contributing = false;\n\n        let planner = ActionPlanner::new(config);\n\n        let mut results = AuditResults::new(\"test-repo\", \"opensource\");\n        results.add_finding(Finding::new(\n            \"DOC005\",\n            \"docs\",\n            Severity::Warning,\n            \"CONTRIBUTING file is missing\",\n        ));\n\n        let plan = planner.create_plan(\u0026results);\n\n        // Should not include contributing because it's disabled in config\n        assert!(!plan\n            .actions()\n            .iter()\n            .any(|a| a.id() == \"contributing-create\"));\n    }\n}\n","traces":[{"line":48,"address":[672592],"length":1,"stats":{"Line":8}},{"line":64,"address":[1152640,1154059,1154053],"length":1,"stats":{"Line":8}},{"line":65,"address":[1152683],"length":1,"stats":{"Line":8}},{"line":68,"address":[1152738,1152984],"length":1,"stats":{"Line":14}},{"line":69,"address":[1152829,1152785],"length":1,"stats":{"Line":10}},{"line":70,"address":[1152921,1152964],"length":1,"stats":{"Line":8}},{"line":75,"address":[1152752,1153213],"length":1,"stats":{"Line":5}},{"line":76,"address":[1153042],"length":1,"stats":{"Line":6}},{"line":77,"address":[1153193,1153147],"length":1,"stats":{"Line":4}},{"line":82,"address":[1153006,1153445],"length":1,"stats":{"Line":5}},{"line":83,"address":[673258],"length":1,"stats":{"Line":4}},{"line":84,"address":[1153425,1153379],"length":1,"stats":{"Line":4}},{"line":89,"address":[673222,673661],"length":1,"stats":{"Line":4}},{"line":90,"address":[1153506],"length":1,"stats":{"Line":2}},{"line":91,"address":[1153657,1153611],"length":1,"stats":{"Line":0}},{"line":96,"address":[1153907,1153470],"length":1,"stats":{"Line":6}},{"line":97,"address":[673722],"length":1,"stats":{"Line":3}},{"line":98,"address":[1153887,1153841],"length":1,"stats":{"Line":0}},{"line":103,"address":[1153702],"length":1,"stats":{"Line":4}},{"line":104,"address":[1153960],"length":1,"stats":{"Line":4}},{"line":108,"address":[673986,673924],"length":1,"stats":{"Line":7}},{"line":110,"address":[1154019],"length":1,"stats":{"Line":4}},{"line":125,"address":[1154080,1155739,1155469],"length":1,"stats":{"Line":8}},{"line":127,"address":[1154127],"length":1,"stats":{"Line":8}},{"line":130,"address":[1154252,1154168],"length":1,"stats":{"Line":16}},{"line":131,"address":[1154417,1155482],"length":1,"stats":{"Line":4}},{"line":133,"address":[675483],"length":1,"stats":{"Line":2}},{"line":134,"address":[1155681],"length":1,"stats":{"Line":2}},{"line":140,"address":[674425],"length":1,"stats":{"Line":6}},{"line":141,"address":[1154549,1154737],"length":1,"stats":{"Line":12}},{"line":142,"address":[1155258,1154826],"length":1,"stats":{"Line":10}},{"line":143,"address":[1155411],"length":1,"stats":{"Line":7}},{"line":147,"address":[674857],"length":1,"stats":{"Line":5}},{"line":148,"address":[1154948],"length":1,"stats":{"Line":0}},{"line":152,"address":[1155171,1155038],"length":1,"stats":{"Line":12}},{"line":156,"address":[1154988],"length":1,"stats":{"Line":5}},{"line":157,"address":[1154906],"length":1,"stats":{"Line":7}},{"line":160,"address":[1155107],"length":1,"stats":{"Line":5}},{"line":175,"address":[1156312,1155776,1157257],"length":1,"stats":{"Line":2}},{"line":177,"address":[1155827],"length":1,"stats":{"Line":6}},{"line":179,"address":[683273,683248],"length":1,"stats":{"Line":6}},{"line":181,"address":[1155903],"length":1,"stats":{"Line":2}},{"line":182,"address":[1155912],"length":1,"stats":{"Line":4}},{"line":185,"address":[1155932],"length":1,"stats":{"Line":2}},{"line":186,"address":[1155941],"length":1,"stats":{"Line":2}},{"line":188,"address":[1155964,1156036],"length":1,"stats":{"Line":2}},{"line":189,"address":[1156044,1156182,1156155],"length":1,"stats":{"Line":0}},{"line":192,"address":[1156318,1156080],"length":1,"stats":{"Line":4}},{"line":198,"address":[676332],"length":1,"stats":{"Line":6}},{"line":199,"address":[1156428,1156356],"length":1,"stats":{"Line":4}},{"line":202,"address":[1156884,1157126],"length":1,"stats":{"Line":4}},{"line":206,"address":[676756],"length":1,"stats":{"Line":2}},{"line":207,"address":[1156523],"length":1,"stats":{"Line":2}},{"line":208,"address":[1156622,1156554],"length":1,"stats":{"Line":4}},{"line":209,"address":[1156722],"length":1,"stats":{"Line":2}},{"line":212,"address":[1156961,1157170,1156985,1157225],"length":1,"stats":{"Line":4}},{"line":226,"address":[1157296,1158031],"length":1,"stats":{"Line":4}},{"line":231,"address":[677331],"length":1,"stats":{"Line":4}},{"line":233,"address":[683481,683456],"length":1,"stats":{"Line":6}},{"line":235,"address":[677380],"length":1,"stats":{"Line":2}},{"line":236,"address":[1157405],"length":1,"stats":{"Line":2}},{"line":240,"address":[1157425],"length":1,"stats":{"Line":2}},{"line":242,"address":[677427],"length":1,"stats":{"Line":2}},{"line":243,"address":[677618],"length":1,"stats":{"Line":2}},{"line":244,"address":[1157461],"length":1,"stats":{"Line":2}},{"line":245,"address":[1157501],"length":1,"stats":{"Line":2}},{"line":246,"address":[677570],"length":1,"stats":{"Line":2}},{"line":250,"address":[677812],"length":1,"stats":{"Line":2}},{"line":251,"address":[1157894],"length":1,"stats":{"Line":0}},{"line":254,"address":[677961],"length":1,"stats":{"Line":2}},{"line":257,"address":[1158064],"length":1,"stats":{"Line":4}},{"line":258,"address":[1158225],"length":1,"stats":{"Line":3}},{"line":260,"address":[1158100],"length":1,"stats":{"Line":4}},{"line":266,"address":[1158091],"length":1,"stats":{"Line":4}},{"line":271,"address":[1158256],"length":1,"stats":{"Line":2}},{"line":272,"address":[1158429],"length":1,"stats":{"Line":2}},{"line":274,"address":[678288],"length":1,"stats":{"Line":2}},{"line":280,"address":[1158283],"length":1,"stats":{"Line":2}},{"line":285,"address":[1158464],"length":1,"stats":{"Line":3}},{"line":286,"address":[678609],"length":1,"stats":{"Line":4}},{"line":288,"address":[678484],"length":1,"stats":{"Line":3}},{"line":294,"address":[678475],"length":1,"stats":{"Line":3}},{"line":307,"address":[680083,680089,678640],"length":1,"stats":{"Line":4}},{"line":308,"address":[1158684],"length":1,"stats":{"Line":4}},{"line":311,"address":[1158723],"length":1,"stats":{"Line":4}},{"line":312,"address":[678728],"length":1,"stats":{"Line":4}},{"line":315,"address":[678734],"length":1,"stats":{"Line":4}},{"line":318,"address":[678740],"length":1,"stats":{"Line":5}},{"line":321,"address":[678792,678831,679151,679295,678982,679508,680118],"length":1,"stats":{"Line":6}},{"line":322,"address":[1158823,1158879],"length":1,"stats":{"Line":7}},{"line":323,"address":[679023,678959],"length":1,"stats":{"Line":7}},{"line":324,"address":[1159144,1159211],"length":1,"stats":{"Line":7}},{"line":327,"address":[1159516],"length":1,"stats":{"Line":5}},{"line":328,"address":[1159561,1159633],"length":1,"stats":{"Line":0}},{"line":334,"address":[1159669,1159542],"length":1,"stats":{"Line":8}},{"line":335,"address":[1159842],"length":1,"stats":{"Line":5}},{"line":336,"address":[1159782],"length":1,"stats":{"Line":3}},{"line":340,"address":[1159999],"length":1,"stats":{"Line":5}},{"line":351,"address":[1160144,1160785,1160814],"length":1,"stats":{"Line":4}},{"line":352,"address":[1160174],"length":1,"stats":{"Line":5}},{"line":355,"address":[1160206],"length":1,"stats":{"Line":5}},{"line":356,"address":[680202],"length":1,"stats":{"Line":5}},{"line":357,"address":[1160230],"length":1,"stats":{"Line":3}},{"line":358,"address":[1160242],"length":1,"stats":{"Line":3}},{"line":359,"address":[1160254],"length":1,"stats":{"Line":6}},{"line":362,"address":[1160306],"length":1,"stats":{"Line":5}},{"line":364,"address":[1160330],"length":1,"stats":{"Line":7}},{"line":365,"address":[680336,680405],"length":1,"stats":{"Line":12}},{"line":367,"address":[1160344],"length":1,"stats":{"Line":4}},{"line":368,"address":[1160468],"length":1,"stats":{"Line":4}},{"line":370,"address":[1160456],"length":1,"stats":{"Line":3}},{"line":371,"address":[1160635],"length":1,"stats":{"Line":4}},{"line":378,"address":[1160526],"length":1,"stats":{"Line":4}},{"line":380,"address":[1160707],"length":1,"stats":{"Line":4}}],"covered":108,"coverable":114},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","templates.rs"],"content":"//! Template file creation\n\nuse crate::error::{ActionError, RepoLensError};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\n/// Create a file from a template\npub fn create_file_from_template(\n    path: \u0026str,\n    template_name: \u0026str,\n    variables: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003c(), RepoLensError\u003e {\n    let template_content = get_template(template_name)?;\n\n    // Replace variables in template\n    let mut content = template_content;\n    for (key, value) in variables {\n        content = content.replace(\u0026format!(\"{{{{ {} }}}}\", key), value);\n        content = content.replace(\u0026format!(\"{{{{{}}}}}\", key), value);\n    }\n\n    // Write the file\n    let file_path = Path::new(path);\n\n    // Create parent directories if needed\n    if let Some(parent) = file_path.parent() {\n        if !parent.as_os_str().is_empty() {\n            fs::create_dir_all(parent).map_err(|e| {\n                RepoLensError::Action(ActionError::DirectoryCreate {\n                    path: parent.display().to_string(),\n                    source: e,\n                })\n            })?;\n        }\n    }\n\n    fs::write(file_path, content).map_err(|e| {\n        RepoLensError::Action(ActionError::FileWrite {\n            path: path.to_string(),\n            source: e,\n        })\n    })?;\n\n    Ok(())\n}\n\n/// Get template content by name\nfn get_template(name: \u0026str) -\u003e Result\u003cString, RepoLensError\u003e {\n    match name {\n        \"LICENSE/MIT\" =\u003e Ok(MIT_LICENSE.to_string()),\n        \"LICENSE/Apache-2.0\" =\u003e Ok(APACHE_LICENSE.to_string()),\n        \"LICENSE/GPL-3.0\" =\u003e Ok(GPL_LICENSE_HEADER.to_string()),\n        \"CONTRIBUTING.md\" =\u003e Ok(CONTRIBUTING_TEMPLATE.to_string()),\n        \"CODE_OF_CONDUCT.md\" =\u003e Ok(CODE_OF_CONDUCT_TEMPLATE.to_string()),\n        \"SECURITY.md\" =\u003e Ok(SECURITY_TEMPLATE.to_string()),\n        \"ISSUE_TEMPLATE/bug_report.md\" =\u003e Ok(BUG_REPORT_TEMPLATE.to_string()),\n        \"ISSUE_TEMPLATE/feature_request.md\" =\u003e Ok(FEATURE_REQUEST_TEMPLATE.to_string()),\n        \"PULL_REQUEST_TEMPLATE/pull_request_template.md\" =\u003e Ok(PULL_REQUEST_TEMPLATE.to_string()),\n        _ =\u003e Err(RepoLensError::Action(ActionError::UnknownTemplate {\n            name: name.to_string(),\n        })),\n    }\n}\n\nconst MIT_LICENSE: \u0026str = r#\"MIT License\n\nCopyright (c) {{ year }} {{ author }}\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"#;\n\nconst APACHE_LICENSE: \u0026str = r#\"                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   Copyright {{ year }} {{ author }}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\"#;\n\nconst GPL_LICENSE_HEADER: \u0026str = r#\"Copyright (C) {{ year }} {{ author }}\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\"#;\n\nconst CONTRIBUTING_TEMPLATE: \u0026str = r#\"# Contributing\n\nThank you for your interest in contributing to this project!\n\n## How to Contribute\n\n### Reporting Issues\n\n- Check if the issue already exists\n- Use a clear and descriptive title\n- Provide steps to reproduce the issue\n- Include relevant logs or screenshots\n\n### Pull Requests\n\n1. Fork the repository\n2. Create a feature branch (`git checkout -b feature/amazing-feature`)\n3. Make your changes\n4. Run tests to ensure everything works\n5. Commit your changes (`git commit -m 'Add amazing feature'`)\n6. Push to the branch (`git push origin feature/amazing-feature`)\n7. Open a Pull Request\n\n### Code Style\n\n- Follow the existing code style\n- Write meaningful commit messages\n- Add tests for new features\n- Update documentation as needed\n\n### Development Setup\n\n```bash\n# Clone the repository\ngit clone \u003crepository-url\u003e\ncd \u003cproject\u003e\n\n# Install dependencies\n# Add project-specific setup instructions here\n```\n\n## Questions?\n\nFeel free to open an issue for any questions or concerns.\n\"#;\n\nconst CODE_OF_CONDUCT_TEMPLATE: \u0026str = r#\"# Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, caste, color, religion, or sexual\nidentity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior:\n\n* The use of sexualized language or imagery, and sexual attention or advances\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information without explicit permission\n* Other conduct which could reasonably be considered inappropriate\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the project maintainers. All complaints will be reviewed and\ninvestigated promptly and fairly.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org),\nversion 2.1.\n\"#;\n\nconst SECURITY_TEMPLATE: \u0026str = r#\"# Security Policy\n\n## Reporting a Vulnerability\n\nWe take security seriously. If you discover a security vulnerability, please follow these steps:\n\n1. **Do not** open a public issue\n2. Email us at [security@example.com] with details\n3. Include steps to reproduce the vulnerability\n4. Allow time for us to investigate and respond\n\n## What to Include\n\n- Type of vulnerability\n- Steps to reproduce\n- Potential impact\n- Suggested fix (if any)\n\n## Response Timeline\n\n- **Initial Response**: Within 48 hours\n- **Status Update**: Within 7 days\n- **Resolution**: Depends on severity and complexity\n\n## Supported Versions\n\n| Version | Supported          |\n| ------- | ------------------ |\n| latest  | :white_check_mark: |\n| \u003c 1.0   | :x:                |\n\n## Security Best Practices\n\nWhen using this project:\n\n- Keep dependencies up to date\n- Use environment variables for secrets\n- Follow the principle of least privilege\n- Enable security features where available\n\nThank you for helping keep this project secure!\n\"#;\n\nconst BUG_REPORT_TEMPLATE: \u0026str = r#\"---\nname: Bug Report\nabout: Create a report to help us improve\ntitle: ''\nlabels: bug\nassignees: ''\n---\n\n## Description\n\nA clear and concise description of what the bug is.\n\n## Steps to Reproduce\n\n1. Go to '...'\n2. Click on '....'\n3. Scroll down to '....'\n4. See error\n\n## Expected Behavior\n\nA clear and concise description of what you expected to happen.\n\n## Actual Behavior\n\nA clear and concise description of what actually happened.\n\n## Environment\n\n- OS: [e.g. Ubuntu 22.04, macOS 13.0, Windows 11]\n- Version: [e.g. 0.1.0]\n- Rust version: [e.g. 1.70.0]\n\n## Additional Context\n\nAdd any other context about the problem here.\n\n## Screenshots\n\nIf applicable, add screenshots to help explain your problem.\n\"#;\n\nconst FEATURE_REQUEST_TEMPLATE: \u0026str = r#\"---\nname: Feature Request\nabout: Suggest an idea for this project\ntitle: ''\nlabels: enhancement\nassignees: ''\n---\n\n## Problem Statement\n\nA clear and concise description of what the problem is. Ex. I'm always frustrated when [...]\n\n## Proposed Solution\n\nA clear and concise description of what you want to happen.\n\n## Alternatives Considered\n\nA clear and concise description of any alternative solutions or features you've considered.\n\n## Use Cases\n\nDescribe the use cases for this feature:\n\n1. Use case 1\n2. Use case 2\n3. Use case 3\n\n## Additional Context\n\nAdd any other context, mockups, or examples about the feature request here.\n\n## Implementation Notes (Optional)\n\nIf you have ideas about how this could be implemented, please share them here.\n\"#;\n\nconst PULL_REQUEST_TEMPLATE: \u0026str = r#\"## Description\n\nBrief description of changes.\n\n## Type of Change\n\n- [ ] Bug fix\n- [ ] New feature\n- [ ] Documentation update\n- [ ] Refactoring\n\n## Checklist\n\n- [ ] Code compiles without errors\n- [ ] Tests pass\n- [ ] Code follows project style guidelines\n- [ ] Documentation updated if needed\n\"#;\n","traces":[{"line":9,"address":[509969,509997,507584],"length":1,"stats":{"Line":2}},{"line":14,"address":[507709],"length":1,"stats":{"Line":2}},{"line":17,"address":[507926],"length":1,"stats":{"Line":2}},{"line":18,"address":[508030,507982],"length":1,"stats":{"Line":4}},{"line":19,"address":[1519777,1518854,1520035],"length":1,"stats":{"Line":0}},{"line":20,"address":[509824,509529],"length":1,"stats":{"Line":0}},{"line":24,"address":[508240],"length":1,"stats":{"Line":2}},{"line":27,"address":[508321],"length":1,"stats":{"Line":2}},{"line":28,"address":[508571,508453],"length":1,"stats":{"Line":4}},{"line":29,"address":[884594,884588,884368],"length":1,"stats":{"Line":0}},{"line":30,"address":[1116436],"length":1,"stats":{"Line":0}},{"line":31,"address":[1116319,1116397],"length":1,"stats":{"Line":0}},{"line":32,"address":[1116431],"length":1,"stats":{"Line":0}},{"line":38,"address":[1116698,1116528,1116692],"length":1,"stats":{"Line":4}},{"line":39,"address":[1116623],"length":1,"stats":{"Line":0}},{"line":40,"address":[1116556],"length":1,"stats":{"Line":0}},{"line":41,"address":[1116618],"length":1,"stats":{"Line":0}},{"line":45,"address":[508971],"length":1,"stats":{"Line":2}},{"line":49,"address":[1520688],"length":1,"stats":{"Line":2}},{"line":51,"address":[510091,510145],"length":1,"stats":{"Line":3}},{"line":52,"address":[1520778,1520901],"length":1,"stats":{"Line":3}},{"line":53,"address":[510345,510222],"length":1,"stats":{"Line":3}},{"line":54,"address":[1521101,1520978],"length":1,"stats":{"Line":5}},{"line":55,"address":[510422,510548],"length":1,"stats":{"Line":2}},{"line":56,"address":[510525,510660],"length":1,"stats":{"Line":2}},{"line":57,"address":[510637,510772],"length":1,"stats":{"Line":2}},{"line":58,"address":[510749,510888],"length":1,"stats":{"Line":2}},{"line":59,"address":[511102,510861],"length":1,"stats":{"Line":2}},{"line":60,"address":[510991],"length":1,"stats":{"Line":2}},{"line":61,"address":[510977],"length":1,"stats":{"Line":2}}],"covered":21,"coverable":30},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","commands","apply.rs"],"content":"//! Apply command - Apply planned changes to the repository\n\nuse colored::Colorize;\nuse dialoguer::Confirm;\nuse std::path::PathBuf;\n\nuse super::ApplyArgs;\nuse crate::actions::executor::ActionExecutor;\nuse crate::actions::planner::ActionPlanner;\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::exit_codes;\nuse crate::rules::engine::RulesEngine;\nuse crate::scanner::Scanner;\n\npub async fn execute(args: ApplyArgs) -\u003e Result\u003ci32, RepoLensError\u003e {\n    // Load configuration\n    let config = Config::load_or_default()?;\n\n    // Initialize scanner\n    let scanner = Scanner::new(PathBuf::from(\".\"));\n\n    // Run the rules engine to get current state\n    let engine = RulesEngine::new(config.clone());\n    let audit_results = engine.run(\u0026scanner).await?;\n\n    // Generate action plan\n    let planner = ActionPlanner::new(config.clone());\n    let mut action_plan = planner.create_plan(\u0026audit_results);\n\n    // Apply filters if specified\n    if let Some(only) = \u0026args.only {\n        action_plan.filter_only(only);\n    }\n    if let Some(skip) = \u0026args.skip {\n        action_plan.filter_skip(skip);\n    }\n\n    // Check if there are any actions to perform\n    if action_plan.is_empty() {\n        println!(\"{}\", \"No actions to perform.\".green());\n        return Ok(exit_codes::SUCCESS);\n    }\n\n    // Display plan summary\n    println!(\"{}\", \"Planned actions:\".bold());\n    println!();\n    for action in action_plan.actions() {\n        println!(\"  {} {}\", \"+\".green(), action.description());\n    }\n    println!();\n\n    // Dry run mode\n    if args.dry_run {\n        println!(\"{}\", \"Dry run mode - no changes made.\".yellow());\n        return Ok(exit_codes::SUCCESS);\n    }\n\n    // Confirm execution\n    if !args.yes {\n        let confirm = Confirm::new()\n            .with_prompt(\"Apply these changes?\")\n            .default(false)\n            .interact()\n            .map_err(|e| {\n                RepoLensError::Action(crate::error::ActionError::ExecutionFailed {\n                    message: format!(\"Failed to get user input: {}\", e),\n                })\n            })?;\n\n        if !confirm {\n            println!(\"{}\", \"Aborted.\".yellow());\n            return Ok(exit_codes::SUCCESS);\n        }\n    }\n\n    // Execute actions\n    let executor = ActionExecutor::new(config);\n    let results = executor.execute(\u0026action_plan).await?;\n\n    // Display results\n    println!();\n    let mut success_count = 0;\n    let mut error_count = 0;\n\n    for result in \u0026results {\n        if result.success {\n            println!(\"  {} {}\", \"‚úì\".green(), result.action_name);\n            success_count += 1;\n        } else {\n            println!(\n                \"  {} {} - {}\",\n                \"‚úó\".red(),\n                result.action_name,\n                result.error.as_deref().unwrap_or(\"Unknown error\")\n            );\n            error_count += 1;\n        }\n    }\n\n    println!();\n    println!(\n        \"{}: {} succeeded, {} failed\",\n        \"Summary\".bold(),\n        success_count.to_string().green(),\n        error_count.to_string().red()\n    );\n\n    if error_count \u003e 0 {\n        Ok(exit_codes::ERROR)\n    } else {\n        Ok(exit_codes::SUCCESS)\n    }\n}\n","traces":[{"line":16,"address":[426272,426289],"length":1,"stats":{"Line":0}},{"line":18,"address":[1054926,1054165,1054311],"length":1,"stats":{"Line":0}},{"line":21,"address":[1054543,1054622],"length":1,"stats":{"Line":0}},{"line":24,"address":[1054723,1054652],"length":1,"stats":{"Line":0}},{"line":25,"address":[1054202,1054856,1058202,1054991,1054753],"length":1,"stats":{"Line":0}},{"line":28,"address":[1055632,1055558],"length":1,"stats":{"Line":0}},{"line":29,"address":[1055662],"length":1,"stats":{"Line":0}},{"line":32,"address":[1055751],"length":1,"stats":{"Line":0}},{"line":33,"address":[1056008,1055823],"length":1,"stats":{"Line":0}},{"line":35,"address":[1055872,1056028],"length":1,"stats":{"Line":0}},{"line":36,"address":[1056036,1056138],"length":1,"stats":{"Line":0}},{"line":40,"address":[1056154,1056085],"length":1,"stats":{"Line":0}},{"line":41,"address":[1031103,1029279],"length":1,"stats":{"Line":0}},{"line":42,"address":[1058174],"length":1,"stats":{"Line":0}},{"line":46,"address":[1056160,1056225],"length":1,"stats":{"Line":0}},{"line":47,"address":[1056384],"length":1,"stats":{"Line":0}},{"line":48,"address":[1029517],"length":1,"stats":{"Line":0}},{"line":49,"address":[1056632,1057759],"length":1,"stats":{"Line":0}},{"line":51,"address":[1056666],"length":1,"stats":{"Line":0}},{"line":54,"address":[1029799],"length":1,"stats":{"Line":0}},{"line":55,"address":[1057572,1056741],"length":1,"stats":{"Line":0}},{"line":56,"address":[1057731],"length":1,"stats":{"Line":0}},{"line":60,"address":[1056725],"length":1,"stats":{"Line":0}},{"line":61,"address":[1057397,1057093,1056775,1056884],"length":1,"stats":{"Line":0}},{"line":65,"address":[1061097,1061103,1060848],"length":1,"stats":{"Line":0}},{"line":66,"address":[1061019],"length":1,"stats":{"Line":0}},{"line":67,"address":[1034018,1033970],"length":1,"stats":{"Line":0}},{"line":71,"address":[1057145],"length":1,"stats":{"Line":0}},{"line":72,"address":[1057153],"length":1,"stats":{"Line":0}},{"line":73,"address":[1057343],"length":1,"stats":{"Line":0}},{"line":78,"address":[1056794],"length":1,"stats":{"Line":0}},{"line":79,"address":[1054223,1057502,1058229,1057399],"length":1,"stats":{"Line":0}},{"line":82,"address":[1058710,1058644],"length":1,"stats":{"Line":0}},{"line":83,"address":[1058729],"length":1,"stats":{"Line":0}},{"line":84,"address":[1058740],"length":1,"stats":{"Line":0}},{"line":86,"address":[1058759],"length":1,"stats":{"Line":0}},{"line":87,"address":[1033486,1031975,1033737],"length":1,"stats":{"Line":0}},{"line":88,"address":[1059994,1060423],"length":1,"stats":{"Line":0}},{"line":89,"address":[1033710,1033742],"length":1,"stats":{"Line":0}},{"line":91,"address":[1060222,1060028],"length":1,"stats":{"Line":0}},{"line":97,"address":[1060369,1060403],"length":1,"stats":{"Line":0}},{"line":101,"address":[1058902],"length":1,"stats":{"Line":0}},{"line":102,"address":[1058947],"length":1,"stats":{"Line":0}},{"line":109,"address":[1059617,1059650],"length":1,"stats":{"Line":0}},{"line":110,"address":[1059652],"length":1,"stats":{"Line":0}},{"line":112,"address":[1059627],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","commands","init.rs"],"content":"//! Init command - Initialize a new configuration file\n\nuse colored::Colorize;\nuse dialoguer::{Confirm, Select};\nuse std::fs;\nuse std::path::Path;\n\nuse super::InitArgs;\nuse crate::config::{Config, Preset};\nuse crate::error::{ActionError, RepoLensError};\nuse crate::utils::prerequisites::{\n    display_error_summary, display_report, display_warnings, run_all_checks, CheckOptions,\n};\n\nconst CONFIG_FILENAME: \u0026str = \".repolens.toml\";\n\npub async fn execute(args: InitArgs) -\u003e Result\u003ci32, RepoLensError\u003e {\n    let root = std::env::current_dir().map_err(|e| {\n        RepoLensError::Action(ActionError::ExecutionFailed {\n            message: format!(\"Failed to get current directory: {}\", e),\n        })\n    })?;\n    let config_path = Path::new(CONFIG_FILENAME);\n\n    // Run prerequisite checks unless skipped\n    if !args.skip_checks {\n        let options = CheckOptions::default();\n        let report = run_all_checks(\u0026root, \u0026options);\n        display_report(\u0026report, false);\n\n        if !report.all_required_passed() {\n            display_error_summary(\u0026report);\n\n            if args.non_interactive {\n                return Ok(crate::exit_codes::ERROR);\n            }\n\n            // Ask if user wants to continue anyway\n            let continue_anyway = Confirm::new()\n                .with_prompt(\"Continue anyway?\")\n                .default(false)\n                .interact()\n                .map_err(|e| {\n                    RepoLensError::Action(ActionError::ExecutionFailed {\n                        message: format!(\"Failed to get user input: {}\", e),\n                    })\n                })?;\n\n            if !continue_anyway {\n                return Ok(crate::exit_codes::ERROR);\n            }\n\n            println!();\n        } else if report.has_warnings() {\n            display_warnings(\u0026report);\n        }\n    }\n\n    // Check if config already exists\n    if config_path.exists() \u0026\u0026 !args.force {\n        if args.non_interactive {\n            eprintln!(\n                \"{} Configuration file already exists. Use --force to overwrite.\",\n                \"Error:\".red().bold()\n            );\n            return Ok(1);\n        }\n\n        let overwrite = Confirm::new()\n            .with_prompt(\"Configuration file already exists. Overwrite?\")\n            .default(false)\n            .interact()\n            .map_err(|e| {\n                RepoLensError::Action(ActionError::ExecutionFailed {\n                    message: format!(\"Failed to get user input: {}\", e),\n                })\n            })?;\n\n        if !overwrite {\n            println!(\"{}\", \"Aborted.\".yellow());\n            return Ok(0);\n        }\n    }\n\n    // Determine preset\n    let preset = if let Some(preset_name) = args.preset {\n        Preset::from_name(\u0026preset_name).ok_or(RepoLensError::Config(\n            crate::error::ConfigError::InvalidPreset { name: preset_name },\n        ))?\n    } else if args.non_interactive {\n        Preset::OpenSource\n    } else {\n        select_preset()?\n    };\n\n    // Create configuration\n    let config = Config::from_preset(preset);\n\n    // Write configuration file\n    let config_content = config.to_toml()?;\n    fs::write(config_path, \u0026config_content).map_err(|e| {\n        RepoLensError::Action(ActionError::FileWrite {\n            path: config_path.display().to_string(),\n            source: e,\n        })\n    })?;\n\n    println!(\n        \"{} Created {} with preset '{}'\",\n        \"Success:\".green().bold(),\n        CONFIG_FILENAME.cyan(),\n        preset.name().yellow()\n    );\n\n    println!(\"\\nNext steps:\");\n    println!(\"  1. Review and customize {}\", CONFIG_FILENAME.cyan());\n    println!(\"  2. Run {} to see planned actions\", \"repolens plan\".cyan());\n    println!(\"  3. Run {} to apply changes\", \"repolens apply\".cyan());\n\n    Ok(0)\n}\n\nfn select_preset() -\u003e Result\u003cPreset, RepoLensError\u003e {\n    let presets = [\n        (\n            \"opensource\",\n            \"Open Source - Prepare repository for public release\",\n        ),\n        (\"enterprise\", \"Enterprise - Internal company standards\"),\n        (\"strict\", \"Strict - Maximum security and compliance checks\"),\n    ];\n\n    let selection = Select::new()\n        .with_prompt(\"Select a preset\")\n        .items(\u0026presets.iter().map(|(_, desc)| *desc).collect::\u003cVec\u003c_\u003e\u003e())\n        .default(0)\n        .interact()\n        .map_err(|e| {\n            RepoLensError::Action(ActionError::ExecutionFailed {\n                message: format!(\"Failed to get user input: {}\", e),\n            })\n        })?;\n\n    Ok(match selection {\n        0 =\u003e Preset::OpenSource,\n        1 =\u003e Preset::Enterprise,\n        2 =\u003e Preset::Strict,\n        _ =\u003e Preset::OpenSource,\n    })\n}\n","traces":[{"line":17,"address":[840480,840615,841742,845094,845341,840510],"length":1,"stats":{"Line":0}},{"line":18,"address":[142912,138132,142797,143171,138255,138361,143165],"length":1,"stats":{"Line":0}},{"line":19,"address":[143087],"length":1,"stats":{"Line":0}},{"line":20,"address":[142998,142933],"length":1,"stats":{"Line":0}},{"line":23,"address":[138545,138458],"length":1,"stats":{"Line":0}},{"line":26,"address":[841025],"length":1,"stats":{"Line":0}},{"line":27,"address":[138610,138571],"length":1,"stats":{"Line":0}},{"line":28,"address":[138627],"length":1,"stats":{"Line":0}},{"line":29,"address":[138687],"length":1,"stats":{"Line":0}},{"line":31,"address":[841206],"length":1,"stats":{"Line":0}},{"line":32,"address":[138771],"length":1,"stats":{"Line":0}},{"line":34,"address":[138800],"length":1,"stats":{"Line":0}},{"line":35,"address":[138829],"length":1,"stats":{"Line":0}},{"line":39,"address":[139227,138810,138857,139066],"length":1,"stats":{"Line":0}},{"line":43,"address":[143439,143184,143433],"length":1,"stats":{"Line":0}},{"line":44,"address":[143355],"length":1,"stats":{"Line":0}},{"line":45,"address":[143218,143266],"length":1,"stats":{"Line":0}},{"line":49,"address":[139118],"length":1,"stats":{"Line":0}},{"line":50,"address":[139122],"length":1,"stats":{"Line":0}},{"line":53,"address":[139188,139147],"length":1,"stats":{"Line":0}},{"line":54,"address":[138786,139255],"length":1,"stats":{"Line":0}},{"line":55,"address":[139269],"length":1,"stats":{"Line":0}},{"line":60,"address":[138592,139340,139288],"length":1,"stats":{"Line":0}},{"line":61,"address":[139350],"length":1,"stats":{"Line":0}},{"line":62,"address":[139905,139379],"length":1,"stats":{"Line":0}},{"line":66,"address":[140091],"length":1,"stats":{"Line":0}},{"line":69,"address":[139622,139360,139900,139413],"length":1,"stats":{"Line":0}},{"line":73,"address":[143456,143711,143705],"length":1,"stats":{"Line":0}},{"line":74,"address":[143627],"length":1,"stats":{"Line":0}},{"line":75,"address":[143538,143490],"length":1,"stats":{"Line":0}},{"line":79,"address":[139674],"length":1,"stats":{"Line":0}},{"line":80,"address":[139682],"length":1,"stats":{"Line":0}},{"line":81,"address":[139872],"length":1,"stats":{"Line":0}},{"line":86,"address":[139294,140119],"length":1,"stats":{"Line":0}},{"line":87,"address":[140262,140367,140536,140175],"length":1,"stats":{"Line":0}},{"line":88,"address":[140277],"length":1,"stats":{"Line":0}},{"line":90,"address":[140587,140689,140841,140211,140621,140192],"length":1,"stats":{"Line":0}},{"line":91,"address":[140681],"length":1,"stats":{"Line":0}},{"line":93,"address":[140707,140846,140674],"length":1,"stats":{"Line":0}},{"line":97,"address":[843059],"length":1,"stats":{"Line":0}},{"line":100,"address":[142756,140867,140930],"length":1,"stats":{"Line":0}},{"line":101,"address":[843592,846412,846418,843777,843671,846192],"length":1,"stats":{"Line":0}},{"line":102,"address":[143876],"length":1,"stats":{"Line":0}},{"line":103,"address":[143837,143759],"length":1,"stats":{"Line":0}},{"line":104,"address":[143871],"length":1,"stats":{"Line":0}},{"line":108,"address":[843868,843970,844090],"length":1,"stats":{"Line":0}},{"line":115,"address":[141855],"length":1,"stats":{"Line":0}},{"line":116,"address":[844364],"length":1,"stats":{"Line":0}},{"line":117,"address":[142090],"length":1,"stats":{"Line":0}},{"line":118,"address":[844744],"length":1,"stats":{"Line":0}},{"line":120,"address":[142470],"length":1,"stats":{"Line":0}},{"line":123,"address":[507563,506544,507557],"length":1,"stats":{"Line":0}},{"line":124,"address":[506561,506731],"length":1,"stats":{"Line":0}},{"line":129,"address":[506623],"length":1,"stats":{"Line":0}},{"line":130,"address":[506677],"length":1,"stats":{"Line":0}},{"line":133,"address":[506821,507081,507349,507203,507120],"length":1,"stats":{"Line":0}},{"line":135,"address":[1223355,1223576,1223497,1223999],"length":1,"stats":{"Line":0}},{"line":138,"address":[144249,144000,144255],"length":1,"stats":{"Line":0}},{"line":139,"address":[846635],"length":1,"stats":{"Line":0}},{"line":140,"address":[846546,846498],"length":1,"stats":{"Line":0}},{"line":144,"address":[507489,507415],"length":1,"stats":{"Line":0}},{"line":145,"address":[507456],"length":1,"stats":{"Line":0}},{"line":146,"address":[507466],"length":1,"stats":{"Line":0}},{"line":147,"address":[507476],"length":1,"stats":{"Line":0}},{"line":148,"address":[507446],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":65},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","commands","mod.rs"],"content":"//! CLI commands module\n\npub mod apply;\npub mod init;\npub mod plan;\npub mod report;\n\nuse clap::Args;\nuse std::path::PathBuf;\n\n/// Arguments for the init command\n#[derive(Args, Debug)]\npub struct InitArgs {\n    /// Preset to use (opensource, enterprise, strict)\n    #[arg(short, long, value_name = \"PRESET\")]\n    pub preset: Option\u003cString\u003e,\n\n    /// Force overwrite existing configuration\n    #[arg(short, long)]\n    pub force: bool,\n\n    /// Skip interactive prompts\n    #[arg(long)]\n    pub non_interactive: bool,\n\n    /// Skip prerequisite checks (git, gh, etc.)\n    #[arg(long)]\n    pub skip_checks: bool,\n}\n\n/// Arguments for the plan command\n#[derive(Args, Debug)]\npub struct PlanArgs {\n    /// Output format (terminal, json, sarif)\n    #[arg(short, long, default_value = \"terminal\")]\n    pub format: OutputFormat,\n\n    /// Only check specific rule categories\n    #[arg(long, value_delimiter = ',')]\n    pub only: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// Skip specific rule categories\n    #[arg(long, value_delimiter = ',')]\n    pub skip: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// Output file (defaults to stdout)\n    #[arg(short, long, value_name = \"FILE\")]\n    pub output: Option\u003cPathBuf\u003e,\n}\n\n/// Arguments for the apply command\n#[derive(Args, Debug)]\npub struct ApplyArgs {\n    /// Skip confirmation prompts\n    #[arg(short, long)]\n    pub yes: bool,\n\n    /// Dry run - show what would be done without making changes\n    #[arg(long)]\n    pub dry_run: bool,\n\n    /// Only apply specific actions\n    #[arg(long, value_delimiter = ',')]\n    pub only: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// Skip specific actions\n    #[arg(long, value_delimiter = ',')]\n    pub skip: Option\u003cVec\u003cString\u003e\u003e,\n}\n\n/// Arguments for the report command\n#[derive(Args, Debug)]\npub struct ReportArgs {\n    /// Output format (html, markdown, json)\n    #[arg(short, long, default_value = \"markdown\")]\n    pub format: ReportFormat,\n\n    /// Output file\n    #[arg(short, long, value_name = \"FILE\")]\n    pub output: Option\u003cPathBuf\u003e,\n\n    /// Include full details in report\n    #[arg(long)]\n    pub detailed: bool,\n}\n\n/// Output format for plan command\n#[derive(Debug, Clone, PartialEq, Eq, clap::ValueEnum)]\npub enum OutputFormat {\n    Terminal,\n    Json,\n    Sarif,\n}\n\n/// Output format for report command\n#[derive(Debug, Clone, PartialEq, Eq, clap::ValueEnum)]\npub enum ReportFormat {\n    Html,\n    Markdown,\n    Json,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","commands","plan.rs"],"content":"//! Plan command - Analyze repository and show planned actions\n//!\n//! This module implements the `plan` command which analyzes a repository\n//! and generates an action plan to fix detected issues.\n\nuse std::path::PathBuf;\n\nuse super::{OutputFormat, PlanArgs};\nuse crate::actions::planner::ActionPlanner;\nuse crate::cli::output::{JsonOutput, OutputRenderer, SarifOutput, TerminalOutput};\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::exit_codes;\nuse crate::rules::engine::RulesEngine;\nuse crate::scanner::Scanner;\n\n/// Execute the plan command\n///\n/// Analyzes the repository, runs audit rules, generates an action plan,\n/// and outputs the results in the requested format.\n///\n/// # Arguments\n///\n/// * `args` - Command line arguments for the plan command\n///\n/// # Returns\n///\n/// An exit code: 0 for success, 1 for critical issues, 2 for warnings\n///\n/// # Errors\n///\n/// Returns an error if the audit or plan generation fails\npub async fn execute(args: PlanArgs) -\u003e Result\u003ci32, RepoLensError\u003e {\n    // Load configuration\n    let config = Config::load_or_default()?;\n\n    // Initialize scanner\n    let scanner = Scanner::new(PathBuf::from(\".\"));\n\n    // Run the rules engine\n    let mut engine = RulesEngine::new(config.clone());\n\n    // Apply filters if specified\n    if let Some(only) = \u0026args.only {\n        engine.set_only_categories(only.clone());\n    }\n    if let Some(skip) = \u0026args.skip {\n        engine.set_skip_categories(skip.clone());\n    }\n\n    // Execute audit\n    let audit_results = engine.run(\u0026scanner).await?;\n\n    // Generate action plan\n    let planner = ActionPlanner::new(config);\n    let action_plan = planner.create_plan(\u0026audit_results);\n\n    // Render output\n    let output: Box\u003cdyn OutputRenderer\u003e = match args.format {\n        OutputFormat::Terminal =\u003e Box::new(TerminalOutput::new()),\n        OutputFormat::Json =\u003e Box::new(JsonOutput::new()),\n        OutputFormat::Sarif =\u003e Box::new(SarifOutput::new()),\n    };\n\n    let rendered = output.render_plan(\u0026audit_results, \u0026action_plan)?;\n\n    // Write output\n    if let Some(output_path) = args.output {\n        std::fs::write(\u0026output_path, \u0026rendered).map_err(|e| {\n            RepoLensError::Action(crate::error::ActionError::FileWrite {\n                path: output_path.display().to_string(),\n                source: e,\n            })\n        })?;\n        eprintln!(\"Plan written to: {}\", output_path.display());\n    } else {\n        println!(\"{rendered}\");\n    }\n\n    // Determine exit code based on findings\n    let exit_code = if audit_results.has_critical() {\n        exit_codes::CRITICAL_ISSUES\n    } else if audit_results.has_warnings() {\n        exit_codes::WARNINGS\n    } else {\n        exit_codes::SUCCESS\n    };\n\n    Ok(exit_code)\n}\n","traces":[{"line":33,"address":[661448,660144,660206,664060,660392,663475],"length":1,"stats":{"Line":0}},{"line":35,"address":[660385,660510,661409],"length":1,"stats":{"Line":0}},{"line":38,"address":[660745,660824],"length":1,"stats":{"Line":0}},{"line":41,"address":[685459,685382],"length":1,"stats":{"Line":0}},{"line":44,"address":[660961],"length":1,"stats":{"Line":0}},{"line":45,"address":[685561,685725],"length":1,"stats":{"Line":0}},{"line":47,"address":[661211,661078],"length":1,"stats":{"Line":0}},{"line":48,"address":[661219,661317],"length":1,"stats":{"Line":0}},{"line":52,"address":[664286,661342,660422,661264,661474],"length":1,"stats":{"Line":0}},{"line":55,"address":[662035],"length":1,"stats":{"Line":0}},{"line":56,"address":[662176],"length":1,"stats":{"Line":0}},{"line":59,"address":[662366,662220],"length":1,"stats":{"Line":0}},{"line":60,"address":[686790,686854],"length":1,"stats":{"Line":0}},{"line":61,"address":[662269,662446],"length":1,"stats":{"Line":0}},{"line":62,"address":[662488,662279],"length":1,"stats":{"Line":0}},{"line":65,"address":[664214,662398,662589],"length":1,"stats":{"Line":0}},{"line":68,"address":[662801],"length":1,"stats":{"Line":0}},{"line":69,"address":[662914,665032,664784,665038,663021,663127],"length":1,"stats":{"Line":0}},{"line":70,"address":[664957],"length":1,"stats":{"Line":0}},{"line":71,"address":[664811,664884],"length":1,"stats":{"Line":0}},{"line":72,"address":[689480],"length":1,"stats":{"Line":0}},{"line":75,"address":[663168],"length":1,"stats":{"Line":0}},{"line":77,"address":[687454,688009],"length":1,"stats":{"Line":0}},{"line":81,"address":[663559,663595,663405],"length":1,"stats":{"Line":0}},{"line":82,"address":[663584],"length":1,"stats":{"Line":0}},{"line":83,"address":[663573,663618,663601],"length":1,"stats":{"Line":0}},{"line":84,"address":[663620],"length":1,"stats":{"Line":0}},{"line":86,"address":[663607],"length":1,"stats":{"Line":0}},{"line":89,"address":[663631],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","commands","report.rs"],"content":"//! Report command - Generate an audit report\n\nuse colored::Colorize;\nuse std::path::PathBuf;\n\nuse super::{ReportArgs, ReportFormat};\nuse crate::cli::output::{HtmlReport, JsonOutput, MarkdownReport, ReportRenderer};\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::exit_codes;\nuse crate::rules::engine::RulesEngine;\nuse crate::scanner::Scanner;\n\npub async fn execute(args: ReportArgs) -\u003e Result\u003ci32, RepoLensError\u003e {\n    // Load configuration\n    let config = Config::load_or_default()?;\n\n    // Initialize scanner\n    let scanner = Scanner::new(PathBuf::from(\".\"));\n\n    // Run the rules engine\n    let engine = RulesEngine::new(config);\n    let audit_results = engine.run(\u0026scanner).await?;\n\n    // Generate report\n    let renderer: Box\u003cdyn ReportRenderer\u003e = match args.format {\n        ReportFormat::Html =\u003e Box::new(HtmlReport::new(args.detailed)),\n        ReportFormat::Markdown =\u003e Box::new(MarkdownReport::new(args.detailed)),\n        ReportFormat::Json =\u003e Box::new(JsonOutput::new()),\n    };\n\n    let report = renderer.render_report(\u0026audit_results)?;\n\n    // Write output\n    let output_path = args.output.unwrap_or_else(|| {\n        let extension = match args.format {\n            ReportFormat::Html =\u003e \"html\",\n            ReportFormat::Markdown =\u003e \"md\",\n            ReportFormat::Json =\u003e \"json\",\n        };\n        PathBuf::from(format!(\"repolens-report.{extension}\"))\n    });\n\n    std::fs::write(\u0026output_path, \u0026report).map_err(|e| {\n        RepoLensError::Action(crate::error::ActionError::FileWrite {\n            path: output_path.display().to_string(),\n            source: e,\n        })\n    })?;\n\n    println!(\n        \"{} Report written to: {}\",\n        \"Success:\".green().bold(),\n        output_path.display().to_string().cyan()\n    );\n\n    // Return exit code based on findings\n    let exit_code = if audit_results.has_critical() {\n        exit_codes::CRITICAL_ISSUES\n    } else if audit_results.has_warnings() {\n        exit_codes::WARNINGS\n    } else {\n        exit_codes::SUCCESS\n    };\n\n    Ok(exit_code)\n}\n","traces":[{"line":14,"address":[998803,998800],"length":1,"stats":{"Line":0}},{"line":16,"address":[37177,37048,37781],"length":1,"stats":{"Line":0}},{"line":19,"address":[37478,37399],"length":1,"stats":{"Line":0}},{"line":22,"address":[37505],"length":1,"stats":{"Line":0}},{"line":23,"address":[37714,37623,37085,37850,40316],"length":1,"stats":{"Line":0}},{"line":26,"address":[38411,38599],"length":1,"stats":{"Line":0}},{"line":27,"address":[38450,38553],"length":1,"stats":{"Line":0}},{"line":28,"address":[38473,38678],"length":1,"stats":{"Line":0}},{"line":29,"address":[38726,38499],"length":1,"stats":{"Line":0}},{"line":32,"address":[40280,38631,38827],"length":1,"stats":{"Line":0}},{"line":35,"address":[40496,39007],"length":1,"stats":{"Line":0}},{"line":36,"address":[40518],"length":1,"stats":{"Line":0}},{"line":37,"address":[76971],"length":1,"stats":{"Line":0}},{"line":38,"address":[40578],"length":1,"stats":{"Line":0}},{"line":39,"address":[40601],"length":1,"stats":{"Line":0}},{"line":41,"address":[40622],"length":1,"stats":{"Line":0}},{"line":44,"address":[41022,39336,41016,39156,39230,40768],"length":1,"stats":{"Line":0}},{"line":45,"address":[40941],"length":1,"stats":{"Line":0}},{"line":46,"address":[77211,77284],"length":1,"stats":{"Line":0}},{"line":47,"address":[40936],"length":1,"stats":{"Line":0}},{"line":51,"address":[76094,75922],"length":1,"stats":{"Line":0}},{"line":58,"address":[39915,39966],"length":1,"stats":{"Line":0}},{"line":59,"address":[39955],"length":1,"stats":{"Line":0}},{"line":60,"address":[39944,39989,39972],"length":1,"stats":{"Line":0}},{"line":61,"address":[39991],"length":1,"stats":{"Line":0}},{"line":63,"address":[39978],"length":1,"stats":{"Line":0}},{"line":66,"address":[40002],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","mod.rs"],"content":"//! CLI module - Command line interface definition and handlers\n\npub mod commands;\npub mod output;\n\nuse clap::{Parser, Subcommand};\nuse std::path::PathBuf;\n\nuse commands::{ApplyArgs, InitArgs, PlanArgs, ReportArgs};\n\n/// RepoLens - Audit and prepare repositories for open source or enterprise standards\n#[derive(Parser, Debug)]\n#[command(name = \"repolens\")]\n#[command(author, version, about, long_about = None)]\n#[command(propagate_version = true)]\npub struct Cli {\n    /// Increase verbosity level (-v, -vv, -vvv)\n    #[arg(short, long, action = clap::ArgAction::Count, global = true)]\n    pub verbose: u8,\n\n    /// Path to configuration file\n    #[arg(short, long, global = true, value_name = \"FILE\")]\n    pub config: Option\u003cPathBuf\u003e,\n\n    /// Working directory (defaults to current directory)\n    #[arg(short = 'C', long, global = true, value_name = \"DIR\")]\n    pub directory: Option\u003cPathBuf\u003e,\n\n    #[command(subcommand)]\n    pub command: Commands,\n}\n\n#[derive(Subcommand, Debug)]\npub enum Commands {\n    /// Initialize a new configuration file\n    Init(InitArgs),\n\n    /// Analyze repository and show planned actions\n    Plan(PlanArgs),\n\n    /// Apply planned changes to the repository\n    Apply(ApplyArgs),\n\n    /// Generate an audit report\n    Report(ReportArgs),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","html.rs"],"content":"//! HTML report output\n\nuse crate::error::RepoLensError;\nuse chrono::Utc;\n\nuse super::ReportRenderer;\nuse crate::rules::results::{AuditResults, Severity};\n\npub struct HtmlReport {\n    detailed: bool,\n}\n\nimpl HtmlReport {\n    pub fn new(detailed: bool) -\u003e Self {\n        Self { detailed }\n    }\n}\n\nimpl ReportRenderer for HtmlReport {\n    fn render_report(\u0026self, results: \u0026AuditResults) -\u003e Result\u003cString, RepoLensError\u003e {\n        let critical_count = results.count_by_severity(Severity::Critical);\n        let warning_count = results.count_by_severity(Severity::Warning);\n        let info_count = results.count_by_severity(Severity::Info);\n\n        let status_color = if critical_count \u003e 0 {\n            \"#dc3545\"\n        } else if warning_count \u003e 0 {\n            \"#ffc107\"\n        } else {\n            \"#28a745\"\n        };\n\n        let mut findings_html = String::new();\n\n        // Critical findings\n        for finding in results.findings_by_severity(Severity::Critical) {\n            findings_html.push_str(\u0026format!(\n                r#\"\u003cdiv class=\"finding critical\"\u003e\n                    \u003cdiv class=\"finding-header\"\u003e\n                        \u003cspan class=\"badge critical\"\u003eCRITICAL\u003c/span\u003e\n                        \u003cspan class=\"rule-id\"\u003e{}\u003c/span\u003e\n                    \u003c/div\u003e\n                    \u003cdiv class=\"finding-message\"\u003e{}\u003c/div\u003e\n                    {}\n                    {}\n                \u003c/div\u003e\"#,\n                finding.rule_id,\n                finding.message,\n                finding.location.as_ref().map_or(String::new(), |l| {\n                    format!(r#\"\u003cdiv class=\"finding-location\"\u003eLocation: \u003ccode\u003e{}\u003c/code\u003e\u003c/div\u003e\"#, l)\n                }),\n                if self.detailed {\n                    format!(\n                        \"{}{}\",\n                        finding.description.as_ref().map_or(String::new(), |d| {\n                            format!(r#\"\u003cdiv class=\"finding-description\"\u003e{}\u003c/div\u003e\"#, d)\n                        }),\n                        finding.remediation.as_ref().map_or(String::new(), |r| {\n                            format!(r#\"\u003cdiv class=\"finding-remediation\"\u003e\u003cstrong\u003eRemediation:\u003c/strong\u003e {}\u003c/div\u003e\"#, r)\n                        })\n                    )\n                } else {\n                    String::new()\n                }\n            ));\n        }\n\n        // Warning findings\n        for finding in results.findings_by_severity(Severity::Warning) {\n            findings_html.push_str(\u0026format!(\n                r#\"\u003cdiv class=\"finding warning\"\u003e\n                    \u003cdiv class=\"finding-header\"\u003e\n                        \u003cspan class=\"badge warning\"\u003eWARNING\u003c/span\u003e\n                        \u003cspan class=\"rule-id\"\u003e{}\u003c/span\u003e\n                    \u003c/div\u003e\n                    \u003cdiv class=\"finding-message\"\u003e{}\u003c/div\u003e\n                    {}\n                \u003c/div\u003e\"#,\n                finding.rule_id,\n                finding.message,\n                finding.location.as_ref().map_or(String::new(), |l| {\n                    format!(\n                        r#\"\u003cdiv class=\"finding-location\"\u003eLocation: \u003ccode\u003e{}\u003c/code\u003e\u003c/div\u003e\"#,\n                        l\n                    )\n                })\n            ));\n        }\n\n        // Info findings\n        if self.detailed {\n            for finding in results.findings_by_severity(Severity::Info) {\n                findings_html.push_str(\u0026format!(\n                    r#\"\u003cdiv class=\"finding info\"\u003e\n                        \u003cdiv class=\"finding-header\"\u003e\n                            \u003cspan class=\"badge info\"\u003eINFO\u003c/span\u003e\n                            \u003cspan class=\"rule-id\"\u003e{}\u003c/span\u003e\n                        \u003c/div\u003e\n                        \u003cdiv class=\"finding-message\"\u003e{}\u003c/div\u003e\n                    \u003c/div\u003e\"#,\n                    finding.rule_id, finding.message\n                ));\n            }\n        }\n\n        let html = format!(\n            r#\"\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eRepoLens Audit Report - {}\u003c/title\u003e\n    \u003cstyle\u003e\n        :root {{\n            --critical: #dc3545;\n            --warning: #ffc107;\n            --info: #17a2b8;\n            --success: #28a745;\n        }}\n        * {{ box-sizing: border-box; margin: 0; padding: 0; }}\n        body {{\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n            line-height: 1.6;\n            color: #333;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 2rem;\n            background: #f8f9fa;\n        }}\n        header {{\n            background: white;\n            padding: 2rem;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n            margin-bottom: 2rem;\n        }}\n        h1 {{ color: #333; margin-bottom: 1rem; }}\n        .meta {{ color: #666; font-size: 0.9rem; }}\n        .summary {{\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));\n            gap: 1rem;\n            margin: 2rem 0;\n        }}\n        .stat {{\n            background: white;\n            padding: 1.5rem;\n            border-radius: 8px;\n            text-align: center;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }}\n        .stat-value {{ font-size: 2rem; font-weight: bold; }}\n        .stat-label {{ color: #666; font-size: 0.9rem; }}\n        .stat.critical .stat-value {{ color: var(--critical); }}\n        .stat.warning .stat-value {{ color: var(--warning); }}\n        .stat.info .stat-value {{ color: var(--info); }}\n        .status-indicator {{\n            display: inline-block;\n            width: 12px;\n            height: 12px;\n            border-radius: 50%;\n            margin-right: 8px;\n        }}\n        .findings {{ margin-top: 2rem; }}\n        .finding {{\n            background: white;\n            padding: 1.5rem;\n            border-radius: 8px;\n            margin-bottom: 1rem;\n            border-left: 4px solid;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }}\n        .finding.critical {{ border-color: var(--critical); }}\n        .finding.warning {{ border-color: var(--warning); }}\n        .finding.info {{ border-color: var(--info); }}\n        .finding-header {{ display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem; }}\n        .badge {{\n            padding: 0.25rem 0.5rem;\n            border-radius: 4px;\n            font-size: 0.75rem;\n            font-weight: bold;\n            color: white;\n        }}\n        .badge.critical {{ background: var(--critical); }}\n        .badge.warning {{ background: var(--warning); color: #333; }}\n        .badge.info {{ background: var(--info); }}\n        .rule-id {{ color: #666; font-family: monospace; }}\n        .finding-message {{ font-weight: 500; }}\n        .finding-location {{ margin-top: 0.5rem; color: #666; font-size: 0.9rem; }}\n        .finding-location code {{ background: #f1f1f1; padding: 0.2rem 0.4rem; border-radius: 4px; }}\n        .finding-description {{ margin-top: 0.5rem; color: #555; }}\n        .finding-remediation {{ margin-top: 0.5rem; color: #28a745; }}\n        footer {{\n            margin-top: 3rem;\n            text-align: center;\n            color: #666;\n            font-size: 0.9rem;\n        }}\n        footer a {{ color: #007bff; text-decoration: none; }}\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003cheader\u003e\n        \u003ch1\u003e\n            \u003cspan class=\"status-indicator\" style=\"background: {}\"\u003e\u003c/span\u003e\n            RepoLens Audit Report\n        \u003c/h1\u003e\n        \u003cdiv class=\"meta\"\u003e\n            \u003cp\u003e\u003cstrong\u003eRepository:\u003c/strong\u003e {}\u003c/p\u003e\n            \u003cp\u003e\u003cstrong\u003ePreset:\u003c/strong\u003e {}\u003c/p\u003e\n            \u003cp\u003e\u003cstrong\u003eGenerated:\u003c/strong\u003e {}\u003c/p\u003e\n            \u003cp\u003e\u003cstrong\u003eVersion:\u003c/strong\u003e {}\u003c/p\u003e\n        \u003c/div\u003e\n    \u003c/header\u003e\n\n    \u003csection class=\"summary\"\u003e\n        \u003cdiv class=\"stat critical\"\u003e\n            \u003cdiv class=\"stat-value\"\u003e{}\u003c/div\u003e\n            \u003cdiv class=\"stat-label\"\u003eCritical\u003c/div\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"stat warning\"\u003e\n            \u003cdiv class=\"stat-value\"\u003e{}\u003c/div\u003e\n            \u003cdiv class=\"stat-label\"\u003eWarnings\u003c/div\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"stat info\"\u003e\n            \u003cdiv class=\"stat-value\"\u003e{}\u003c/div\u003e\n            \u003cdiv class=\"stat-label\"\u003eInfo\u003c/div\u003e\n        \u003c/div\u003e\n    \u003c/section\u003e\n\n    \u003csection class=\"findings\"\u003e\n        \u003ch2\u003eFindings\u003c/h2\u003e\n        {}\n    \u003c/section\u003e\n\n    \u003cfooter\u003e\n        \u003cp\u003eReport generated by \u003ca href=\"https://github.com/kdelfour/repolens\"\u003eRepoLens\u003c/a\u003e\u003c/p\u003e\n    \u003c/footer\u003e\n\u003c/body\u003e\n\u003c/html\u003e\"#,\n            results.repository_name,\n            status_color,\n            results.repository_name,\n            results.preset,\n            Utc::now().format(\"%Y-%m-%d %H:%M:%S UTC\"),\n            env!(\"CARGO_PKG_VERSION\"),\n            critical_count,\n            warning_count,\n            info_count,\n            findings_html\n        );\n\n        Ok(html)\n    }\n}\n","traces":[{"line":14,"address":[655360],"length":1,"stats":{"Line":0}},{"line":20,"address":[659173,655376,657153],"length":1,"stats":{"Line":0}},{"line":21,"address":[655442],"length":1,"stats":{"Line":0}},{"line":22,"address":[655479],"length":1,"stats":{"Line":0}},{"line":23,"address":[655516],"length":1,"stats":{"Line":0}},{"line":25,"address":[655545,655596],"length":1,"stats":{"Line":0}},{"line":26,"address":[655569],"length":1,"stats":{"Line":0}},{"line":27,"address":[655654,655556,655625],"length":1,"stats":{"Line":0}},{"line":28,"address":[655627],"length":1,"stats":{"Line":0}},{"line":30,"address":[655598],"length":1,"stats":{"Line":0}},{"line":33,"address":[655694],"length":1,"stats":{"Line":0}},{"line":36,"address":[655707,655798],"length":1,"stats":{"Line":0}},{"line":37,"address":[655944,657934,658025,658710,658151,659144],"length":1,"stats":{"Line":0}},{"line":49,"address":[513808],"length":1,"stats":{"Line":0}},{"line":50,"address":[513829],"length":1,"stats":{"Line":0}},{"line":52,"address":[658104],"length":1,"stats":{"Line":0}},{"line":53,"address":[658224,658363],"length":1,"stats":{"Line":0}},{"line":55,"address":[658189,658129],"length":1,"stats":{"Line":0}},{"line":56,"address":[513957],"length":1,"stats":{"Line":0}},{"line":58,"address":[658300],"length":1,"stats":{"Line":0}},{"line":59,"address":[514085],"length":1,"stats":{"Line":0}},{"line":63,"address":[112213,112245],"length":1,"stats":{"Line":0}},{"line":69,"address":[110070],"length":1,"stats":{"Line":0}},{"line":70,"address":[111520,111996,110257,111611],"length":1,"stats":{"Line":0}},{"line":81,"address":[111548],"length":1,"stats":{"Line":0}},{"line":82,"address":[514213],"length":1,"stats":{"Line":0}},{"line":91,"address":[656191],"length":1,"stats":{"Line":0}},{"line":92,"address":[656234],"length":1,"stats":{"Line":0}},{"line":93,"address":[657390,657164,656425],"length":1,"stats":{"Line":0}},{"line":106,"address":[656204,656602,656447],"length":1,"stats":{"Line":0}},{"line":245,"address":[656532],"length":1,"stats":{"Line":0}},{"line":253,"address":[657080],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","json.rs"],"content":"//! JSON output formatting\n\nuse crate::error::RepoLensError;\nuse serde::Serialize;\n\nuse super::{OutputRenderer, ReportRenderer};\nuse crate::actions::plan::ActionPlan;\nuse crate::rules::results::AuditResults;\n\npub struct JsonOutput;\n\nimpl JsonOutput {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\nimpl Default for JsonOutput {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[derive(Serialize)]\nstruct PlanOutput\u003c'a\u003e {\n    version: \u0026'static str,\n    repository: \u0026'a str,\n    preset: \u0026'a str,\n    audit: AuditSummary\u003c'a\u003e,\n    actions: Vec\u003cActionSummary\u003c'a\u003e\u003e,\n}\n\n#[derive(Serialize)]\nstruct AuditSummary\u003c'a\u003e {\n    critical_count: usize,\n    warning_count: usize,\n    info_count: usize,\n    findings: \u0026'a [crate::rules::results::Finding],\n}\n\n#[derive(Serialize)]\nstruct ActionSummary\u003c'a\u003e {\n    category: \u0026'a str,\n    description: \u0026'a str,\n    details: \u0026'a [String],\n}\n\nimpl OutputRenderer for JsonOutput {\n    fn render_plan(\n        \u0026self,\n        results: \u0026AuditResults,\n        plan: \u0026ActionPlan,\n    ) -\u003e Result\u003cString, RepoLensError\u003e {\n        let output = PlanOutput {\n            version: env!(\"CARGO_PKG_VERSION\"),\n            repository: \u0026results.repository_name,\n            preset: \u0026results.preset,\n            audit: AuditSummary {\n                critical_count: results\n                    .count_by_severity(crate::rules::results::Severity::Critical),\n                warning_count: results.count_by_severity(crate::rules::results::Severity::Warning),\n                info_count: results.count_by_severity(crate::rules::results::Severity::Info),\n                findings: results.findings(),\n            },\n            actions: plan\n                .actions()\n                .iter()\n                .map(|a| ActionSummary {\n                    category: a.category(),\n                    description: a.description(),\n                    details: a.details(),\n                })\n                .collect(),\n        };\n\n        Ok(serde_json::to_string_pretty(\u0026output)?)\n    }\n}\n\nimpl ReportRenderer for JsonOutput {\n    fn render_report(\u0026self, results: \u0026AuditResults) -\u003e Result\u003cString, RepoLensError\u003e {\n        Ok(serde_json::to_string_pretty(results)?)\n    }\n}\n","traces":[{"line":19,"address":[478976],"length":1,"stats":{"Line":0}},{"line":20,"address":[478977],"length":1,"stats":{"Line":0}},{"line":49,"address":[478992,479766,479772],"length":1,"stats":{"Line":0}},{"line":56,"address":[479051],"length":1,"stats":{"Line":0}},{"line":57,"address":[479071],"length":1,"stats":{"Line":0}},{"line":58,"address":[479213],"length":1,"stats":{"Line":0}},{"line":65,"address":[479253],"length":1,"stats":{"Line":0}},{"line":76,"address":[479519,479459],"length":1,"stats":{"Line":0}},{"line":81,"address":[479792],"length":1,"stats":{"Line":0}},{"line":82,"address":[479827],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","markdown.rs"],"content":"//! Markdown report output\n\nuse crate::error::RepoLensError;\nuse chrono::Utc;\n\nuse super::ReportRenderer;\nuse crate::rules::results::{AuditResults, Severity};\n\npub struct MarkdownReport {\n    detailed: bool,\n}\n\nimpl MarkdownReport {\n    pub fn new(detailed: bool) -\u003e Self {\n        Self { detailed }\n    }\n}\n\nimpl ReportRenderer for MarkdownReport {\n    fn render_report(\u0026self, results: \u0026AuditResults) -\u003e Result\u003cString, RepoLensError\u003e {\n        let mut output = String::new();\n\n        // Header\n        output.push_str(\u0026format!(\n            \"# RepoLens Audit Report\\n\\n\\\n             **Repository:** {}\\n\\\n             **Preset:** {}\\n\\\n             **Generated:** {}\\n\\\n             **RepoLens Version:** {}\\n\\n\",\n            results.repository_name,\n            results.preset,\n            Utc::now().format(\"%Y-%m-%d %H:%M:%S UTC\"),\n            env!(\"CARGO_PKG_VERSION\")\n        ));\n\n        // Summary\n        output.push_str(\"## Summary\\n\\n\");\n        output.push_str(\"| Severity | Count |\\n\");\n        output.push_str(\"|----------|-------|\\n\");\n        output.push_str(\u0026format!(\n            \"| Critical | {} |\\n\",\n            results.count_by_severity(Severity::Critical)\n        ));\n        output.push_str(\u0026format!(\n            \"| Warning | {} |\\n\",\n            results.count_by_severity(Severity::Warning)\n        ));\n        output.push_str(\u0026format!(\n            \"| Info | {} |\\n\\n\",\n            results.count_by_severity(Severity::Info)\n        ));\n\n        // Critical findings\n        let critical: Vec\u003c_\u003e = results.findings_by_severity(Severity::Critical).collect();\n        if !critical.is_empty() {\n            output.push_str(\"## Critical Issues\\n\\n\");\n            output.push_str(\"These issues must be resolved before proceeding.\\n\\n\");\n            for finding in critical {\n                output.push_str(\u0026format!(\n                    \"### {} - {}\\n\\n\",\n                    finding.rule_id, finding.message\n                ));\n                if let Some(location) = \u0026finding.location {\n                    output.push_str(\u0026format!(\"**Location:** `{}`\\n\\n\", location));\n                }\n                if self.detailed {\n                    if let Some(description) = \u0026finding.description {\n                        output.push_str(\u0026format!(\"{}\\n\\n\", description));\n                    }\n                    if let Some(remediation) = \u0026finding.remediation {\n                        output.push_str(\u0026format!(\"**Remediation:** {}\\n\\n\", remediation));\n                    }\n                }\n            }\n        }\n\n        // Warning findings\n        let warnings: Vec\u003c_\u003e = results.findings_by_severity(Severity::Warning).collect();\n        if !warnings.is_empty() {\n            output.push_str(\"## Warnings\\n\\n\");\n            output.push_str(\"These issues should be addressed.\\n\\n\");\n            for finding in warnings {\n                output.push_str(\u0026format!(\n                    \"### {} - {}\\n\\n\",\n                    finding.rule_id, finding.message\n                ));\n                if let Some(location) = \u0026finding.location {\n                    output.push_str(\u0026format!(\"**Location:** `{}`\\n\\n\", location));\n                }\n                if self.detailed {\n                    if let Some(description) = \u0026finding.description {\n                        output.push_str(\u0026format!(\"{}\\n\\n\", description));\n                    }\n                    if let Some(remediation) = \u0026finding.remediation {\n                        output.push_str(\u0026format!(\"**Remediation:** {}\\n\\n\", remediation));\n                    }\n                }\n            }\n        }\n\n        // Info findings\n        let info: Vec\u003c_\u003e = results.findings_by_severity(Severity::Info).collect();\n        if !info.is_empty() \u0026\u0026 self.detailed {\n            output.push_str(\"## Informational\\n\\n\");\n            output.push_str(\"These are suggestions for improvement.\\n\\n\");\n            for finding in info {\n                output.push_str(\u0026format!(\"- **{}**: {}\\n\", finding.rule_id, finding.message));\n            }\n            output.push('\\n');\n        }\n\n        // Footer\n        output.push_str(\"---\\n\\n\");\n        output.push_str(\"*Report generated by [RepoLens](https://github.com/kdelfour/repolens)*\\n\");\n\n        Ok(output)\n    }\n}\n","traces":[{"line":14,"address":[114368],"length":1,"stats":{"Line":0}},{"line":20,"address":[114384,117219,120689],"length":1,"stats":{"Line":0}},{"line":21,"address":[114439],"length":1,"stats":{"Line":0}},{"line":24,"address":[114500,114661,115030,114568],"length":1,"stats":{"Line":0}},{"line":32,"address":[114591],"length":1,"stats":{"Line":0}},{"line":37,"address":[115056],"length":1,"stats":{"Line":0}},{"line":38,"address":[115083],"length":1,"stats":{"Line":0}},{"line":39,"address":[115110],"length":1,"stats":{"Line":0}},{"line":40,"address":[115192,115418],"length":1,"stats":{"Line":0}},{"line":42,"address":[115145],"length":1,"stats":{"Line":0}},{"line":44,"address":[115499,115725],"length":1,"stats":{"Line":0}},{"line":46,"address":[115452],"length":1,"stats":{"Line":0}},{"line":48,"address":[116032,115806],"length":1,"stats":{"Line":0}},{"line":50,"address":[115759],"length":1,"stats":{"Line":0}},{"line":54,"address":[116066],"length":1,"stats":{"Line":0}},{"line":55,"address":[116198,116136],"length":1,"stats":{"Line":0}},{"line":56,"address":[116204],"length":1,"stats":{"Line":0}},{"line":57,"address":[116273],"length":1,"stats":{"Line":0}},{"line":58,"address":[116300,116498],"length":1,"stats":{"Line":0}},{"line":59,"address":[1577246,1577484,1577201],"length":1,"stats":{"Line":0}},{"line":63,"address":[116878],"length":1,"stats":{"Line":0}},{"line":64,"address":[1577631,1577582],"length":1,"stats":{"Line":0}},{"line":66,"address":[116977],"length":1,"stats":{"Line":0}},{"line":67,"address":[1577873],"length":1,"stats":{"Line":0}},{"line":68,"address":[117389,117297],"length":1,"stats":{"Line":0}},{"line":70,"address":[1577972,1578265],"length":1,"stats":{"Line":0}},{"line":71,"address":[117633],"length":1,"stats":{"Line":0}},{"line":78,"address":[117904,116239],"length":1,"stats":{"Line":0}},{"line":79,"address":[117927,117989],"length":1,"stats":{"Line":0}},{"line":80,"address":[117995],"length":1,"stats":{"Line":0}},{"line":81,"address":[1578704],"length":1,"stats":{"Line":0}},{"line":82,"address":[118091,118289],"length":1,"stats":{"Line":0}},{"line":83,"address":[118352,118397,118623],"length":1,"stats":{"Line":0}},{"line":87,"address":[118657],"length":1,"stats":{"Line":0}},{"line":88,"address":[1579404,1579355],"length":1,"stats":{"Line":0}},{"line":90,"address":[118750],"length":1,"stats":{"Line":0}},{"line":91,"address":[1579628],"length":1,"stats":{"Line":0}},{"line":92,"address":[119046,119135],"length":1,"stats":{"Line":0}},{"line":94,"address":[1579996,1579721],"length":1,"stats":{"Line":0}},{"line":95,"address":[119364],"length":1,"stats":{"Line":0}},{"line":102,"address":[119623,118030],"length":1,"stats":{"Line":0}},{"line":103,"address":[119646,119702],"length":1,"stats":{"Line":0}},{"line":104,"address":[1580391],"length":1,"stats":{"Line":0}},{"line":105,"address":[119778],"length":1,"stats":{"Line":0}},{"line":106,"address":[119805,119997],"length":1,"stats":{"Line":0}},{"line":107,"address":[120057,120121],"length":1,"stats":{"Line":0}},{"line":109,"address":[120104],"length":1,"stats":{"Line":0}},{"line":113,"address":[119721],"length":1,"stats":{"Line":0}},{"line":114,"address":[120374],"length":1,"stats":{"Line":0}},{"line":116,"address":[120409],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":50},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","mod.rs"],"content":"//! Output formatting module for CLI\n\nmod html;\nmod json;\nmod markdown;\nmod sarif;\nmod terminal;\n\npub use html::HtmlReport;\npub use json::JsonOutput;\npub use markdown::MarkdownReport;\npub use sarif::SarifOutput;\npub use terminal::TerminalOutput;\n\nuse crate::actions::plan::ActionPlan;\nuse crate::error::RepoLensError;\nuse crate::rules::results::AuditResults;\n\n/// Trait for rendering plan output\npub trait OutputRenderer {\n    fn render_plan(\n        \u0026self,\n        results: \u0026AuditResults,\n        plan: \u0026ActionPlan,\n    ) -\u003e Result\u003cString, RepoLensError\u003e;\n}\n\n/// Trait for rendering report output\npub trait ReportRenderer {\n    fn render_report(\u0026self, results: \u0026AuditResults) -\u003e Result\u003cString, RepoLensError\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","sarif.rs"],"content":"//! SARIF output formatting for GitHub Code Scanning integration\n\nuse crate::error::RepoLensError;\nuse serde::Serialize;\n\nuse super::OutputRenderer;\nuse crate::actions::plan::ActionPlan;\nuse crate::rules::results::{AuditResults, Finding, Severity};\n\npub struct SarifOutput;\n\nimpl SarifOutput {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\nimpl Default for SarifOutput {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[derive(Serialize)]\nstruct SarifReport {\n    #[serde(rename = \"$schema\")]\n    schema: \u0026'static str,\n    version: \u0026'static str,\n    runs: Vec\u003cSarifRun\u003e,\n}\n\n#[derive(Serialize)]\nstruct SarifRun {\n    tool: SarifTool,\n    results: Vec\u003cSarifResult\u003e,\n}\n\n#[derive(Serialize)]\nstruct SarifTool {\n    driver: SarifDriver,\n}\n\n#[derive(Serialize)]\nstruct SarifDriver {\n    name: \u0026'static str,\n    version: \u0026'static str,\n    #[serde(rename = \"informationUri\")]\n    information_uri: \u0026'static str,\n    rules: Vec\u003cSarifRule\u003e,\n}\n\n#[derive(Serialize)]\nstruct SarifRule {\n    id: String,\n    name: String,\n    #[serde(rename = \"shortDescription\")]\n    short_description: SarifMessage,\n    #[serde(rename = \"defaultConfiguration\")]\n    default_configuration: SarifDefaultConfig,\n}\n\n#[derive(Serialize)]\nstruct SarifDefaultConfig {\n    level: String,\n}\n\n#[derive(Serialize)]\nstruct SarifResult {\n    #[serde(rename = \"ruleId\")]\n    rule_id: String,\n    level: String,\n    message: SarifMessage,\n    locations: Vec\u003cSarifLocation\u003e,\n}\n\n#[derive(Serialize)]\nstruct SarifMessage {\n    text: String,\n}\n\n#[derive(Serialize)]\nstruct SarifLocation {\n    #[serde(rename = \"physicalLocation\")]\n    physical_location: SarifPhysicalLocation,\n}\n\n#[derive(Serialize)]\nstruct SarifPhysicalLocation {\n    #[serde(rename = \"artifactLocation\")]\n    artifact_location: SarifArtifactLocation,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    region: Option\u003cSarifRegion\u003e,\n}\n\n#[derive(Serialize)]\nstruct SarifArtifactLocation {\n    uri: String,\n}\n\n#[derive(Serialize)]\nstruct SarifRegion {\n    #[serde(rename = \"startLine\")]\n    start_line: u32,\n    #[serde(rename = \"startColumn\", skip_serializing_if = \"Option::is_none\")]\n    start_column: Option\u003cu32\u003e,\n}\n\nimpl SarifOutput {\n    fn severity_to_level(severity: Severity) -\u003e \u0026'static str {\n        match severity {\n            Severity::Critical =\u003e \"error\",\n            Severity::Warning =\u003e \"warning\",\n            Severity::Info =\u003e \"note\",\n        }\n    }\n\n    fn finding_to_result(finding: \u0026Finding) -\u003e SarifResult {\n        let (uri, region) = if let Some(location) = \u0026finding.location {\n            // Parse location like \"src/config.ts:42\"\n            let parts: Vec\u003c\u0026str\u003e = location.split(':').collect();\n            let uri = parts.first().unwrap_or(\u0026\"unknown\").to_string();\n            let region = parts.get(1).and_then(|line| {\n                line.parse::\u003cu32\u003e().ok().map(|l| SarifRegion {\n                    start_line: l,\n                    start_column: None,\n                })\n            });\n            (uri, region)\n        } else {\n            (\"unknown\".to_string(), None)\n        };\n\n        SarifResult {\n            rule_id: finding.rule_id.clone(),\n            level: Self::severity_to_level(finding.severity).to_string(),\n            message: SarifMessage {\n                text: finding.message.clone(),\n            },\n            locations: vec![SarifLocation {\n                physical_location: SarifPhysicalLocation {\n                    artifact_location: SarifArtifactLocation { uri },\n                    region,\n                },\n            }],\n        }\n    }\n}\n\nimpl OutputRenderer for SarifOutput {\n    fn render_plan(\n        \u0026self,\n        results: \u0026AuditResults,\n        _plan: \u0026ActionPlan,\n    ) -\u003e Result\u003cString, RepoLensError\u003e {\n        let rules: Vec\u003cSarifRule\u003e = results\n            .findings()\n            .iter()\n            .map(|f| SarifRule {\n                id: f.rule_id.clone(),\n                name: f.rule_id.clone(),\n                short_description: SarifMessage {\n                    text: f.message.clone(),\n                },\n                default_configuration: SarifDefaultConfig {\n                    level: Self::severity_to_level(f.severity).to_string(),\n                },\n            })\n            .collect();\n\n        let results_sarif: Vec\u003cSarifResult\u003e = results\n            .findings()\n            .iter()\n            .map(Self::finding_to_result)\n            .collect();\n\n        let report = SarifReport {\n            schema: \"https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json\",\n            version: \"2.1.0\",\n            runs: vec![SarifRun {\n                tool: SarifTool {\n                    driver: SarifDriver {\n                        name: \"repolens\",\n                        version: env!(\"CARGO_PKG_VERSION\"),\n                        information_uri: \"https://github.com/kdelfour/repolens\",\n                        rules,\n                    },\n                },\n                results: results_sarif,\n            }],\n        };\n\n        Ok(serde_json::to_string_pretty(\u0026report)?)\n    }\n}\n","traces":[{"line":19,"address":[690320],"length":1,"stats":{"Line":0}},{"line":20,"address":[860673],"length":1,"stats":{"Line":0}},{"line":109,"address":[860688],"length":1,"stats":{"Line":0}},{"line":110,"address":[860695],"length":1,"stats":{"Line":0}},{"line":111,"address":[690374],"length":1,"stats":{"Line":0}},{"line":112,"address":[860749],"length":1,"stats":{"Line":0}},{"line":113,"address":[860772],"length":1,"stats":{"Line":0}},{"line":117,"address":[861591,861597,860816],"length":1,"stats":{"Line":0}},{"line":118,"address":[860846,861118,861502],"length":1,"stats":{"Line":0}},{"line":120,"address":[860912],"length":1,"stats":{"Line":0}},{"line":121,"address":[861177,860979],"length":1,"stats":{"Line":0}},{"line":122,"address":[1420432],"length":1,"stats":{"Line":0}},{"line":123,"address":[1420450,1420543,1420528],"length":1,"stats":{"Line":0}},{"line":125,"address":[1420535],"length":1,"stats":{"Line":0}},{"line":128,"address":[861357],"length":1,"stats":{"Line":0}},{"line":130,"address":[861003],"length":1,"stats":{"Line":0}},{"line":134,"address":[691220],"length":1,"stats":{"Line":0}},{"line":135,"address":[861653,861727],"length":1,"stats":{"Line":0}},{"line":136,"address":[691463],"length":1,"stats":{"Line":0}},{"line":139,"address":[691505,691735],"length":1,"stats":{"Line":0}},{"line":150,"address":[863722,862448,863716],"length":1,"stats":{"Line":0}},{"line":155,"address":[692150],"length":1,"stats":{"Line":0}},{"line":158,"address":[1421054,1420560,1421048,1420924],"length":1,"stats":{"Line":0}},{"line":159,"address":[1420606],"length":1,"stats":{"Line":0}},{"line":160,"address":[1420640],"length":1,"stats":{"Line":0}},{"line":161,"address":[1420756],"length":1,"stats":{"Line":0}},{"line":162,"address":[1420690],"length":1,"stats":{"Line":0}},{"line":164,"address":[1420876],"length":1,"stats":{"Line":0}},{"line":165,"address":[1420782,1420847],"length":1,"stats":{"Line":0}},{"line":170,"address":[862639,862571],"length":1,"stats":{"Line":0}},{"line":179,"address":[863024,862723],"length":1,"stats":{"Line":0}},{"line":192,"address":[863428,863365],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","terminal.rs"],"content":"//! Terminal output formatting with colors\n\nuse crate::error::RepoLensError;\nuse colored::Colorize;\n\nuse super::{OutputRenderer, ReportRenderer};\nuse crate::actions::plan::ActionPlan;\nuse crate::rules::results::{AuditResults, Finding, Severity};\n\npub struct TerminalOutput;\n\nimpl TerminalOutput {\n    pub fn new() -\u003e Self {\n        Self\n    }\n\n    fn format_header(\u0026self, repo_name: \u0026str, preset: \u0026str) -\u003e String {\n        format!(\n            r#\"\n{} v{}\n\n{} {}\n{} {}\n\"#,\n            \"repolens\".cyan().bold(),\n            env!(\"CARGO_PKG_VERSION\"),\n            \"Repository:\".dimmed(),\n            repo_name.white().bold(),\n            \"Preset:\".dimmed(),\n            preset.yellow()\n        )\n    }\n\n    fn format_findings(\u0026self, results: \u0026AuditResults) -\u003e String {\n        let mut output = String::new();\n\n        output.push_str(\u0026format!(\n            \"\\n{}\\n{}\\n\\n\",\n            \"‚îÅ\".repeat(50).dimmed(),\n            \"  AUDIT RESULTS\".bold()\n        ));\n\n        // Critical findings\n        let critical: Vec\u003c_\u003e = results.findings_by_severity(Severity::Critical).collect();\n        if !critical.is_empty() {\n            output.push_str(\u0026format!(\n                \"{} ({})\\\\n\",\n                \"‚ùå CRITICAL\".red().bold(),\n                critical.len()\n            ));\n            for finding in critical {\n                output.push_str(\u0026self.format_finding(finding));\n            }\n            output.push('\\n');\n        }\n\n        // Warning findings\n        let warnings: Vec\u003c_\u003e = results.findings_by_severity(Severity::Warning).collect();\n        if !warnings.is_empty() {\n            output.push_str(\u0026format!(\n                \"{} ({})\\\\n\",\n                \"‚ö†Ô∏è  WARNING\".yellow().bold(),\n                warnings.len()\n            ));\n            for finding in warnings {\n                output.push_str(\u0026self.format_finding(finding));\n            }\n            output.push('\\n');\n        }\n\n        // Info findings\n        let info: Vec\u003c_\u003e = results.findings_by_severity(Severity::Info).collect();\n        if !info.is_empty() {\n            output.push_str(\u0026format!(\"{} ({})\\\\n\", \"‚ÑπÔ∏è  INFO\".blue().bold(), info.len()));\n            for finding in info {\n                output.push_str(\u0026self.format_finding(finding));\n            }\n            output.push('\\n');\n        }\n\n        output\n    }\n\n    fn format_finding(\u0026self, finding: \u0026Finding) -\u003e String {\n        let mut output = format!(\n            \"  {} [{}] {}\\n\",\n            \"‚Ä¢\".dimmed(),\n            finding.rule_id.cyan(),\n            finding.message\n        );\n\n        if let Some(location) = \u0026finding.location {\n            output.push_str(\u0026format!(\"    {} {}\\n\", \"‚îî‚îÄ\".dimmed(), location.dimmed()));\n        }\n\n        output\n    }\n\n    fn format_actions(\u0026self, plan: \u0026ActionPlan) -\u003e String {\n        let mut output = String::new();\n\n        output.push_str(\u0026format!(\n            \"\\n{}\\n{}\\n\\n\",\n            \"‚îÅ\".repeat(50).dimmed(),\n            \"  PLANNED ACTIONS\".bold()\n        ));\n\n        if plan.is_empty() {\n            output.push_str(\u0026format!(\"  {}\\n\", \"No actions required.\".green()));\n            return output;\n        }\n\n        output.push_str(\"The following changes will be applied:\\n\\n\");\n\n        for action in plan.actions() {\n            output.push_str(\u0026format!(\n                \"  {} [{}] {}\\n\",\n                \"+\".green(),\n                action.category().cyan(),\n                action.description()\n            ));\n\n            for detail in action.details() {\n                output.push_str(\u0026format!(\"      {} {}\\n\", \"‚îî‚îÄ\".dimmed(), detail.dimmed()));\n            }\n        }\n\n        output\n    }\n\n    fn format_summary(\u0026self, results: \u0026AuditResults) -\u003e String {\n        let mut output = String::new();\n\n        output.push_str(\u0026format!(\n            \"\\n{}\\n{}\\n\\n\",\n            \"‚îÅ\".repeat(50).dimmed(),\n            \"  SUMMARY\".bold()\n        ));\n\n        let critical_count = results.count_by_severity(Severity::Critical);\n        let warning_count = results.count_by_severity(Severity::Warning);\n        let info_count = results.count_by_severity(Severity::Info);\n\n        output.push_str(\u0026format!(\n            \"Critical: {} ‚îÇ Warnings: {} ‚îÇ Info: {}\\n\",\n            critical_count.to_string().red().bold(),\n            warning_count.to_string().yellow().bold(),\n            info_count.to_string().blue().bold()\n        ));\n\n        if critical_count \u003e 0 {\n            output.push_str(\u0026format!(\n                \"\\n{} {} critical issue(s) must be fixed manually.\\n\",\n                \"‚ö†Ô∏è \".yellow(),\n                critical_count\n            ));\n        }\n\n        output.push_str(\u0026format!(\n            \"\\nRun '{}' to execute planned actions.\\n\",\n            \"repolens apply\".cyan()\n        ));\n\n        output\n    }\n}\n\nimpl Default for TerminalOutput {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl OutputRenderer for TerminalOutput {\n    fn render_plan(\n        \u0026self,\n        results: \u0026AuditResults,\n        plan: \u0026ActionPlan,\n    ) -\u003e Result\u003cString, RepoLensError\u003e {\n        let mut output = String::new();\n\n        output.push_str(\u0026self.format_header(\u0026results.repository_name, \u0026results.preset));\n        output.push_str(\u0026self.format_findings(results));\n        output.push_str(\u0026self.format_actions(plan));\n        output.push_str(\u0026self.format_summary(results));\n\n        Ok(output)\n    }\n}\n\nimpl ReportRenderer for TerminalOutput {\n    fn render_report(\u0026self, results: \u0026AuditResults) -\u003e Result\u003cString, RepoLensError\u003e {\n        let mut output = String::new();\n\n        output.push_str(\u0026self.format_header(\u0026results.repository_name, \u0026results.preset));\n        output.push_str(\u0026self.format_findings(results));\n        output.push_str(\u0026self.format_summary(results));\n\n        Ok(output)\n    }\n}\n","traces":[{"line":17,"address":[209240,208128,209234],"length":1,"stats":{"Line":0}},{"line":18,"address":[907406,907502,907304,907180,907086],"length":1,"stats":{"Line":0}},{"line":25,"address":[208204],"length":1,"stats":{"Line":0}},{"line":27,"address":[208333],"length":1,"stats":{"Line":0}},{"line":28,"address":[208442],"length":1,"stats":{"Line":0}},{"line":29,"address":[208559],"length":1,"stats":{"Line":0}},{"line":30,"address":[208667],"length":1,"stats":{"Line":0}},{"line":34,"address":[211332,213701,209264],"length":1,"stats":{"Line":0}},{"line":35,"address":[209319],"length":1,"stats":{"Line":0}},{"line":37,"address":[210149,209651,209476,209552],"length":1,"stats":{"Line":0}},{"line":39,"address":[209453,209533,209372],"length":1,"stats":{"Line":0}},{"line":40,"address":[209620],"length":1,"stats":{"Line":0}},{"line":44,"address":[210183],"length":1,"stats":{"Line":0}},{"line":45,"address":[210253,210315],"length":1,"stats":{"Line":0}},{"line":46,"address":[210421,210531,210868],"length":1,"stats":{"Line":0}},{"line":48,"address":[909137,909210],"length":1,"stats":{"Line":0}},{"line":49,"address":[210500],"length":1,"stats":{"Line":0}},{"line":51,"address":[210894,211092],"length":1,"stats":{"Line":0}},{"line":52,"address":[211218,211163],"length":1,"stats":{"Line":0}},{"line":54,"address":[910014],"length":1,"stats":{"Line":0}},{"line":58,"address":[210360,211354],"length":1,"stats":{"Line":0}},{"line":59,"address":[211433,211377],"length":1,"stats":{"Line":0}},{"line":60,"address":[211968,211539,211643],"length":1,"stats":{"Line":0}},{"line":62,"address":[211512,211439],"length":1,"stats":{"Line":0}},{"line":63,"address":[211618],"length":1,"stats":{"Line":0}},{"line":65,"address":[910810,911002],"length":1,"stats":{"Line":0}},{"line":66,"address":[911073,911128],"length":1,"stats":{"Line":0}},{"line":68,"address":[212292],"length":1,"stats":{"Line":0}},{"line":72,"address":[911252,910294],"length":1,"stats":{"Line":0}},{"line":73,"address":[212459,212515],"length":1,"stats":{"Line":0}},{"line":74,"address":[212521,212622],"length":1,"stats":{"Line":0}},{"line":75,"address":[213104,213296],"length":1,"stats":{"Line":0}},{"line":76,"address":[213422,213367],"length":1,"stats":{"Line":0}},{"line":78,"address":[912218],"length":1,"stats":{"Line":0}},{"line":81,"address":[212560],"length":1,"stats":{"Line":0}},{"line":84,"address":[213744,215071,215077],"length":1,"stats":{"Line":0}},{"line":85,"address":[213821,213935],"length":1,"stats":{"Line":0}},{"line":87,"address":[912598],"length":1,"stats":{"Line":0}},{"line":88,"address":[213889],"length":1,"stats":{"Line":0}},{"line":92,"address":[214325],"length":1,"stats":{"Line":0}},{"line":93,"address":[214383,214499],"length":1,"stats":{"Line":0}},{"line":96,"address":[214424],"length":1,"stats":{"Line":0}},{"line":99,"address":[215104,217824,218255],"length":1,"stats":{"Line":0}},{"line":100,"address":[913975],"length":1,"stats":{"Line":0}},{"line":102,"address":[914087,914262,914163,914760],"length":1,"stats":{"Line":0}},{"line":104,"address":[914144,913980,914064],"length":1,"stats":{"Line":0}},{"line":105,"address":[914231],"length":1,"stats":{"Line":0}},{"line":108,"address":[215978],"length":1,"stats":{"Line":0}},{"line":109,"address":[217830,216032],"length":1,"stats":{"Line":0}},{"line":110,"address":[218215],"length":1,"stats":{"Line":0}},{"line":113,"address":[914821],"length":1,"stats":{"Line":0}},{"line":115,"address":[216074],"length":1,"stats":{"Line":0}},{"line":116,"address":[216489,217012,216611,216352],"length":1,"stats":{"Line":0}},{"line":118,"address":[216262],"length":1,"stats":{"Line":0}},{"line":119,"address":[216431],"length":1,"stats":{"Line":0}},{"line":120,"address":[216568],"length":1,"stats":{"Line":0}},{"line":123,"address":[915862],"length":1,"stats":{"Line":0}},{"line":124,"address":[217213],"length":1,"stats":{"Line":0}},{"line":128,"address":[216301],"length":1,"stats":{"Line":0}},{"line":131,"address":[218272,221519,221525],"length":1,"stats":{"Line":0}},{"line":132,"address":[218327],"length":1,"stats":{"Line":0}},{"line":134,"address":[218614,218515,218439,219106],"length":1,"stats":{"Line":0}},{"line":136,"address":[218332,218496,218416],"length":1,"stats":{"Line":0}},{"line":137,"address":[218583],"length":1,"stats":{"Line":0}},{"line":140,"address":[917956],"length":1,"stats":{"Line":0}},{"line":141,"address":[918005],"length":1,"stats":{"Line":0}},{"line":142,"address":[918054],"length":1,"stats":{"Line":0}},{"line":144,"address":[219554,219651,219431,220556,219331,219871,219774],"length":1,"stats":{"Line":0}},{"line":146,"address":[219279,219385],"length":1,"stats":{"Line":0}},{"line":147,"address":[219502,219605],"length":1,"stats":{"Line":0}},{"line":148,"address":[918538,918641],"length":1,"stats":{"Line":0}},{"line":151,"address":[919398],"length":1,"stats":{"Line":0}},{"line":152,"address":[220658,221054],"length":1,"stats":{"Line":0}},{"line":154,"address":[220627],"length":1,"stats":{"Line":0}},{"line":159,"address":[920250,919899],"length":1,"stats":{"Line":0}},{"line":161,"address":[220593],"length":1,"stats":{"Line":0}},{"line":164,"address":[221476],"length":1,"stats":{"Line":0}},{"line":169,"address":[221552],"length":1,"stats":{"Line":0}},{"line":170,"address":[920369],"length":1,"stats":{"Line":0}},{"line":175,"address":[222458,222464,221568],"length":1,"stats":{"Line":0}},{"line":180,"address":[221638],"length":1,"stats":{"Line":0}},{"line":182,"address":[221651,221752],"length":1,"stats":{"Line":0}},{"line":183,"address":[221947],"length":1,"stats":{"Line":0}},{"line":184,"address":[222085],"length":1,"stats":{"Line":0}},{"line":185,"address":[921042],"length":1,"stats":{"Line":0}},{"line":187,"address":[222359],"length":1,"stats":{"Line":0}},{"line":192,"address":[223184,223190,222480],"length":1,"stats":{"Line":0}},{"line":193,"address":[222531],"length":1,"stats":{"Line":0}},{"line":195,"address":[222627,222541],"length":1,"stats":{"Line":0}},{"line":196,"address":[222819],"length":1,"stats":{"Line":0}},{"line":197,"address":[222957],"length":1,"stats":{"Line":0}},{"line":199,"address":[223085],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":92},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","config","loader.rs"],"content":"//! Configuration loader\n\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\nuse crate::error::{ConfigError, RepoLensError};\n\nuse super::presets::Preset;\nuse super::{ActionsConfig, CustomRulesConfig, RuleConfig, SecretsConfig, TemplatesConfig, UrlConfig};\n\nconst CONFIG_FILENAME: \u0026str = \".repolens.toml\";\n\n/// Main configuration structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Config {\n    /// Preset name (opensource, enterprise, strict)\n    #[serde(default = \"default_preset\")]\n    pub preset: String,\n\n    /// Rule overrides\n    #[serde(default)]\n    pub rules: HashMap\u003cString, RuleConfig\u003e,\n\n    /// Secrets detection configuration\n    #[serde(default)]\n    #[serde(rename = \"rules.secrets\")]\n    pub secrets: SecretsConfig,\n\n    /// URL detection configuration\n    #[serde(default)]\n    #[serde(rename = \"rules.urls\")]\n    pub urls: UrlConfig,\n\n    /// Actions configuration\n    #[serde(default)]\n    pub actions: ActionsConfig,\n\n    /// Template configuration\n    #[serde(default)]\n    pub templates: TemplatesConfig,\n\n    /// Custom rules configuration\n    #[serde(default)]\n    #[serde(rename = \"rules.custom\")]\n    pub custom_rules: CustomRulesConfig,\n}\n\nfn default_preset() -\u003e String {\n    \"opensource\".to_string()\n}\n\nimpl Default for Config {\n    fn default() -\u003e Self {\n        Self {\n            preset: \"opensource\".to_string(),\n            rules: HashMap::new(),\n            secrets: SecretsConfig::default(),\n            urls: UrlConfig::default(),\n            actions: ActionsConfig::default(),\n            templates: TemplatesConfig::default(),\n            custom_rules: CustomRulesConfig::default(),\n        }\n    }\n}\n\nimpl Config {\n    /// Load configuration from file or return default\n    pub fn load_or_default() -\u003e Result\u003cSelf, RepoLensError\u003e {\n        let config_path = Path::new(CONFIG_FILENAME);\n\n        if config_path.exists() {\n            Self::load_from_file(config_path)\n        } else {\n            Ok(Self::default())\n        }\n    }\n\n    /// Load configuration from a specific file\n    pub fn load_from_file(path: \u0026Path) -\u003e Result\u003cSelf, RepoLensError\u003e {\n        let content = fs::read_to_string(path).map_err(|e| {\n            RepoLensError::Config(ConfigError::FileRead {\n                path: path.display().to_string(),\n                source: e,\n            })\n        })?;\n\n        toml::from_str(\u0026content).map_err(Into::into)\n    }\n\n    /// Create a new configuration from a preset\n    pub fn from_preset(preset: Preset) -\u003e Self {\n        let mut config = Self {\n            preset: preset.name().to_string(),\n            ..Default::default()\n        };\n\n        // Apply preset-specific defaults\n        match preset {\n            Preset::OpenSource =\u003e {\n                config.actions.license.enabled = true;\n                config.actions.contributing = true;\n                config.actions.code_of_conduct = true;\n                config.actions.security_policy = true;\n                config.actions.github_settings.discussions = true;\n            }\n            Preset::Enterprise =\u003e {\n                config.actions.license.enabled = false;\n                config.actions.contributing = false;\n                config.actions.code_of_conduct = false;\n                config.actions.security_policy = true;\n                config.actions.branch_protection.required_approvals = 2;\n                config.actions.branch_protection.require_signed_commits = true;\n                config.actions.github_settings.discussions = false;\n            }\n            Preset::Strict =\u003e {\n                config.actions.license.enabled = true;\n                config.actions.contributing = true;\n                config.actions.code_of_conduct = true;\n                config.actions.security_policy = true;\n                config.actions.branch_protection.required_approvals = 2;\n                config.actions.branch_protection.require_signed_commits = true;\n                config.actions.github_settings.discussions = true;\n            }\n        }\n\n        config\n    }\n\n    /// Serialize configuration to TOML\n    pub fn to_toml(\u0026self) -\u003e Result\u003cString, RepoLensError\u003e {\n        toml::to_string_pretty(self).map_err(Into::into)\n    }\n\n    /// Check if a rule is enabled\n    pub fn is_rule_enabled(\u0026self, rule_id: \u0026str) -\u003e bool {\n        self.rules.get(rule_id).map(|r| r.enabled).unwrap_or(true)\n    }\n\n    /// Get severity override for a rule\n    #[allow(dead_code)]\n    pub fn get_rule_severity(\u0026self, rule_id: \u0026str) -\u003e Option\u003c\u0026str\u003e {\n        self.rules.get(rule_id).and_then(|r| r.severity.as_deref())\n    }\n\n    /// Check if a file should be ignored for secrets scanning\n    pub fn should_ignore_file(\u0026self, file_path: \u0026str) -\u003e bool {\n        self.secrets\n            .ignore_files\n            .iter()\n            .any(|pattern| glob_match(pattern, file_path))\n    }\n\n    /// Check if a pattern should be ignored for secrets scanning\n    pub fn should_ignore_pattern(\u0026self, path: \u0026str) -\u003e bool {\n        self.secrets\n            .ignore_patterns\n            .iter()\n            .any(|pattern| glob_match(pattern, path))\n    }\n\n    /// Check if a URL is allowed (for enterprise mode)\n    #[allow(dead_code)]\n    pub fn is_url_allowed(\u0026self, url: \u0026str) -\u003e bool {\n        if self.urls.allowed_internal.is_empty() {\n            return false;\n        }\n\n        self.urls\n            .allowed_internal\n            .iter()\n            .any(|pattern| glob_match(pattern, url))\n    }\n}\n\n/// Simple glob matching (supports * and **)\npub fn glob_match(pattern: \u0026str, text: \u0026str) -\u003e bool {\n    if pattern.contains(\"**\") {\n        return glob_match_double_star(pattern, text);\n    }\n\n    if pattern.contains('*') {\n        return glob_match_single_star(pattern, text);\n    }\n\n    text == pattern\n}\n\n/// Match pattern with double star (**)\nfn glob_match_double_star(pattern: \u0026str, text: \u0026str) -\u003e bool {\n    let parts: Vec\u003c\u0026str\u003e = pattern.split(\"**\").collect();\n\n    // Handle patterns like \"**/test/**\" which split into ['', '/test/', '']\n    if parts.len() == 3 \u0026\u0026 parts[0].is_empty() \u0026\u0026 parts[2].is_empty() {\n        // Pattern is **something**, check if text contains something\n        let middle = parts[1].trim_matches('/');\n        return text.contains(\u0026format!(\"/{}\", middle)) || text.starts_with(middle);\n    }\n\n    if parts.len() != 2 {\n        return false;\n    }\n\n    let prefix = parts[0].trim_end_matches('/');\n    let suffix_raw = parts[1];\n    let suffix = suffix_raw.trim_start_matches('/');\n\n    if !prefix.is_empty() \u0026\u0026 !text.starts_with(prefix) {\n        return false;\n    }\n\n    if suffix.is_empty() {\n        // Pattern like \"**\" or \"prefix/**\" matches everything\n        return true;\n    }\n\n    // Handle patterns like *.test.ts\n    if suffix.starts_with('*') {\n        let suffix_pattern = suffix.trim_start_matches('*');\n        return text.ends_with(suffix_pattern);\n    }\n\n    // For patterns like \"**/test/**\" or \"**/test\", check if suffix appears anywhere\n    if prefix.is_empty() {\n        // Pattern starts with **, check if suffix appears anywhere\n        // For \"**/test/**\", suffix_raw is \"/test/\", suffix is \"test/\"\n        // We need to check if the path contains \"/test/\" anywhere\n        // Since suffix_raw had a leading slash, check for \"/suffix\" pattern\n        if suffix_raw.starts_with('/') {\n            // Check for \"/suffix\" in the path (e.g., \"/test/\" in \"src/test/file.ts\")\n            // suffix is \"test/\" so we check for \"/test/\"\n            // Also handle case where path starts with \"test/\"\n            let pattern_to_find = format!(\"/{}\", suffix);\n            if text.contains(\u0026pattern_to_find) {\n                return true;\n            }\n            // Also check if text starts with suffix (for paths like \"test/file.ts\")\n            if text.starts_with(suffix) {\n                return true;\n            }\n            return false;\n        }\n        // No leading slash in original, check for suffix anywhere\n        return text.contains(suffix);\n    }\n\n    // Pattern has both prefix and suffix\n    // Check if text starts with prefix and contains suffix after prefix\n    if let Some(after_prefix) = text.strip_prefix(prefix) {\n        return after_prefix.contains(suffix) || after_prefix.ends_with(suffix);\n    }\n\n    // Fallback: check ends or contains\n    text.ends_with(suffix) || text.contains(suffix)\n}\n\n/// Match pattern with single star (*)\nfn glob_match_single_star(pattern: \u0026str, text: \u0026str) -\u003e bool {\n    let parts: Vec\u003c\u0026str\u003e = pattern.split('*').collect();\n    let mut pos = 0;\n\n    for (i, part) in parts.iter().enumerate() {\n        if part.is_empty() {\n            continue;\n        }\n\n        if let Some(found_pos) = text[pos..].find(part) {\n            if i == 0 \u0026\u0026 found_pos != 0 {\n                return false;\n            }\n            pos += found_pos + part.len();\n        } else {\n            return false;\n        }\n    }\n\n    if let Some(last_part) = parts.last() {\n        if !last_part.is_empty() {\n            return text.ends_with(last_part);\n        }\n    }\n\n    true\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_glob_match() {\n        assert!(glob_match(\"*.ts\", \"file.ts\"));\n        assert!(glob_match(\"*.ts\", \"path/to/file.ts\"));\n        assert!(!glob_match(\"*.ts\", \"file.js\"));\n\n        // For \"**/test/**\", we check if path contains \"/test/\" anywhere\n        // For \"**/test/**\", check if path contains \"/test/\" anywhere\n        // \"src/test/file.ts\" contains \"/test/\" so it should match\n        assert!(\n            glob_match(\"**/test/**\", \"src/test/file.ts\"),\n            \"Pattern **/test/** should match src/test/file.ts\"\n        );\n        assert!(glob_match(\"**/test/**\", \"test/file.ts\"));\n        assert!(glob_match(\"**/*.test.ts\", \"src/file.test.ts\"));\n    }\n\n    #[test]\n    fn test_default_config() {\n        let config = Config::default();\n        assert_eq!(config.preset, \"opensource\");\n        assert!(config.actions.gitignore);\n    }\n\n    #[test]\n    fn test_from_preset() {\n        let config = Config::from_preset(Preset::Enterprise);\n        assert_eq!(config.preset, \"enterprise\");\n        assert!(!config.actions.license.enabled);\n        assert_eq!(config.actions.branch_protection.required_approvals, 2);\n    }\n\n    #[test]\n    fn test_custom_rules_config_parsing() {\n        let toml_content = r#\"\npreset = \"opensource\"\n\n[\"rules.custom\".\"no-todo\"]\npattern = \"TODO\"\nseverity = \"warning\"\nfiles = [\"**/*.rs\"]\nmessage = \"TODO comment found\"\n\"#;\n        let config: Config = toml::from_str(toml_content).unwrap();\n        assert!(config.custom_rules.rules.contains_key(\"no-todo\"));\n        let rule = config.custom_rules.rules.get(\"no-todo\").unwrap();\n        assert_eq!(rule.pattern, \"TODO\");\n        assert_eq!(rule.severity, \"warning\");\n    }\n}\n","traces":[{"line":50,"address":[248704],"length":1,"stats":{"Line":0}},{"line":51,"address":[683512],"length":1,"stats":{"Line":0}},{"line":55,"address":[684096,683536,684090],"length":1,"stats":{"Line":10}},{"line":57,"address":[683552],"length":1,"stats":{"Line":2}},{"line":58,"address":[683583],"length":1,"stats":{"Line":16}},{"line":59,"address":[683636],"length":1,"stats":{"Line":2}},{"line":60,"address":[683685],"length":1,"stats":{"Line":16}},{"line":61,"address":[683734],"length":1,"stats":{"Line":2}},{"line":62,"address":[683786],"length":1,"stats":{"Line":9}},{"line":63,"address":[683838],"length":1,"stats":{"Line":9}},{"line":70,"address":[249312],"length":1,"stats":{"Line":0}},{"line":71,"address":[684128],"length":1,"stats":{"Line":0}},{"line":73,"address":[684216,684178],"length":1,"stats":{"Line":0}},{"line":74,"address":[684232],"length":1,"stats":{"Line":0}},{"line":76,"address":[684187],"length":1,"stats":{"Line":0}},{"line":81,"address":[684256,684612,684618],"length":1,"stats":{"Line":0}},{"line":82,"address":[550759,550753,550512],"length":1,"stats":{"Line":0}},{"line":83,"address":[550667],"length":1,"stats":{"Line":0}},{"line":84,"address":[550622,550544],"length":1,"stats":{"Line":0}},{"line":85,"address":[316998],"length":1,"stats":{"Line":0}},{"line":89,"address":[684490,684561],"length":1,"stats":{"Line":0}},{"line":93,"address":[684640,685485,685479],"length":1,"stats":{"Line":2}},{"line":95,"address":[684669],"length":1,"stats":{"Line":2}},{"line":100,"address":[685252],"length":1,"stats":{"Line":2}},{"line":101,"address":[685324],"length":1,"stats":{"Line":0}},{"line":102,"address":[250484],"length":1,"stats":{"Line":0}},{"line":103,"address":[685292],"length":1,"stats":{"Line":0}},{"line":104,"address":[685300],"length":1,"stats":{"Line":0}},{"line":105,"address":[685308],"length":1,"stats":{"Line":0}},{"line":106,"address":[685316],"length":1,"stats":{"Line":0}},{"line":108,"address":[685385],"length":1,"stats":{"Line":2}},{"line":109,"address":[250526],"length":1,"stats":{"Line":2}},{"line":110,"address":[685334],"length":1,"stats":{"Line":2}},{"line":111,"address":[685342],"length":1,"stats":{"Line":2}},{"line":112,"address":[685350],"length":1,"stats":{"Line":2}},{"line":113,"address":[685358],"length":1,"stats":{"Line":2}},{"line":114,"address":[685369],"length":1,"stats":{"Line":2}},{"line":115,"address":[685377],"length":1,"stats":{"Line":2}},{"line":118,"address":[685387],"length":1,"stats":{"Line":0}},{"line":119,"address":[685395],"length":1,"stats":{"Line":0}},{"line":120,"address":[685403],"length":1,"stats":{"Line":0}},{"line":121,"address":[685411],"length":1,"stats":{"Line":0}},{"line":122,"address":[685419],"length":1,"stats":{"Line":0}},{"line":123,"address":[685430],"length":1,"stats":{"Line":0}},{"line":124,"address":[685438],"length":1,"stats":{"Line":0}},{"line":128,"address":[685451],"length":1,"stats":{"Line":2}},{"line":132,"address":[685504],"length":1,"stats":{"Line":0}},{"line":133,"address":[685522],"length":1,"stats":{"Line":0}},{"line":137,"address":[685568],"length":1,"stats":{"Line":5}},{"line":138,"address":[550789,550784],"length":1,"stats":{"Line":3}},{"line":143,"address":[685632],"length":1,"stats":{"Line":0}},{"line":144,"address":[550800,550809],"length":1,"stats":{"Line":0}},{"line":148,"address":[685680],"length":1,"stats":{"Line":2}},{"line":149,"address":[685708],"length":1,"stats":{"Line":2}},{"line":152,"address":[550864,550832],"length":1,"stats":{"Line":4}},{"line":156,"address":[250976],"length":1,"stats":{"Line":2}},{"line":157,"address":[685804],"length":1,"stats":{"Line":2}},{"line":160,"address":[550912,550944],"length":1,"stats":{"Line":0}},{"line":165,"address":[685872],"length":1,"stats":{"Line":0}},{"line":166,"address":[685905],"length":1,"stats":{"Line":0}},{"line":167,"address":[251189],"length":1,"stats":{"Line":0}},{"line":170,"address":[251123],"length":1,"stats":{"Line":0}},{"line":173,"address":[551024,550992],"length":1,"stats":{"Line":0}},{"line":178,"address":[686016],"length":1,"stats":{"Line":2}},{"line":179,"address":[251239],"length":1,"stats":{"Line":2}},{"line":180,"address":[251296],"length":1,"stats":{"Line":2}},{"line":183,"address":[686070],"length":1,"stats":{"Line":2}},{"line":184,"address":[251350],"length":1,"stats":{"Line":2}},{"line":187,"address":[686128],"length":1,"stats":{"Line":2}},{"line":191,"address":[687067,686192,688529],"length":1,"stats":{"Line":2}},{"line":192,"address":[251456],"length":1,"stats":{"Line":2}},{"line":195,"address":[686398,686327,686480],"length":1,"stats":{"Line":6}},{"line":197,"address":[251802],"length":1,"stats":{"Line":2}},{"line":198,"address":[251916,252261],"length":1,"stats":{"Line":4}},{"line":201,"address":[252285,251646],"length":1,"stats":{"Line":4}},{"line":202,"address":[687125],"length":1,"stats":{"Line":0}},{"line":205,"address":[252291,252347],"length":1,"stats":{"Line":4}},{"line":206,"address":[252434],"length":1,"stats":{"Line":2}},{"line":207,"address":[252519],"length":1,"stats":{"Line":2}},{"line":209,"address":[252572,252665],"length":1,"stats":{"Line":2}},{"line":210,"address":[252671],"length":1,"stats":{"Line":0}},{"line":213,"address":[687430,687484],"length":1,"stats":{"Line":4}},{"line":215,"address":[687526],"length":1,"stats":{"Line":0}},{"line":219,"address":[252747,252694],"length":1,"stats":{"Line":4}},{"line":220,"address":[252774,253684],"length":1,"stats":{"Line":4}},{"line":221,"address":[688496],"length":1,"stats":{"Line":2}},{"line":225,"address":[687615,687559],"length":1,"stats":{"Line":0}},{"line":230,"address":[252882,253279],"length":1,"stats":{"Line":0}},{"line":234,"address":[688128,688173],"length":1,"stats":{"Line":0}},{"line":235,"address":[253501,253560],"length":1,"stats":{"Line":0}},{"line":236,"address":[688409],"length":1,"stats":{"Line":0}},{"line":239,"address":[688423,688378],"length":1,"stats":{"Line":0}},{"line":245,"address":[688159,688097],"length":1,"stats":{"Line":0}},{"line":250,"address":[687711,687647],"length":1,"stats":{"Line":0}},{"line":251,"address":[687800,687882],"length":1,"stats":{"Line":0}},{"line":255,"address":[687964,687847],"length":1,"stats":{"Line":0}},{"line":259,"address":[688544,689661,689667],"length":1,"stats":{"Line":2}},{"line":260,"address":[253824],"length":1,"stats":{"Line":2}},{"line":261,"address":[688679],"length":1,"stats":{"Line":2}},{"line":263,"address":[688691,689638,688778],"length":1,"stats":{"Line":6}},{"line":264,"address":[689330,689055],"length":1,"stats":{"Line":4}},{"line":268,"address":[689356],"length":1,"stats":{"Line":2}},{"line":269,"address":[689490,689516],"length":1,"stats":{"Line":2}},{"line":270,"address":[254762],"length":1,"stats":{"Line":0}},{"line":272,"address":[689569,689527,689643],"length":1,"stats":{"Line":4}},{"line":274,"address":[689498],"length":1,"stats":{"Line":2}},{"line":278,"address":[689079],"length":1,"stats":{"Line":2}},{"line":279,"address":[689241,689195],"length":1,"stats":{"Line":4}},{"line":280,"address":[689268],"length":1,"stats":{"Line":2}},{"line":284,"address":[689213],"length":1,"stats":{"Line":0}}],"covered":59,"coverable":110},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","config","mod.rs"],"content":"//! Configuration module\n\npub mod loader;\npub mod presets;\n\npub use loader::Config;\npub use presets::Preset;\n\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n/// Rule configuration\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct RuleConfig {\n    /// Whether the rule is enabled\n    #[serde(default = \"default_true\")]\n    pub enabled: bool,\n\n    /// Severity override (critical, warning, info)\n    pub severity: Option\u003cString\u003e,\n}\n\nfn default_true() -\u003e bool {\n    true\n}\n\n/// Secrets configuration\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct SecretsConfig {\n    /// Patterns to ignore when scanning for secrets\n    #[serde(default)]\n    pub ignore_patterns: Vec\u003cString\u003e,\n\n    /// Files to ignore when scanning for secrets\n    #[serde(default)]\n    pub ignore_files: Vec\u003cString\u003e,\n\n    /// Custom secret patterns to detect\n    #[serde(default)]\n    pub custom_patterns: Vec\u003cString\u003e,\n}\n\n/// URL configuration\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct UrlConfig {\n    /// Allowed internal URLs (for enterprise mode)\n    #[serde(default)]\n    pub allowed_internal: Vec\u003cString\u003e,\n}\n\n/// Actions configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ActionsConfig {\n    /// Whether to update .gitignore\n    #[serde(default = \"default_true\")]\n    pub gitignore: bool,\n\n    /// License configuration\n    #[serde(default)]\n    pub license: LicenseConfig,\n\n    /// Whether to create CONTRIBUTING.md\n    #[serde(default = \"default_true\")]\n    pub contributing: bool,\n\n    /// Whether to create CODE_OF_CONDUCT.md\n    #[serde(default = \"default_true\")]\n    pub code_of_conduct: bool,\n\n    /// Whether to create SECURITY.md\n    #[serde(default = \"default_true\")]\n    pub security_policy: bool,\n\n    /// Branch protection configuration\n    #[serde(default)]\n    pub branch_protection: BranchProtectionConfig,\n\n    /// GitHub settings configuration\n    #[serde(default)]\n    pub github_settings: GitHubSettingsConfig,\n}\n\nimpl Default for ActionsConfig {\n    fn default() -\u003e Self {\n        Self {\n            gitignore: true,\n            license: LicenseConfig::default(),\n            contributing: true,\n            code_of_conduct: true,\n            security_policy: true,\n            branch_protection: BranchProtectionConfig::default(),\n            github_settings: GitHubSettingsConfig::default(),\n        }\n    }\n}\n\n/// License configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LicenseConfig {\n    /// Whether to create LICENSE file\n    #[serde(default = \"default_true\")]\n    pub enabled: bool,\n\n    /// License type (MIT, Apache-2.0, GPL-3.0, etc.)\n    #[serde(default = \"default_license_type\")]\n    pub license_type: String,\n\n    /// Author name for license\n    #[serde(default)]\n    pub author: Option\u003cString\u003e,\n\n    /// Year for license (defaults to current year)\n    #[serde(default)]\n    pub year: Option\u003cString\u003e,\n}\n\nimpl Default for LicenseConfig {\n    fn default() -\u003e Self {\n        Self {\n            enabled: true,\n            license_type: \"MIT\".to_string(),\n            author: None,\n            year: None,\n        }\n    }\n}\n\nfn default_license_type() -\u003e String {\n    \"MIT\".to_string()\n}\n\n/// Branch protection configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BranchProtectionConfig {\n    /// Whether to enable branch protection\n    #[serde(default = \"default_true\")]\n    pub enabled: bool,\n\n    /// Branch to protect (defaults to main)\n    #[serde(default = \"default_branch\")]\n    pub branch: String,\n\n    /// Number of required approvals\n    #[serde(default = \"default_approvals\")]\n    pub required_approvals: u32,\n\n    /// Whether to require status checks\n    #[serde(default = \"default_true\")]\n    pub require_status_checks: bool,\n\n    /// Whether to block force pushes\n    #[serde(default = \"default_true\")]\n    pub block_force_push: bool,\n\n    /// Whether to require signed commits\n    #[serde(default)]\n    pub require_signed_commits: bool,\n}\n\nimpl Default for BranchProtectionConfig {\n    fn default() -\u003e Self {\n        Self {\n            enabled: true,\n            branch: \"main\".to_string(),\n            required_approvals: 1,\n            require_status_checks: true,\n            block_force_push: true,\n            require_signed_commits: false,\n        }\n    }\n}\n\nfn default_branch() -\u003e String {\n    \"main\".to_string()\n}\n\nfn default_approvals() -\u003e u32 {\n    1\n}\n\n/// GitHub settings configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GitHubSettingsConfig {\n    /// Whether to enable GitHub Discussions\n    #[serde(default = \"default_true\")]\n    pub discussions: bool,\n\n    /// Whether to enable GitHub Issues\n    #[serde(default = \"default_true\")]\n    pub issues: bool,\n\n    /// Whether to enable GitHub Wiki\n    #[serde(default)]\n    pub wiki: bool,\n\n    /// Whether to enable vulnerability alerts\n    #[serde(default = \"default_true\")]\n    pub vulnerability_alerts: bool,\n\n    /// Whether to enable automatic security fixes\n    #[serde(default = \"default_true\")]\n    pub automated_security_fixes: bool,\n}\n\nimpl Default for GitHubSettingsConfig {\n    fn default() -\u003e Self {\n        Self {\n            discussions: true,\n            issues: true,\n            wiki: false,\n            vulnerability_alerts: true,\n            automated_security_fixes: true,\n        }\n    }\n}\n\n/// Template configuration\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct TemplatesConfig {\n    /// Author name for templates\n    pub license_author: Option\u003cString\u003e,\n\n    /// Year for templates\n    pub license_year: Option\u003cString\u003e,\n\n    /// Project name override\n    pub project_name: Option\u003cString\u003e,\n\n    /// Project description\n    pub project_description: Option\u003cString\u003e,\n}\n\n/// Custom rule configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CustomRule {\n    /// Regex pattern to match\n    pub pattern: String,\n\n    /// Severity level (critical, warning, info)\n    #[serde(default = \"default_custom_severity\")]\n    pub severity: String,\n\n    /// File glob patterns to include\n    #[serde(default)]\n    pub files: Vec\u003cString\u003e,\n\n    /// Custom message for the finding\n    pub message: Option\u003cString\u003e,\n\n    /// Detailed description\n    pub description: Option\u003cString\u003e,\n\n    /// Suggested remediation\n    pub remediation: Option\u003cString\u003e,\n\n    /// If true, fail when pattern is NOT found (inverted matching)\n    #[serde(default)]\n    pub invert: bool,\n}\n\nfn default_custom_severity() -\u003e String {\n    \"warning\".to_string()\n}\n\n/// Custom rules configuration container\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct CustomRulesConfig {\n    /// Map of rule ID to rule configuration\n    #[serde(flatten)]\n    pub rules: HashMap\u003cString, CustomRule\u003e,\n}\n","traces":[{"line":84,"address":[582046,582052,581760],"length":1,"stats":{"Line":2}},{"line":87,"address":[1496230],"length":1,"stats":{"Line":2}},{"line":91,"address":[1496240],"length":1,"stats":{"Line":11}},{"line":92,"address":[1496284,1496338],"length":1,"stats":{"Line":20}},{"line":118,"address":[1496528],"length":1,"stats":{"Line":10}},{"line":121,"address":[1496541],"length":1,"stats":{"Line":9}},{"line":128,"address":[1496704],"length":1,"stats":{"Line":0}},{"line":129,"address":[1496712],"length":1,"stats":{"Line":0}},{"line":161,"address":[1496736],"length":1,"stats":{"Line":9}},{"line":164,"address":[1496749],"length":1,"stats":{"Line":11}},{"line":173,"address":[1496848],"length":1,"stats":{"Line":0}},{"line":174,"address":[1496856],"length":1,"stats":{"Line":0}},{"line":261,"address":[1496944],"length":1,"stats":{"Line":0}},{"line":262,"address":[1496952],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":14},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","config","presets","mod.rs"],"content":"//! Preset configurations for different use cases\n\n/// Available presets\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum Preset {\n    /// Open source project - prepare for public release\n    OpenSource,\n    /// Enterprise project - internal company standards\n    Enterprise,\n    /// Strict mode - maximum security and compliance\n    Strict,\n}\n\nimpl Preset {\n    /// Get preset from name\n    pub fn from_name(name: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match name.to_lowercase().as_str() {\n            \"opensource\" | \"open-source\" | \"oss\" =\u003e Some(Self::OpenSource),\n            \"enterprise\" | \"ent\" | \"internal\" =\u003e Some(Self::Enterprise),\n            \"strict\" | \"secure\" | \"compliance\" =\u003e Some(Self::Strict),\n            _ =\u003e None,\n        }\n    }\n\n    /// Get the name of the preset\n    pub fn name(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::OpenSource =\u003e \"opensource\",\n            Self::Enterprise =\u003e \"enterprise\",\n            Self::Strict =\u003e \"strict\",\n        }\n    }\n\n    /// Get a description of the preset\n    #[allow(dead_code)]\n    pub fn description(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::OpenSource =\u003e \"Prepare repository for public open source release\",\n            Self::Enterprise =\u003e \"Apply internal company standards and policies\",\n            Self::Strict =\u003e \"Maximum security and compliance checks\",\n        }\n    }\n\n    /// Get the rules that should be enabled for this preset\n    #[allow(dead_code)]\n    pub fn enabled_rules(\u0026self) -\u003e Vec\u003c\u0026'static str\u003e {\n        match self {\n            Self::OpenSource =\u003e vec![\n                \"secrets/hardcoded\",\n                \"secrets/files\",\n                \"secrets/env\",\n                \"docs/readme\",\n                \"docs/license\",\n                \"docs/contributing\",\n                \"docs/code-of-conduct\",\n                \"docs/security\",\n                \"files/sensitive\",\n                \"files/large\",\n                \"files/gitignore\",\n                \"security/dependencies\",\n                \"workflows/secrets\",\n                \"workflows/permissions\",\n                \"github/branch-protection\",\n                \"github/settings\",\n            ],\n            Self::Enterprise =\u003e vec![\n                \"secrets/hardcoded\",\n                \"secrets/files\",\n                \"secrets/env\",\n                \"docs/readme\",\n                \"docs/security\",\n                \"files/sensitive\",\n                \"files/large\",\n                \"files/gitignore\",\n                \"security/dependencies\",\n                \"security/codeowners\",\n                \"security/signed-commits\",\n                \"workflows/secrets\",\n                \"workflows/permissions\",\n                \"github/branch-protection\",\n                \"github/settings\",\n            ],\n            Self::Strict =\u003e vec![\n                \"secrets/hardcoded\",\n                \"secrets/files\",\n                \"secrets/env\",\n                \"secrets/history\",\n                \"docs/readme\",\n                \"docs/license\",\n                \"docs/contributing\",\n                \"docs/code-of-conduct\",\n                \"docs/security\",\n                \"docs/changelog\",\n                \"files/sensitive\",\n                \"files/large\",\n                \"files/gitignore\",\n                \"files/editorconfig\",\n                \"security/dependencies\",\n                \"security/codeowners\",\n                \"security/signed-commits\",\n                \"workflows/secrets\",\n                \"workflows/permissions\",\n                \"workflows/pinned-actions\",\n                \"github/branch-protection\",\n                \"github/settings\",\n                \"quality/tests\",\n                \"quality/linting\",\n            ],\n        }\n    }\n\n    /// Get rules with critical severity for this preset\n    #[allow(dead_code)]\n    pub fn critical_rules(\u0026self) -\u003e Vec\u003c\u0026'static str\u003e {\n        match self {\n            Self::OpenSource =\u003e vec![\"secrets/hardcoded\", \"secrets/files\", \"docs/license\"],\n            Self::Enterprise =\u003e vec![\"secrets/hardcoded\", \"secrets/files\", \"security/codeowners\"],\n            Self::Strict =\u003e vec![\n                \"secrets/hardcoded\",\n                \"secrets/files\",\n                \"secrets/history\",\n                \"docs/license\",\n                \"security/codeowners\",\n                \"security/signed-commits\",\n            ],\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_preset_from_name() {\n        assert_eq!(Preset::from_name(\"opensource\").unwrap(), Preset::OpenSource);\n        assert_eq!(Preset::from_name(\"oss\").unwrap(), Preset::OpenSource);\n        assert_eq!(Preset::from_name(\"enterprise\").unwrap(), Preset::Enterprise);\n        assert_eq!(Preset::from_name(\"strict\").unwrap(), Preset::Strict);\n        assert!(Preset::from_name(\"invalid\").is_none());\n    }\n\n    #[test]\n    fn test_preset_name() {\n        assert_eq!(Preset::OpenSource.name(), \"opensource\");\n        assert_eq!(Preset::Enterprise.name(), \"enterprise\");\n        assert_eq!(Preset::Strict.name(), \"strict\");\n    }\n}\n","traces":[{"line":16,"address":[532608,533198,533192],"length":1,"stats":{"Line":2}},{"line":17,"address":[532631,532720],"length":1,"stats":{"Line":4}},{"line":18,"address":[532736],"length":1,"stats":{"Line":2}},{"line":19,"address":[532883],"length":1,"stats":{"Line":2}},{"line":20,"address":[693846],"length":1,"stats":{"Line":2}},{"line":21,"address":[533164],"length":1,"stats":{"Line":2}},{"line":26,"address":[533216],"length":1,"stats":{"Line":2}},{"line":27,"address":[533221],"length":1,"stats":{"Line":2}},{"line":28,"address":[533253],"length":1,"stats":{"Line":2}},{"line":29,"address":[533276],"length":1,"stats":{"Line":2}},{"line":30,"address":[533299],"length":1,"stats":{"Line":2}},{"line":36,"address":[533344],"length":1,"stats":{"Line":0}},{"line":37,"address":[533349],"length":1,"stats":{"Line":0}},{"line":38,"address":[533381],"length":1,"stats":{"Line":0}},{"line":39,"address":[694220],"length":1,"stats":{"Line":0}},{"line":40,"address":[533427],"length":1,"stats":{"Line":0}},{"line":46,"address":[533472],"length":1,"stats":{"Line":0}},{"line":47,"address":[533491],"length":1,"stats":{"Line":0}},{"line":48,"address":[694339,694453],"length":1,"stats":{"Line":0}},{"line":66,"address":[533555,534082],"length":1,"stats":{"Line":0}},{"line":83,"address":[533594,534494],"length":1,"stats":{"Line":0}},{"line":114,"address":[535136],"length":1,"stats":{"Line":0}},{"line":115,"address":[535155],"length":1,"stats":{"Line":0}},{"line":116,"address":[535187,535301],"length":1,"stats":{"Line":0}},{"line":117,"address":[535219,535448],"length":1,"stats":{"Line":0}},{"line":118,"address":[535587,535258],"length":1,"stats":{"Line":0}}],"covered":11,"coverable":26},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","error.rs"],"content":"//! Error types for RepoLens\n//!\n//! This module defines custom error types using `thiserror` for better error handling\n//! and more descriptive error messages throughout the application.\n\nuse thiserror::Error;\n\n/// Main error type for RepoLens\n#[derive(Error, Debug)]\npub enum RepoLensError {\n    /// Scan-related errors\n    #[error(\"Scan error: {0}\")]\n    Scan(#[from] ScanError),\n\n    /// Configuration-related errors\n    #[error(\"Config error: {0}\")]\n    Config(#[from] ConfigError),\n\n    /// Provider-related errors (GitHub API, etc.)\n    #[error(\"Provider error: {0}\")]\n    Provider(#[from] ProviderError),\n\n    /// Action execution errors\n    #[error(\"Action error: {0}\")]\n    Action(#[from] ActionError),\n\n    /// Rule execution errors\n    #[error(\"Rule error: {0}\")]\n    Rule(#[from] RuleError),\n}\n\n/// Errors that occur during repository scanning\n#[derive(Error, Debug)]\npub enum ScanError {\n    /// Failed to read a file\n    #[error(\"Failed to read file '{path}': {source}\")]\n    FileRead {\n        /// Path to the file that failed to read\n        path: String,\n        /// The underlying I/O error\n        source: std::io::Error,\n    },\n}\n\n/// Errors that occur during configuration loading and parsing\n#[derive(Error, Debug)]\npub enum ConfigError {\n    /// Failed to read configuration file\n    #[error(\"Failed to read configuration file '{path}': {source}\")]\n    FileRead {\n        /// Path to the configuration file\n        path: String,\n        /// The underlying I/O error\n        source: std::io::Error,\n    },\n\n    /// Failed to parse configuration file\n    #[error(\"Failed to parse configuration file: {message}\")]\n    Parse {\n        /// Error message describing the parse failure\n        message: String,\n    },\n\n    /// Failed to serialize configuration\n    #[error(\"Failed to serialize configuration: {message}\")]\n    Serialize {\n        /// Error message describing the serialization failure\n        message: String,\n    },\n\n    /// Invalid preset name\n    #[error(\"Invalid preset name: {name}\")]\n    InvalidPreset {\n        /// The invalid preset name\n        name: String,\n    },\n}\n\n/// Errors that occur when interacting with external providers (GitHub API, etc.)\n#[derive(Error, Debug)]\npub enum ProviderError {\n    /// Command execution failed\n    #[error(\"Command execution failed: {command}\")]\n    CommandFailed {\n        /// The command that failed\n        command: String,\n    },\n\n    /// Failed to parse JSON response\n    #[error(\"Failed to parse JSON response: {message}\")]\n    JsonParse {\n        /// Error message describing the parse failure\n        message: String,\n    },\n\n    /// Not in a GitHub repository or not authenticated\n    #[error(\"Not in a GitHub repository or not authenticated\")]\n    NotAuthenticated,\n\n    /// Invalid repository name format\n    #[error(\"Invalid repository name format: {name}\")]\n    InvalidRepoName {\n        /// The invalid repository name\n        name: String,\n    },\n\n    /// GitHub CLI not available\n    #[error(\"GitHub CLI (gh) is not available or not authenticated\")]\n    GitHubCliNotAvailable,\n}\n\n/// Errors that occur during action execution\n#[derive(Error, Debug)]\npub enum ActionError {\n    /// Failed to create file\n    #[error(\"Failed to create file '{path}': {source}\")]\n    #[allow(dead_code)]\n    FileCreate {\n        /// Path to the file that failed to create\n        path: String,\n        /// The underlying I/O error\n        source: std::io::Error,\n    },\n\n    /// Failed to write file\n    #[error(\"Failed to write file '{path}': {source}\")]\n    FileWrite {\n        /// Path to the file that failed to write\n        path: String,\n        /// The underlying I/O error\n        source: std::io::Error,\n    },\n\n    /// Failed to create directory\n    #[error(\"Failed to create directory '{path}': {source}\")]\n    DirectoryCreate {\n        /// Path to the directory that failed to create\n        path: String,\n        /// The underlying I/O error\n        source: std::io::Error,\n    },\n\n    /// Unknown template\n    #[error(\"Unknown template: {name}\")]\n    UnknownTemplate {\n        /// The unknown template name\n        name: String,\n    },\n\n    /// Action execution failed\n    #[error(\"Action execution failed: {message}\")]\n    ExecutionFailed {\n        /// Error message describing the failure\n        message: String,\n    },\n}\n\n/// Errors that occur during rule execution\n#[derive(Error, Debug)]\npub enum RuleError {\n    /// Rule execution failed\n    #[error(\"Rule execution failed: {message}\")]\n    ExecutionFailed {\n        /// Error message describing the failure\n        message: String,\n    },\n}\n\n// Allow conversion from std::io::Error for convenience\nimpl From\u003cstd::io::Error\u003e for RepoLensError {\n    fn from(err: std::io::Error) -\u003e Self {\n        RepoLensError::Scan(ScanError::FileRead {\n            path: \"unknown\".to_string(),\n            source: err,\n        })\n    }\n}\n\n// Conversion from toml::de::Error\nimpl From\u003ctoml::de::Error\u003e for RepoLensError {\n    fn from(err: toml::de::Error) -\u003e Self {\n        RepoLensError::Config(ConfigError::Parse {\n            message: err.to_string(),\n        })\n    }\n}\n\n// Conversion from toml::ser::Error\nimpl From\u003ctoml::ser::Error\u003e for RepoLensError {\n    fn from(err: toml::ser::Error) -\u003e Self {\n        RepoLensError::Config(ConfigError::Serialize {\n            message: err.to_string(),\n        })\n    }\n}\n\n// Conversion from serde_json::Error\nimpl From\u003cserde_json::Error\u003e for RepoLensError {\n    fn from(err: serde_json::Error) -\u003e Self {\n        RepoLensError::Provider(ProviderError::JsonParse {\n            message: err.to_string(),\n        })\n    }\n}\n","traces":[{"line":170,"address":[12777514,12778298],"length":1,"stats":{"Line":2}},{"line":171,"address":[6393129],"length":1,"stats":{"Line":2}},{"line":172,"address":[8448433,8447649],"length":1,"stats":{"Line":2}},{"line":173,"address":[3277710],"length":1,"stats":{"Line":0}},{"line":174,"address":[6392969],"length":1,"stats":{"Line":4}},{"line":180,"address":[6393184],"length":1,"stats":{"Line":0}},{"line":181,"address":[847124,846944],"length":1,"stats":{"Line":0}},{"line":182,"address":[12778784],"length":1,"stats":{"Line":2}},{"line":183,"address":[3277906],"length":1,"stats":{"Line":0}},{"line":189,"address":[6699161],"length":1,"stats":{"Line":0}},{"line":190,"address":[12778839],"length":1,"stats":{"Line":0}},{"line":191,"address":[15778011],"length":1,"stats":{"Line":0}},{"line":192,"address":[6698992],"length":1,"stats":{"Line":0}},{"line":198,"address":[10625488],"length":1,"stats":{"Line":2}},{"line":199,"address":[999472,999657,999651],"length":1,"stats":{"Line":6}},{"line":200,"address":[8449469],"length":1,"stats":{"Line":2}},{"line":201,"address":[8449551,8449612],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":17},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","lib.rs"],"content":"//! RepoLens Library\n//!\n//! This crate provides the core functionality for auditing repositories\n//! and preparing them for open source or enterprise standards.\n\npub mod actions;\npub mod cli;\npub mod config;\npub mod error;\npub mod providers;\npub mod rules;\npub mod scanner;\npub mod utils;\n\npub use error::RepoLensError;\n\n/// Exit codes for the CLI\npub mod exit_codes {\n    /// Success - no issues found\n    pub const SUCCESS: i32 = 0;\n    /// Critical issues found that block release\n    pub const CRITICAL_ISSUES: i32 = 1;\n    /// Warnings found but not blocking\n    pub const WARNINGS: i32 = 2;\n    /// Configuration or runtime error\n    pub const ERROR: i32 = 3;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","main.rs"],"content":"//! RepoLens - A CLI tool to audit and prepare repositories for open source or enterprise standards\n//!\n//! This is the main entry point for the CLI application.\n\nuse clap::Parser;\nuse tracing_subscriber::{fmt, prelude::*, EnvFilter};\n\nmod actions;\nmod cli;\nmod config;\nmod error;\nmod providers;\nmod rules;\nmod scanner;\nmod utils;\n\nuse error::RepoLensError;\n\n/// Exit codes for the CLI\npub mod exit_codes {\n    /// Success - no issues found\n    pub const SUCCESS: i32 = 0;\n    /// Critical issues found that block release\n    pub const CRITICAL_ISSUES: i32 = 1;\n    /// Warnings found but not blocking\n    pub const WARNINGS: i32 = 2;\n    /// Configuration or runtime error\n    pub const ERROR: i32 = 3;\n}\n\nuse cli::{Cli, Commands};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), RepoLensError\u003e {\n    // Parse CLI arguments\n    let cli = Cli::parse();\n\n    // Setup logging based on verbosity\n    setup_logging(cli.verbose);\n\n    // Execute the appropriate command\n    let result = match cli.command {\n        Commands::Init(args) =\u003e cli::commands::init::execute(args).await,\n        Commands::Plan(args) =\u003e cli::commands::plan::execute(args).await,\n        Commands::Apply(args) =\u003e cli::commands::apply::execute(args).await,\n        Commands::Report(args) =\u003e cli::commands::report::execute(args).await,\n    };\n\n    // Handle exit codes for CI integration\n    match result {\n        Ok(exit_code) =\u003e std::process::exit(exit_code),\n        Err(e) =\u003e {\n            eprintln!(\"Error: {}\", e);\n            std::process::exit(1);\n        }\n    }\n}\n\nfn setup_logging(verbosity: u8) {\n    let filter = match verbosity {\n        0 =\u003e \"warn\",\n        1 =\u003e \"info\",\n        2 =\u003e \"debug\",\n        _ =\u003e \"trace\",\n    };\n\n    tracing_subscriber::registry()\n        .with(fmt::layer())\n        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(filter)))\n        .init();\n}\n","traces":[{"line":34,"address":[681772,681344,681766],"length":1,"stats":{"Line":0}},{"line":36,"address":[807766],"length":1,"stats":{"Line":0}},{"line":39,"address":[808007],"length":1,"stats":{"Line":0}},{"line":42,"address":[808114],"length":1,"stats":{"Line":0}},{"line":43,"address":[629364],"length":1,"stats":{"Line":0}},{"line":44,"address":[629383],"length":1,"stats":{"Line":0}},{"line":45,"address":[629402],"length":1,"stats":{"Line":0}},{"line":46,"address":[629421],"length":1,"stats":{"Line":0}},{"line":50,"address":[681530,681400,681460,681641],"length":1,"stats":{"Line":0}},{"line":51,"address":[809937],"length":1,"stats":{"Line":0}},{"line":52,"address":[809872],"length":1,"stats":{"Line":0}},{"line":53,"address":[810001,809930],"length":1,"stats":{"Line":0}},{"line":54,"address":[810070],"length":1,"stats":{"Line":0}},{"line":59,"address":[681306,681274,680816],"length":1,"stats":{"Line":0}},{"line":60,"address":[680852],"length":1,"stats":{"Line":0}},{"line":61,"address":[680917],"length":1,"stats":{"Line":0}},{"line":62,"address":[680940],"length":1,"stats":{"Line":0}},{"line":63,"address":[680963],"length":1,"stats":{"Line":0}},{"line":64,"address":[680894],"length":1,"stats":{"Line":0}},{"line":67,"address":[681212,681256,680984,681065],"length":1,"stats":{"Line":0}},{"line":68,"address":[681312,681017,681024,681104],"length":1,"stats":{"Line":0}},{"line":69,"address":[681139,681248,681287,681120],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","providers","github.rs"],"content":"//! GitHub provider - Interactions with GitHub API via gh CLI\n\nuse crate::error::{ProviderError, RepoLensError};\nuse serde::Deserialize;\nuse std::process::Command;\n\n/// GitHub provider for repository operations\n#[allow(dead_code)]\npub struct GitHubProvider {\n    repo_owner: String,\n    repo_name: String,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\nstruct RepoInfo {\n    name: String,\n    owner: RepoOwner,\n    visibility: String,\n    #[serde(rename = \"hasIssuesEnabled\")]\n    has_issues_enabled: bool,\n    #[serde(rename = \"hasDiscussionsEnabled\")]\n    has_discussions_enabled: bool,\n    #[serde(rename = \"hasWikiEnabled\")]\n    has_wiki_enabled: bool,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\nstruct RepoOwner {\n    login: String,\n}\n\nimpl GitHubProvider {\n    /// Create a new GitHub provider for the current repository\n    #[allow(dead_code)]\n    pub fn new() -\u003e Result\u003cSelf, RepoLensError\u003e {\n        let (owner, name) = Self::get_repo_info()?;\n        Ok(Self {\n            repo_owner: owner,\n            repo_name: name,\n        })\n    }\n\n    /// Check if GitHub CLI is available and authenticated\n    #[allow(dead_code)]\n    pub fn is_available() -\u003e bool {\n        Command::new(\"gh\")\n            .args([\"auth\", \"status\"])\n            .output()\n            .map(|o| o.status.success())\n            .unwrap_or(false)\n    }\n\n    /// Get repository owner and name\n    #[allow(dead_code)]\n    fn get_repo_info() -\u003e Result\u003c(String, String), RepoLensError\u003e {\n        let output = Command::new(\"gh\")\n            .args([\n                \"repo\",\n                \"view\",\n                \"--json\",\n                \"owner,name\",\n                \"-q\",\n                \".owner.login + \\\"/\\\" + .name\",\n            ])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: \"gh repo view\".to_string(),\n                })\n            })?;\n\n        if !output.status.success() {\n            return Err(RepoLensError::Provider(ProviderError::NotAuthenticated));\n        }\n\n        let full_name = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n        let parts: Vec\u003c\u0026str\u003e = full_name.split('/').collect();\n\n        if parts.len() != 2 {\n            return Err(RepoLensError::Provider(ProviderError::InvalidRepoName {\n                name: full_name,\n            }));\n        }\n\n        Ok((parts[0].to_string(), parts[1].to_string()))\n    }\n\n    /// Get the full repository name (owner/name)\n    #[allow(dead_code)]\n    pub fn full_name(\u0026self) -\u003e String {\n        format!(\"{}/{}\", self.repo_owner, self.repo_name)\n    }\n\n    /// Get repository visibility\n    #[allow(dead_code)]\n    pub fn get_visibility(\u0026self) -\u003e Result\u003cString, RepoLensError\u003e {\n        let output = Command::new(\"gh\")\n            .args([\"repo\", \"view\", \"--json\", \"visibility\", \"-q\", \".visibility\"])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: \"gh repo view\".to_string(),\n                })\n            })?;\n\n        Ok(String::from_utf8_lossy(\u0026output.stdout)\n            .trim()\n            .to_lowercase())\n    }\n\n    /// Check if the repository is public\n    #[allow(dead_code)]\n    pub fn is_public(\u0026self) -\u003e Result\u003cbool, RepoLensError\u003e {\n        Ok(self.get_visibility()? == \"public\")\n    }\n\n    /// Get list of repository secrets (names only)\n    #[allow(dead_code)]\n    pub fn list_secrets(\u0026self) -\u003e Result\u003cVec\u003cString\u003e, RepoLensError\u003e {\n        let output = Command::new(\"gh\")\n            .args([\"secret\", \"list\", \"--json\", \"name\", \"-q\", \".[].name\"])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: \"gh secret list\".to_string(),\n                })\n            })?;\n\n        if !output.status.success() {\n            return Ok(Vec::new());\n        }\n\n        let output_str = String::from_utf8_lossy(\u0026output.stdout);\n        Ok(output_str.lines().map(|s| s.to_string()).collect())\n    }\n\n    /// Get list of repository variables\n    #[allow(dead_code)]\n    pub fn list_variables(\u0026self) -\u003e Result\u003cVec\u003cString\u003e, RepoLensError\u003e {\n        let output = Command::new(\"gh\")\n            .args([\"variable\", \"list\", \"--json\", \"name\", \"-q\", \".[].name\"])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: \"gh variable list\".to_string(),\n                })\n            })?;\n\n        if !output.status.success() {\n            return Ok(Vec::new());\n        }\n\n        let output_str = String::from_utf8_lossy(\u0026output.stdout);\n        Ok(output_str.lines().map(|s| s.to_string()).collect())\n    }\n\n    /// Get branch protection status\n    #[allow(dead_code)]\n    pub fn get_branch_protection(\n        \u0026self,\n        branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cBranchProtection\u003e, RepoLensError\u003e {\n        let output = Command::new(\"gh\")\n            .args([\n                \"api\",\n                \u0026format!(\"repos/{}/branches/{}/protection\", self.full_name(), branch),\n            ])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: format!(\n                        \"gh api repos/{}/branches/{}/protection\",\n                        self.full_name(),\n                        branch\n                    ),\n                })\n            })?;\n\n        if !output.status.success() {\n            // 404 means no protection\n            return Ok(None);\n        }\n\n        let protection: BranchProtection = serde_json::from_slice(\u0026output.stdout)?;\n\n        Ok(Some(protection))\n    }\n}\n\n/// Branch protection settings from GitHub API\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct BranchProtection {\n    #[serde(rename = \"required_status_checks\")]\n    pub required_status_checks: Option\u003cStatusChecks\u003e,\n\n    #[serde(rename = \"enforce_admins\")]\n    pub enforce_admins: Option\u003cEnforceAdmins\u003e,\n\n    #[serde(rename = \"required_pull_request_reviews\")]\n    pub required_pull_request_reviews: Option\u003cPullRequestReviews\u003e,\n\n    #[serde(rename = \"required_linear_history\")]\n    pub required_linear_history: Option\u003cRequiredLinearHistory\u003e,\n\n    #[serde(rename = \"allow_force_pushes\")]\n    pub allow_force_pushes: Option\u003cAllowForcePushes\u003e,\n\n    #[serde(rename = \"allow_deletions\")]\n    pub allow_deletions: Option\u003cAllowDeletions\u003e,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct StatusChecks {\n    pub strict: bool,\n    pub contexts: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct EnforceAdmins {\n    pub enabled: bool,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct PullRequestReviews {\n    #[serde(rename = \"required_approving_review_count\")]\n    pub required_approving_review_count: u32,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct RequiredLinearHistory {\n    pub enabled: bool,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct AllowForcePushes {\n    pub enabled: bool,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct AllowDeletions {\n    pub enabled: bool,\n}\n","traces":[{"line":37,"address":[323232],"length":1,"stats":{"Line":0}},{"line":38,"address":[1001536],"length":1,"stats":{"Line":0}},{"line":39,"address":[323468],"length":1,"stats":{"Line":0}},{"line":47,"address":[323816,323822,323584],"length":1,"stats":{"Line":0}},{"line":48,"address":[323740,323591,323685],"length":1,"stats":{"Line":0}},{"line":49,"address":[323623],"length":1,"stats":{"Line":0}},{"line":51,"address":[603801,603792],"length":1,"stats":{"Line":0}},{"line":57,"address":[323840,325703,325662],"length":1,"stats":{"Line":0}},{"line":58,"address":[323857,324131,324286,324070],"length":1,"stats":{"Line":0}},{"line":59,"address":[323900],"length":1,"stats":{"Line":0}},{"line":68,"address":[603888,604082,604076],"length":1,"stats":{"Line":0}},{"line":69,"address":[1302901],"length":1,"stats":{"Line":0}},{"line":70,"address":[603906],"length":1,"stats":{"Line":0}},{"line":74,"address":[324498],"length":1,"stats":{"Line":0}},{"line":75,"address":[324536],"length":1,"stats":{"Line":0}},{"line":78,"address":[324723,324666],"length":1,"stats":{"Line":0}},{"line":79,"address":[324947],"length":1,"stats":{"Line":0}},{"line":81,"address":[325025,325098],"length":1,"stats":{"Line":0}},{"line":82,"address":[325187],"length":1,"stats":{"Line":0}},{"line":83,"address":[325147],"length":1,"stats":{"Line":0}},{"line":87,"address":[325351,325104],"length":1,"stats":{"Line":0}},{"line":92,"address":[325744],"length":1,"stats":{"Line":0}},{"line":93,"address":[325773],"length":1,"stats":{"Line":0}},{"line":98,"address":[326876,326870,325936],"length":1,"stats":{"Line":0}},{"line":99,"address":[326227,326166,326382,325961],"length":1,"stats":{"Line":0}},{"line":100,"address":[1004284],"length":1,"stats":{"Line":0}},{"line":102,"address":[604284,604096,604290],"length":1,"stats":{"Line":0}},{"line":103,"address":[604181],"length":1,"stats":{"Line":0}},{"line":104,"address":[604114],"length":1,"stats":{"Line":0}},{"line":108,"address":[326582,326710],"length":1,"stats":{"Line":0}},{"line":115,"address":[327205,326912,327199],"length":1,"stats":{"Line":0}},{"line":116,"address":[326937,327162],"length":1,"stats":{"Line":0}},{"line":121,"address":[327232,328266,328272],"length":1,"stats":{"Line":0}},{"line":122,"address":[327462,327523,327678,327257],"length":1,"stats":{"Line":0}},{"line":123,"address":[327292],"length":1,"stats":{"Line":0}},{"line":125,"address":[604492,604498,604304],"length":1,"stats":{"Line":0}},{"line":126,"address":[604389],"length":1,"stats":{"Line":0}},{"line":127,"address":[604322],"length":1,"stats":{"Line":0}},{"line":131,"address":[327878],"length":1,"stats":{"Line":0}},{"line":132,"address":[327907,327957],"length":1,"stats":{"Line":0}},{"line":135,"address":[327926,328033],"length":1,"stats":{"Line":0}},{"line":136,"address":[1303440,1303493],"length":1,"stats":{"Line":0}},{"line":141,"address":[329344,328304,329338],"length":1,"stats":{"Line":0}},{"line":142,"address":[328329,328534,328595,328750],"length":1,"stats":{"Line":0}},{"line":143,"address":[328364],"length":1,"stats":{"Line":0}},{"line":145,"address":[1303520,1303708,1303714],"length":1,"stats":{"Line":0}},{"line":146,"address":[604677],"length":1,"stats":{"Line":0}},{"line":147,"address":[1303538],"length":1,"stats":{"Line":0}},{"line":151,"address":[328950],"length":1,"stats":{"Line":0}},{"line":152,"address":[328979,329029],"length":1,"stats":{"Line":0}},{"line":155,"address":[328998,329105],"length":1,"stats":{"Line":0}},{"line":156,"address":[1303728,1303781],"length":1,"stats":{"Line":0}},{"line":161,"address":[330733,329376,330727],"length":1,"stats":{"Line":0}},{"line":165,"address":[329416,329946,330128],"length":1,"stats":{"Line":0}},{"line":166,"address":[329887],"length":1,"stats":{"Line":0}},{"line":168,"address":[329454,329505],"length":1,"stats":{"Line":0}},{"line":171,"address":[1304298,1303808,1304292],"length":1,"stats":{"Line":0}},{"line":172,"address":[605258],"length":1,"stats":{"Line":0}},{"line":173,"address":[604972],"length":1,"stats":{"Line":0}},{"line":175,"address":[604911],"length":1,"stats":{"Line":0}},{"line":181,"address":[330391],"length":1,"stats":{"Line":0}},{"line":183,"address":[330425],"length":1,"stats":{"Line":0}},{"line":186,"address":[330522,330722,330463],"length":1,"stats":{"Line":0}},{"line":188,"address":[330650],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":64},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","providers","mod.rs"],"content":"//! Provider module - External service integrations\n\npub mod github;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","custom.rs"],"content":"//! Custom rules category\n//!\n//! Allows users to define custom audit rules via regex patterns in configuration.\n\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::{Finding, Severity};\nuse crate::scanner::Scanner;\nuse regex::Regex;\nuse tracing::debug;\n\n/// Custom rules implementation\npub struct CustomRules;\n\n/// Simple glob matching (supports * and **)\nfn glob_match(pattern: \u0026str, text: \u0026str) -\u003e bool {\n    if pattern.contains(\"**\") {\n        return glob_match_double_star(pattern, text);\n    }\n\n    if pattern.contains('*') {\n        return glob_match_single_star(pattern, text);\n    }\n\n    text == pattern\n}\n\n/// Match pattern with double star (**)\nfn glob_match_double_star(pattern: \u0026str, text: \u0026str) -\u003e bool {\n    let parts: Vec\u003c\u0026str\u003e = pattern.split(\"**\").collect();\n\n    if parts.len() == 3 \u0026\u0026 parts[0].is_empty() \u0026\u0026 parts[2].is_empty() {\n        let middle = parts[1].trim_matches('/');\n        return text.contains(\u0026format!(\"/{}\", middle)) || text.starts_with(middle);\n    }\n\n    if parts.len() != 2 {\n        return false;\n    }\n\n    let prefix = parts[0].trim_end_matches('/');\n    let suffix_raw = parts[1];\n    let suffix = suffix_raw.trim_start_matches('/');\n\n    if !prefix.is_empty() \u0026\u0026 !text.starts_with(prefix) {\n        return false;\n    }\n\n    if suffix.is_empty() {\n        return true;\n    }\n\n    if suffix.starts_with('*') {\n        let suffix_pattern = suffix.trim_start_matches('*');\n        return text.ends_with(suffix_pattern);\n    }\n\n    if prefix.is_empty() {\n        if suffix_raw.starts_with('/') {\n            let pattern_to_find = format!(\"/{}\", suffix);\n            if text.contains(\u0026pattern_to_find) {\n                return true;\n            }\n            if text.starts_with(suffix) {\n                return true;\n            }\n            return false;\n        }\n        return text.contains(suffix);\n    }\n\n    if let Some(after_prefix) = text.strip_prefix(prefix) {\n        return after_prefix.contains(suffix) || after_prefix.ends_with(suffix);\n    }\n\n    text.ends_with(suffix) || text.contains(suffix)\n}\n\n/// Match pattern with single star (*)\nfn glob_match_single_star(pattern: \u0026str, text: \u0026str) -\u003e bool {\n    let parts: Vec\u003c\u0026str\u003e = pattern.split('*').collect();\n    let mut pos = 0;\n\n    for (i, part) in parts.iter().enumerate() {\n        if part.is_empty() {\n            continue;\n        }\n\n        if let Some(found_pos) = text[pos..].find(part) {\n            if i == 0 \u0026\u0026 found_pos != 0 {\n                return false;\n            }\n            pos += found_pos + part.len();\n        } else {\n            return false;\n        }\n    }\n\n    if let Some(last_part) = parts.last() {\n        if !last_part.is_empty() {\n            return text.ends_with(last_part);\n        }\n    }\n\n    true\n}\n\n#[async_trait::async_trait]\nimpl RuleCategory for CustomRules {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"custom\"\n    }\n\n    async fn run(\n        \u0026self,\n        scanner: \u0026Scanner,\n        config: \u0026Config,\n    ) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n        let mut findings = Vec::new();\n\n        // Skip if no custom rules defined\n        if config.custom_rules.rules.is_empty() {\n            debug!(\"No custom rules defined\");\n            return Ok(findings);\n        }\n\n        // Get all files from the scanner\n        let all_files = scanner.all_files();\n\n        for (rule_id, rule) in \u0026config.custom_rules.rules {\n            debug!(rule_id = %rule_id, pattern = %rule.pattern, \"Processing custom rule\");\n\n            // Compile the regex pattern\n            let regex = match Regex::new(\u0026rule.pattern) {\n                Ok(r) =\u003e r,\n                Err(e) =\u003e {\n                    debug!(\n                        rule_id = %rule_id,\n                        error = %e,\n                        \"Invalid regex pattern in custom rule\"\n                    );\n                    continue;\n                }\n            };\n\n            // Determine severity\n            let severity = match rule.severity.to_lowercase().as_str() {\n                \"critical\" =\u003e Severity::Critical,\n                \"warning\" =\u003e Severity::Warning,\n                \"info\" =\u003e Severity::Info,\n                _ =\u003e Severity::Warning,\n            };\n\n            // Filter files based on glob patterns\n            let files_to_check: Vec\u003c_\u003e = if rule.files.is_empty() {\n                all_files.iter().collect()\n            } else {\n                all_files\n                    .iter()\n                    .filter(|file| {\n                        rule.files\n                            .iter()\n                            .any(|pattern| glob_match(pattern, \u0026file.path))\n                    })\n                    .collect()\n            };\n\n            // Check each file\n            for file_info in files_to_check {\n                let file_path = \u0026file_info.path;\n\n                // Read file content\n                let content = match scanner.read_file(file_path) {\n                    Ok(c) =\u003e c,\n                    Err(_) =\u003e continue, // Skip files that can't be read\n                };\n\n                let pattern_found = regex.is_match(\u0026content);\n\n                // Handle inverted matching\n                let should_report = if rule.invert {\n                    !pattern_found // Report if pattern NOT found\n                } else {\n                    pattern_found // Report if pattern found\n                };\n\n                if should_report {\n                    // Find line numbers for matches (only for non-inverted)\n                    let locations: Vec\u003c(usize, String)\u003e = if !rule.invert {\n                        content\n                            .lines()\n                            .enumerate()\n                            .filter(|(_, line)| regex.is_match(line))\n                            .map(|(i, line)| (i + 1, line.to_string()))\n                            .take(5) // Limit to first 5 matches\n                            .collect()\n                    } else {\n                        vec![]\n                    };\n\n                    let message = rule.message.clone().unwrap_or_else(|| {\n                        if rule.invert {\n                            format!(\"Required pattern '{}' not found\", rule.pattern)\n                        } else {\n                            format!(\"Pattern '{}' matched\", rule.pattern)\n                        }\n                    });\n\n                    let description = rule.description.clone().unwrap_or_else(|| {\n                        if locations.is_empty() {\n                            format!(\"Custom rule '{}' triggered in {}\", rule_id, file_path)\n                        } else {\n                            let lines: Vec\u003cString\u003e = locations\n                                .iter()\n                                .map(|(line_num, _)| format!(\"line {}\", line_num))\n                                .collect();\n                            format!(\n                                \"Custom rule '{}' triggered in {} at {}\",\n                                rule_id,\n                                file_path,\n                                lines.join(\", \")\n                            )\n                        }\n                    });\n\n                    let location = if let Some((line_num, _)) = locations.first() {\n                        Some(format!(\"{}:{}\", file_path, line_num))\n                    } else {\n                        Some(file_path.to_string())\n                    };\n\n                    findings.push(Finding {\n                        rule_id: format!(\"custom/{}\", rule_id),\n                        category: \"custom\".to_string(),\n                        severity,\n                        message,\n                        location,\n                        description: Some(description),\n                        remediation: rule.remediation.clone(),\n                    });\n                }\n            }\n        }\n\n        Ok(findings)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::{CustomRule, CustomRulesConfig};\n    use std::collections::HashMap;\n    use std::fs;\n    use tempfile::TempDir;\n\n    fn create_test_config_with_rule(rule_id: \u0026str, rule: CustomRule) -\u003e Config {\n        let mut rules = HashMap::new();\n        rules.insert(rule_id.to_string(), rule);\n        let mut config = Config::default();\n        config.custom_rules = CustomRulesConfig { rules };\n        config\n    }\n\n    #[tokio::test]\n    async fn test_custom_rule_pattern_match() {\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"test.rs\");\n        fs::write(\u0026test_file, \"// TODO: fix this later\\nfn main() {}\").unwrap();\n\n        let rule = CustomRule {\n            pattern: \"TODO\".to_string(),\n            severity: \"warning\".to_string(),\n            files: vec![\"**/*.rs\".to_string()],\n            message: Some(\"TODO comment found\".to_string()),\n            description: None,\n            remediation: Some(\"Address or remove the TODO\".to_string()),\n            invert: false,\n        };\n\n        let config = create_test_config_with_rule(\"no-todo\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(\u0026scanner, \u0026config).await.unwrap();\n\n        assert_eq!(findings.len(), 1);\n        assert_eq!(findings[0].rule_id, \"custom/no-todo\");\n        assert_eq!(findings[0].severity, Severity::Warning);\n        assert!(findings[0].message.contains(\"TODO\"));\n    }\n\n    #[tokio::test]\n    async fn test_custom_rule_no_match() {\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"test.rs\");\n        fs::write(\u0026test_file, \"fn main() { println!(\\\"Hello\\\"); }\").unwrap();\n\n        let rule = CustomRule {\n            pattern: \"TODO\".to_string(),\n            severity: \"warning\".to_string(),\n            files: vec![\"**/*.rs\".to_string()],\n            message: None,\n            description: None,\n            remediation: None,\n            invert: false,\n        };\n\n        let config = create_test_config_with_rule(\"no-todo\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(findings.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_custom_rule_inverted_match() {\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"lib.rs\");\n        fs::write(\u0026test_file, \"fn helper() {}\").unwrap();\n\n        let rule = CustomRule {\n            pattern: r\"^//!\".to_string(), // Module doc comment\n            severity: \"info\".to_string(),\n            files: vec![\"**/lib.rs\".to_string()],\n            message: Some(\"Missing module documentation\".to_string()),\n            description: None,\n            remediation: Some(\"Add module-level documentation\".to_string()),\n            invert: true, // Fail when NOT found\n        };\n\n        let config = create_test_config_with_rule(\"require-doc\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(\u0026scanner, \u0026config).await.unwrap();\n\n        assert_eq!(findings.len(), 1);\n        assert_eq!(findings[0].rule_id, \"custom/require-doc\");\n        assert!(findings[0].message.contains(\"Missing module documentation\"));\n    }\n\n    #[tokio::test]\n    async fn test_custom_rule_file_filter() {\n        let temp_dir = TempDir::new().unwrap();\n        fs::write(temp_dir.path().join(\"test.rs\"), \"TODO: fix\").unwrap();\n        fs::write(temp_dir.path().join(\"test.js\"), \"// TODO: fix\").unwrap();\n\n        let rule = CustomRule {\n            pattern: \"TODO\".to_string(),\n            severity: \"warning\".to_string(),\n            files: vec![\"**/*.rs\".to_string()], // Only Rust files\n            message: None,\n            description: None,\n            remediation: None,\n            invert: false,\n        };\n\n        let config = create_test_config_with_rule(\"no-todo\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(\u0026scanner, \u0026config).await.unwrap();\n\n        // Should only find in .rs file, not .js\n        assert_eq!(findings.len(), 1);\n        assert!(findings[0].location.as_ref().unwrap().ends_with(\".rs\") \n            || findings[0].location.as_ref().unwrap().contains(\".rs:\"));\n    }\n\n    #[tokio::test]\n    async fn test_custom_rule_severity_levels() {\n        let temp_dir = TempDir::new().unwrap();\n        fs::write(temp_dir.path().join(\"test.rs\"), \"FIXME: urgent\").unwrap();\n\n        let rule = CustomRule {\n            pattern: \"FIXME\".to_string(),\n            severity: \"critical\".to_string(),\n            files: vec![],\n            message: None,\n            description: None,\n            remediation: None,\n            invert: false,\n        };\n\n        let config = create_test_config_with_rule(\"no-fixme\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(\u0026scanner, \u0026config).await.unwrap();\n\n        assert_eq!(findings.len(), 1);\n        assert_eq!(findings[0].severity, Severity::Critical);\n    }\n\n    #[tokio::test]\n    async fn test_no_custom_rules_returns_empty() {\n        let temp_dir = TempDir::new().unwrap();\n        fs::write(temp_dir.path().join(\"test.rs\"), \"fn main() {}\").unwrap();\n\n        let config = Config::default(); // No custom rules\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(findings.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_invalid_regex_is_skipped() {\n        let temp_dir = TempDir::new().unwrap();\n        fs::write(temp_dir.path().join(\"test.rs\"), \"test content\").unwrap();\n\n        let rule = CustomRule {\n            pattern: \"[invalid regex\".to_string(), // Invalid regex\n            severity: \"warning\".to_string(),\n            files: vec![],\n            message: None,\n            description: None,\n            remediation: None,\n            invert: false,\n        };\n\n        let config = create_test_config_with_rule(\"bad-rule\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        // Should not panic, just skip the invalid rule\n        let findings = custom_rules.run(\u0026scanner, \u0026config).await.unwrap();\n        assert!(findings.is_empty());\n    }\n}\n","traces":[{"line":17,"address":[1219184],"length":1,"stats":{"Line":6}},{"line":18,"address":[950839],"length":1,"stats":{"Line":5}},{"line":19,"address":[950896],"length":1,"stats":{"Line":2}},{"line":22,"address":[950870],"length":1,"stats":{"Line":0}},{"line":23,"address":[950950],"length":1,"stats":{"Line":0}},{"line":26,"address":[950928],"length":1,"stats":{"Line":0}},{"line":30,"address":[951867,953329,950992],"length":1,"stats":{"Line":6}},{"line":31,"address":[951056],"length":1,"stats":{"Line":2}},{"line":33,"address":[1219499,1219652,1219570],"length":1,"stats":{"Line":8}},{"line":34,"address":[951398],"length":1,"stats":{"Line":0}},{"line":35,"address":[1219884,1220229],"length":1,"stats":{"Line":0}},{"line":38,"address":[951242,951881],"length":1,"stats":{"Line":8}},{"line":39,"address":[951925],"length":1,"stats":{"Line":0}},{"line":42,"address":[951943,951887],"length":1,"stats":{"Line":8}},{"line":43,"address":[1220402],"length":1,"stats":{"Line":5}},{"line":44,"address":[952115],"length":1,"stats":{"Line":3}},{"line":46,"address":[952261,952168],"length":1,"stats":{"Line":5}},{"line":47,"address":[952267],"length":1,"stats":{"Line":0}},{"line":50,"address":[952230,952284],"length":1,"stats":{"Line":8}},{"line":51,"address":[952326],"length":1,"stats":{"Line":0}},{"line":54,"address":[1220715,1220662],"length":1,"stats":{"Line":7}},{"line":55,"address":[952370,953280],"length":1,"stats":{"Line":6}},{"line":56,"address":[953296],"length":1,"stats":{"Line":3}},{"line":59,"address":[952359,952415],"length":1,"stats":{"Line":4}},{"line":60,"address":[952875,952478],"length":1,"stats":{"Line":4}},{"line":61,"address":[952973,952928],"length":1,"stats":{"Line":4}},{"line":62,"address":[1221469,1221528],"length":1,"stats":{"Line":4}},{"line":63,"address":[953209],"length":1,"stats":{"Line":0}},{"line":65,"address":[953223,953178],"length":1,"stats":{"Line":4}},{"line":70,"address":[952959,952897],"length":1,"stats":{"Line":0}},{"line":73,"address":[1220819,1220883],"length":1,"stats":{"Line":0}},{"line":74,"address":[952682,952600],"length":1,"stats":{"Line":0}},{"line":77,"address":[952764,952647],"length":1,"stats":{"Line":0}},{"line":81,"address":[954461,954467,953344],"length":1,"stats":{"Line":0}},{"line":82,"address":[953408],"length":1,"stats":{"Line":0}},{"line":83,"address":[953479],"length":1,"stats":{"Line":0}},{"line":85,"address":[954438,953491,953578],"length":1,"stats":{"Line":0}},{"line":86,"address":[953855,954130],"length":1,"stats":{"Line":0}},{"line":90,"address":[954156],"length":1,"stats":{"Line":0}},{"line":91,"address":[954290,954316],"length":1,"stats":{"Line":0}},{"line":92,"address":[954346],"length":1,"stats":{"Line":0}},{"line":94,"address":[954327,954369,954443],"length":1,"stats":{"Line":0}},{"line":96,"address":[954298],"length":1,"stats":{"Line":0}},{"line":100,"address":[953879],"length":1,"stats":{"Line":0}},{"line":101,"address":[953995,954041],"length":1,"stats":{"Line":0}},{"line":102,"address":[954068],"length":1,"stats":{"Line":0}},{"line":106,"address":[954013],"length":1,"stats":{"Line":0}},{"line":111,"address":[954480],"length":1,"stats":{"Line":2}},{"line":115,"address":[954531],"length":1,"stats":{"Line":24}},{"line":120,"address":[375375],"length":1,"stats":{"Line":11}},{"line":123,"address":[375462,375382],"length":1,"stats":{"Line":14}},{"line":124,"address":[375503,381359,381023],"length":1,"stats":{"Line":4}},{"line":125,"address":[381246],"length":1,"stats":{"Line":2}},{"line":129,"address":[375468,375550],"length":1,"stats":{"Line":11}},{"line":131,"address":[375588],"length":1,"stats":{"Line":2}},{"line":132,"address":[923270,923746,923447],"length":1,"stats":{"Line":8}},{"line":135,"address":[376232,376709],"length":1,"stats":{"Line":10}},{"line":136,"address":[924318],"length":1,"stats":{"Line":7}},{"line":137,"address":[376759],"length":1,"stats":{"Line":2}},{"line":138,"address":[380605,376791,380360],"length":1,"stats":{"Line":4}},{"line":148,"address":[377091,376894,376981],"length":1,"stats":{"Line":12}},{"line":149,"address":[377113,377194],"length":1,"stats":{"Line":8}},{"line":150,"address":[924699,924656,924747],"length":1,"stats":{"Line":11}},{"line":151,"address":[924780,924764,924721],"length":1,"stats":{"Line":6}},{"line":152,"address":[377282],"length":1,"stats":{"Line":0}},{"line":156,"address":[377327],"length":1,"stats":{"Line":2}},{"line":157,"address":[925071,924905],"length":1,"stats":{"Line":4}},{"line":159,"address":[924866,924960],"length":1,"stats":{"Line":9}},{"line":161,"address":[381616],"length":1,"stats":{"Line":6}},{"line":162,"address":[381634,381676],"length":1,"stats":{"Line":10}},{"line":164,"address":[381696,381673,381726],"length":1,"stats":{"Line":17}},{"line":170,"address":[925215,925080,924992],"length":1,"stats":{"Line":6}},{"line":171,"address":[925270],"length":1,"stats":{"Line":2}},{"line":174,"address":[377910,377790],"length":1,"stats":{"Line":4}},{"line":175,"address":[925488],"length":1,"stats":{"Line":2}},{"line":179,"address":[925648,925739],"length":1,"stats":{"Line":6}},{"line":182,"address":[925803,925778],"length":1,"stats":{"Line":8}},{"line":183,"address":[378324],"length":1,"stats":{"Line":2}},{"line":185,"address":[378306],"length":1,"stats":{"Line":4}},{"line":188,"address":[925823],"length":1,"stats":{"Line":2}},{"line":190,"address":[925863],"length":1,"stats":{"Line":3}},{"line":191,"address":[925949,925880],"length":1,"stats":{"Line":6}},{"line":194,"address":[929280,929296],"length":1,"stats":{"Line":5}},{"line":195,"address":[381856,381878],"length":1,"stats":{"Line":9}},{"line":199,"address":[378415,378633],"length":1,"stats":{"Line":4}},{"line":202,"address":[926098,926183,929504],"length":1,"stats":{"Line":14}},{"line":203,"address":[929525],"length":1,"stats":{"Line":3}},{"line":204,"address":[382172],"length":1,"stats":{"Line":0}},{"line":206,"address":[382051],"length":1,"stats":{"Line":2}},{"line":210,"address":[929776,926309,926229,930523],"length":1,"stats":{"Line":7}},{"line":211,"address":[382310],"length":1,"stats":{"Line":5}},{"line":212,"address":[929897],"length":1,"stats":{"Line":2}},{"line":214,"address":[382327],"length":1,"stats":{"Line":2}},{"line":216,"address":[383089,383056],"length":1,"stats":{"Line":6}},{"line":218,"address":[382619,382713,382378],"length":1,"stats":{"Line":8}},{"line":222,"address":[930130],"length":1,"stats":{"Line":4}},{"line":227,"address":[379003,378915,379420],"length":1,"stats":{"Line":7}},{"line":228,"address":[379138,379081],"length":1,"stats":{"Line":9}},{"line":230,"address":[379108,379364],"length":1,"stats":{"Line":4}},{"line":233,"address":[379880],"length":1,"stats":{"Line":4}},{"line":234,"address":[379337,379463],"length":1,"stats":{"Line":6}},{"line":235,"address":[927051],"length":1,"stats":{"Line":3}},{"line":236,"address":[379646],"length":1,"stats":{"Line":4}},{"line":237,"address":[379657],"length":1,"stats":{"Line":3}},{"line":238,"address":[379697],"length":1,"stats":{"Line":7}},{"line":239,"address":[379737],"length":1,"stats":{"Line":4}},{"line":240,"address":[379809],"length":1,"stats":{"Line":4}},{"line":246,"address":[375813],"length":1,"stats":{"Line":2}}],"covered":79,"coverable":108},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","docs.rs"],"content":"//! Documentation rules\n//!\n//! This module provides rules for checking repository documentation, including:\n//! - README files and their quality\n//! - LICENSE files\n//! - CONTRIBUTING guidelines\n//! - CODE_OF_CONDUCT files\n//! - SECURITY policy files\n\nuse crate::error::RepoLensError;\n\nuse crate::config::Config;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for checking repository documentation\npub struct DocsRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for DocsRules {\n    /// Get the category name\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"docs\"\n    }\n\n    /// Run all documentation-related rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for documentation issues\n    async fn run(\u0026self, scanner: \u0026Scanner, config: \u0026Config) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n        let mut findings = Vec::new();\n\n        // Check README\n        if config.is_rule_enabled(\"docs/readme\") {\n            findings.extend(check_readme(scanner).await?);\n        }\n\n        // Check LICENSE\n        if config.is_rule_enabled(\"docs/license\") {\n            findings.extend(check_license(scanner, config).await?);\n        }\n\n        // Check CONTRIBUTING\n        if config.is_rule_enabled(\"docs/contributing\") {\n            findings.extend(check_contributing(scanner).await?);\n        }\n\n        // Check CODE_OF_CONDUCT\n        if config.is_rule_enabled(\"docs/code-of-conduct\") {\n            findings.extend(check_code_of_conduct(scanner).await?);\n        }\n\n        // Check SECURITY\n        if config.is_rule_enabled(\"docs/security\") {\n            findings.extend(check_security(scanner).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for README file and assess its quality\n///\n/// Verifies README existence and checks for recommended sections like\n/// installation, usage, and license information.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for README issues\nasync fn check_readme(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    let readme_files = [\"README.md\", \"README\", \"README.txt\", \"README.rst\"];\n    let has_readme = readme_files.iter().any(|f| scanner.file_exists(f));\n\n    if !has_readme {\n        findings.push(\n            Finding::new(\n                \"DOC001\",\n                \"docs\",\n                Severity::Warning,\n                \"README file is missing\",\n            )\n            .with_description(\n                \"A README file is essential for explaining what the project does and how to use it.\"\n            )\n            .with_remediation(\n                \"Create a README.md file with project description, installation instructions, and usage examples.\"\n            )\n        );\n        return Ok(findings);\n    }\n\n    // Check README quality\n    if let Ok(content) = scanner.read_file(\"README.md\") {\n        let line_count = content.lines().count();\n\n        if line_count \u003c 10 {\n            findings.push(\n                Finding::new(\n                    \"DOC002\",\n                    \"docs\",\n                    Severity::Warning,\n                    format!(\"README is too short ({} lines)\", line_count),\n                )\n                .with_description(\n                    \"A comprehensive README should include sections for description, installation, usage, and contribution guidelines.\"\n                )\n            );\n        }\n\n        // Check for recommended sections\n        let sections = [\n            (\"installation\", \"Installation instructions\"),\n            (\"usage\", \"Usage examples\"),\n            (\"license\", \"License information\"),\n        ];\n\n        for (keyword, description) in sections {\n            if !content.to_lowercase().contains(keyword) {\n                findings.push(Finding::new(\n                    \"DOC003\",\n                    \"docs\",\n                    Severity::Info,\n                    format!(\"README missing section: {}\", description),\n                ));\n            }\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for LICENSE file\n///\n/// Verifies that a LICENSE file exists. For enterprise preset, LICENSE is optional.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `config` - The configuration (used to check preset)\n///\n/// # Returns\n///\n/// A vector of findings for LICENSE issues\nasync fn check_license(scanner: \u0026Scanner, config: \u0026Config) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    let license_files = [\"LICENSE\", \"LICENSE.md\", \"LICENSE.txt\", \"COPYING\"];\n    let has_license = license_files.iter().any(|f| scanner.file_exists(f));\n\n    // For enterprise preset, LICENSE is optional\n    if config.preset == \"enterprise\" \u0026\u0026 !has_license {\n        return Ok(findings);\n    }\n\n    if !has_license {\n        findings.push(\n            Finding::new(\n                \"DOC004\",\n                \"docs\",\n                Severity::Critical,\n                \"LICENSE file is missing\",\n            )\n            .with_description(\n                \"A LICENSE file is required for open source projects to define how others can use your code.\"\n            )\n            .with_remediation(\n                \"Add a LICENSE file with an appropriate open source license (MIT, Apache-2.0, GPL-3.0, etc.).\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check for CONTRIBUTING file\n///\n/// Verifies that a CONTRIBUTING file exists to guide contributors.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for CONTRIBUTING issues\nasync fn check_contributing(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    let contributing_files = [\"CONTRIBUTING.md\", \"CONTRIBUTING\", \".github/CONTRIBUTING.md\"];\n    let has_contributing = contributing_files.iter().any(|f| scanner.file_exists(f));\n\n    if !has_contributing {\n        findings.push(\n            Finding::new(\n                \"DOC005\",\n                \"docs\",\n                Severity::Warning,\n                \"CONTRIBUTING file is missing\",\n            )\n            .with_description(\n                \"A CONTRIBUTING file helps potential contributors understand how to participate in your project.\"\n            )\n            .with_remediation(\n                \"Create a CONTRIBUTING.md file with contribution guidelines, code style, and pull request process.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check for CODE_OF_CONDUCT file\n///\n/// Verifies that a CODE_OF_CONDUCT file exists to establish community standards.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for CODE_OF_CONDUCT issues\nasync fn check_code_of_conduct(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    let coc_files = [\n        \"CODE_OF_CONDUCT.md\",\n        \"CODE_OF_CONDUCT\",\n        \".github/CODE_OF_CONDUCT.md\",\n    ];\n    let has_coc = coc_files.iter().any(|f| scanner.file_exists(f));\n\n    if !has_coc {\n        findings.push(\n            Finding::new(\n                \"DOC006\",\n                \"docs\",\n                Severity::Warning,\n                \"CODE_OF_CONDUCT file is missing\",\n            )\n            .with_description(\n                \"A Code of Conduct establishes expectations for behavior and helps create a welcoming community.\"\n            )\n            .with_remediation(\n                \"Add a CODE_OF_CONDUCT.md file. Consider using the Contributor Covenant as a starting point.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check for SECURITY policy file\n///\n/// Verifies that a SECURITY.md file exists for reporting vulnerabilities.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for SECURITY policy issues\nasync fn check_security(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    let security_files = [\"SECURITY.md\", \".github/SECURITY.md\"];\n    let has_security = security_files.iter().any(|f| scanner.file_exists(f));\n\n    if !has_security {\n        findings.push(\n            Finding::new(\n                \"DOC007\",\n                \"docs\",\n                Severity::Warning,\n                \"SECURITY policy file is missing\",\n            )\n            .with_description(\n                \"A SECURITY.md file tells users how to report security vulnerabilities responsibly.\"\n            )\n            .with_remediation(\n                \"Create a SECURITY.md file with instructions for reporting security issues.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::Config;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_readme_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_readme(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC001\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_readme_too_short() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let readme = root.join(\"README.md\");\n\n        fs::write(\u0026readme, \"# Test\\n\\nShort.\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_readme(\u0026scanner).await.unwrap();\n\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC002\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_readme_missing_sections() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let readme = root.join(\"README.md\");\n\n        fs::write(\u0026readme, \"# Project\\n\\nDescription here.\\n\\nMore content.\\n\\nEven more.\\n\\nAnd more.\\n\\nAnd more.\\n\\nAnd more.\\n\\nAnd more.\\n\\nAnd more.\\n\\nAnd more.\\n\\nAnd more.\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_readme(\u0026scanner).await.unwrap();\n\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC003\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_license_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config::default();\n        let findings = check_license(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC004\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_license_enterprise_optional() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config {\n            preset: \"enterprise\".to_string(),\n            ..Default::default()\n        };\n        let findings = check_license(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(findings.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_check_contributing_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_contributing(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC005\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_code_of_conduct_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_code_of_conduct(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC006\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_security_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_security(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC007\"));\n    }\n}\n","traces":[{"line":23,"address":[349328],"length":1,"stats":{"Line":2}},{"line":37,"address":[523492,523228,523408,524368,526026,523104,523139,523752],"length":1,"stats":{"Line":18}},{"line":38,"address":[523508],"length":1,"stats":{"Line":3}},{"line":41,"address":[523524,523598],"length":1,"stats":{"Line":6}},{"line":42,"address":[284114,284031],"length":1,"stats":{"Line":3}},{"line":46,"address":[523604,524177],"length":1,"stats":{"Line":6}},{"line":47,"address":[615870,616012],"length":1,"stats":{"Line":3}},{"line":51,"address":[524183,524773],"length":1,"stats":{"Line":6}},{"line":52,"address":[616052,615888],"length":1,"stats":{"Line":2}},{"line":56,"address":[524779,525331],"length":1,"stats":{"Line":7}},{"line":57,"address":[525490,525372,523309,526144],"length":1,"stats":{"Line":3}},{"line":61,"address":[525889,525337],"length":1,"stats":{"Line":6}},{"line":62,"address":[29583,32287,32405],"length":1,"stats":{"Line":2}},{"line":65,"address":[525899],"length":1,"stats":{"Line":4}},{"line":81,"address":[1504360,1504352],"length":1,"stats":{"Line":12}},{"line":82,"address":[517085],"length":1,"stats":{"Line":2}},{"line":84,"address":[517161],"length":1,"stats":{"Line":4}},{"line":85,"address":[517269,519728,517361,519745],"length":1,"stats":{"Line":11}},{"line":87,"address":[517412],"length":1,"stats":{"Line":3}},{"line":88,"address":[517602],"length":1,"stats":{"Line":2}},{"line":89,"address":[517532,517424],"length":1,"stats":{"Line":4}},{"line":92,"address":[517416],"length":1,"stats":{"Line":2}},{"line":102,"address":[517632],"length":1,"stats":{"Line":2}},{"line":106,"address":[517502,517829,517920],"length":1,"stats":{"Line":7}},{"line":107,"address":[518047,517968],"length":1,"stats":{"Line":6}},{"line":109,"address":[518091],"length":1,"stats":{"Line":4}},{"line":110,"address":[518719],"length":1,"stats":{"Line":2}},{"line":111,"address":[518621],"length":1,"stats":{"Line":2}},{"line":114,"address":[518486],"length":1,"stats":{"Line":2}},{"line":115,"address":[518494],"length":1,"stats":{"Line":2}},{"line":124,"address":[518268],"length":1,"stats":{"Line":2}},{"line":125,"address":[518106],"length":1,"stats":{"Line":2}},{"line":126,"address":[518160],"length":1,"stats":{"Line":2}},{"line":127,"address":[518214],"length":1,"stats":{"Line":2}},{"line":130,"address":[518843,518364,518754],"length":1,"stats":{"Line":6}},{"line":131,"address":[519086,518956],"length":1,"stats":{"Line":5}},{"line":132,"address":[25651],"length":1,"stats":{"Line":3}},{"line":135,"address":[25516],"length":1,"stats":{"Line":3}},{"line":136,"address":[25524],"length":1,"stats":{"Line":3}},{"line":142,"address":[25814],"length":1,"stats":{"Line":3}},{"line":157,"address":[519776,520682,519895,519806,519917],"length":1,"stats":{"Line":13}},{"line":158,"address":[519888],"length":1,"stats":{"Line":3}},{"line":160,"address":[26217],"length":1,"stats":{"Line":3}},{"line":161,"address":[520146,520720,520063,520737],"length":1,"stats":{"Line":10}},{"line":164,"address":[26504,26455],"length":1,"stats":{"Line":5}},{"line":165,"address":[520254],"length":1,"stats":{"Line":2}},{"line":168,"address":[520231],"length":1,"stats":{"Line":2}},{"line":169,"address":[520650],"length":1,"stats":{"Line":2}},{"line":170,"address":[26662,26836],"length":1,"stats":{"Line":4}},{"line":173,"address":[520398],"length":1,"stats":{"Line":2}},{"line":185,"address":[520476],"length":1,"stats":{"Line":2}},{"line":199,"address":[349280,349288],"length":1,"stats":{"Line":8}},{"line":200,"address":[520858],"length":1,"stats":{"Line":2}},{"line":202,"address":[520931],"length":1,"stats":{"Line":2}},{"line":203,"address":[521006,521521,521504,521089],"length":1,"stats":{"Line":8}},{"line":205,"address":[27396],"length":1,"stats":{"Line":2}},{"line":206,"address":[521439],"length":1,"stats":{"Line":2}},{"line":207,"address":[27625,27408],"length":1,"stats":{"Line":4}},{"line":210,"address":[521144],"length":1,"stats":{"Line":2}},{"line":222,"address":[27486],"length":1,"stats":{"Line":2}},{"line":236,"address":[1504416,1504424],"length":1,"stats":{"Line":8}},{"line":237,"address":[521642],"length":1,"stats":{"Line":2}},{"line":239,"address":[27971],"length":1,"stats":{"Line":2}},{"line":244,"address":[522288,522305,521873,521790],"length":1,"stats":{"Line":8}},{"line":246,"address":[28180],"length":1,"stats":{"Line":2}},{"line":247,"address":[522223],"length":1,"stats":{"Line":2}},{"line":248,"address":[521936,522153],"length":1,"stats":{"Line":4}},{"line":251,"address":[521928],"length":1,"stats":{"Line":2}},{"line":263,"address":[522014],"length":1,"stats":{"Line":2}},{"line":277,"address":[28689,29268,28711,28622,28592],"length":1,"stats":{"Line":8}},{"line":278,"address":[522426],"length":1,"stats":{"Line":2}},{"line":280,"address":[522499],"length":1,"stats":{"Line":2}},{"line":281,"address":[523056,523073,522630,522547],"length":1,"stats":{"Line":8}},{"line":283,"address":[522681],"length":1,"stats":{"Line":2}},{"line":284,"address":[522980],"length":1,"stats":{"Line":2}},{"line":285,"address":[522910,522693],"length":1,"stats":{"Line":4}},{"line":288,"address":[522685],"length":1,"stats":{"Line":2}},{"line":300,"address":[522771],"length":1,"stats":{"Line":2}}],"covered":78,"coverable":78},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","files.rs"],"content":"//! File-related rules\n//!\n//! This module provides rules for checking repository files, including:\n//! - Large files that should use Git LFS\n//! - .gitignore configuration and recommended entries\n//! - Temporary files that shouldn't be committed\n\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for checking repository files\npub struct FilesRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for FilesRules {\n    /// Get the category name\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"files\"\n    }\n\n    /// Run all file-related rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for file-related issues\n    async fn run(\u0026self, scanner: \u0026Scanner, config: \u0026Config) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n        let mut findings = Vec::new();\n\n        // Check for large files\n        if config.is_rule_enabled(\"files/large\") {\n            findings.extend(check_large_files(scanner).await?);\n        }\n\n        // Check .gitignore\n        if config.is_rule_enabled(\"files/gitignore\") {\n            findings.extend(check_gitignore(scanner).await?);\n        }\n\n        // Check for temporary files\n        if config.is_rule_enabled(\"files/temp\") {\n            findings.extend(check_temp_files(scanner).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for files larger than the recommended threshold\n///\n/// Large files can slow down repository operations and should use Git LFS.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for large files\nasync fn check_large_files(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // 10MB threshold\n    const LARGE_FILE_THRESHOLD: u64 = 10 * 1024 * 1024;\n\n    for file in scanner.files_larger_than(LARGE_FILE_THRESHOLD) {\n        let size_mb = file.size as f64 / 1024.0 / 1024.0;\n\n        findings.push(\n            Finding::new(\n                \"FILE001\",\n                \"files\",\n                Severity::Warning,\n                format!(\"Large file detected ({:.1} MB)\", size_mb),\n            )\n            .with_location(\u0026file.path)\n            .with_description(\n                \"Large files can slow down repository operations and increase clone times.\",\n            )\n            .with_remediation(\n                \"Consider using Git LFS (Large File Storage) for binary or large files.\",\n            ),\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check .gitignore file existence and recommended entries\n///\n/// Verifies that .gitignore exists and contains recommended patterns\n/// to prevent committing unwanted files.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for .gitignore issues\nasync fn check_gitignore(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // Check if .gitignore exists\n    if !scanner.file_exists(\".gitignore\") {\n        findings.push(\n            Finding::new(\n                \"FILE002\",\n                \"files\",\n                Severity::Warning,\n                \".gitignore file is missing\",\n            )\n            .with_description(\n                \"A .gitignore file helps prevent accidentally committing unwanted files.\",\n            )\n            .with_remediation(\n                \"Create a .gitignore file with appropriate patterns for your project type.\",\n            ),\n        );\n        return Ok(findings);\n    }\n\n    // Check for recommended entries\n    let gitignore_content = scanner.read_file(\".gitignore\").unwrap_or_else(|e| {\n        tracing::warn!(\"Failed to read .gitignore: {}\", e);\n        String::new()\n    });\n    let recommended_entries = [\n        (\".env\", \"Environment files\"),\n        (\"*.key\", \"Private keys\"),\n        (\"*.pem\", \"Certificates\"),\n        (\"node_modules\", \"Node.js dependencies\"),\n        (\".DS_Store\", \"macOS metadata\"),\n    ];\n\n    for (pattern, description) in recommended_entries {\n        if !gitignore_content.contains(pattern) {\n            findings.push(\n                Finding::new(\n                    \"FILE003\",\n                    \"files\",\n                    Severity::Info,\n                    format!(\".gitignore missing recommended entry: {}\", pattern),\n                )\n                .with_description(format!(\n                    \"Adding '{}' to .gitignore helps prevent committing {}.\",\n                    pattern,\n                    description.to_lowercase()\n                )),\n            );\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for temporary files that shouldn't be committed\n///\n/// Detects common temporary file patterns like .log, .tmp, .swp, etc.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for temporary files\nasync fn check_temp_files(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    let temp_patterns = [\"*.log\", \"*.tmp\", \"*.temp\", \"*~\", \"*.swp\", \"*.swo\", \"*.bak\"];\n\n    for pattern in temp_patterns {\n        for file in scanner.files_matching_pattern(pattern) {\n            findings.push(\n                Finding::new(\n                    \"FILE004\",\n                    \"files\",\n                    Severity::Warning,\n                    \"Temporary file found in repository\",\n                )\n                .with_location(\u0026file.path)\n                .with_description(\"Temporary files should not be committed to version control.\")\n                .with_remediation(\"Remove the file and add the pattern to .gitignore.\"),\n            );\n        }\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_large_files_detects_large_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let large_file = root.join(\"large.bin\");\n\n        let large_content = vec![0u8; 11 * 1024 * 1024];\n        fs::write(\u0026large_file, large_content).unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_large_files(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"FILE001\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_gitignore_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_gitignore(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"FILE002\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_gitignore_missing_recommended_entries() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let gitignore = root.join(\".gitignore\");\n\n        fs::write(\u0026gitignore, \"node_modules/\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_gitignore(\u0026scanner).await.unwrap();\n\n        assert!(findings.iter().any(|f| f.rule_id == \"FILE003\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_temp_files_detects_tmp() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let tmp_file = root.join(\"temp.tmp\");\n\n        fs::write(\u0026tmp_file, \"temporary content\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_temp_files(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"FILE004\"));\n    }\n}\n","traces":[{"line":20,"address":[1571536],"length":1,"stats":{"Line":2}},{"line":34,"address":[857777,858377,857203,857168,857517,858919,857433,857289],"length":1,"stats":{"Line":14}},{"line":35,"address":[857533],"length":1,"stats":{"Line":2}},{"line":38,"address":[857549,857623],"length":1,"stats":{"Line":4}},{"line":39,"address":[857316,858356,857803,857664],"length":1,"stats":{"Line":2}},{"line":43,"address":[857629,858202],"length":1,"stats":{"Line":4}},{"line":44,"address":[356099,356239,355190,356893],"length":1,"stats":{"Line":2}},{"line":48,"address":[858782,858208],"length":1,"stats":{"Line":4}},{"line":49,"address":[355208,356780,356898],"length":1,"stats":{"Line":3}},{"line":52,"address":[858792],"length":1,"stats":{"Line":2}},{"line":67,"address":[349639,349520,349550,350643,349617],"length":1,"stats":{"Line":8}},{"line":68,"address":[851754],"length":1,"stats":{"Line":2}},{"line":73,"address":[851899,851845,852023],"length":1,"stats":{"Line":6}},{"line":74,"address":[852083],"length":1,"stats":{"Line":2}},{"line":76,"address":[852755],"length":1,"stats":{"Line":2}},{"line":77,"address":[852594],"length":1,"stats":{"Line":2}},{"line":80,"address":[852147],"length":1,"stats":{"Line":2}},{"line":81,"address":[852155,852344],"length":1,"stats":{"Line":4}},{"line":93,"address":[350061],"length":1,"stats":{"Line":2}},{"line":108,"address":[395168,395176],"length":1,"stats":{"Line":8}},{"line":109,"address":[852938],"length":1,"stats":{"Line":2}},{"line":112,"address":[853097,853024],"length":1,"stats":{"Line":5}},{"line":113,"address":[853286],"length":1,"stats":{"Line":2}},{"line":114,"address":[853216,853111],"length":1,"stats":{"Line":4}},{"line":117,"address":[853103],"length":1,"stats":{"Line":2}},{"line":127,"address":[853313],"length":1,"stats":{"Line":2}},{"line":131,"address":[855790,853476,853186,855200,855784],"length":1,"stats":{"Line":4}},{"line":132,"address":[855499,855222,855292],"length":1,"stats":{"Line":0}},{"line":133,"address":[855489],"length":1,"stats":{"Line":0}},{"line":135,"address":[853776],"length":1,"stats":{"Line":2}},{"line":136,"address":[351362],"length":1,"stats":{"Line":2}},{"line":137,"address":[853560],"length":1,"stats":{"Line":2}},{"line":138,"address":[853614],"length":1,"stats":{"Line":2}},{"line":139,"address":[853668],"length":1,"stats":{"Line":2}},{"line":140,"address":[351578],"length":1,"stats":{"Line":2}},{"line":143,"address":[853969,854035,854121],"length":1,"stats":{"Line":6}},{"line":144,"address":[352248,352090],"length":1,"stats":{"Line":4}},{"line":145,"address":[855101],"length":1,"stats":{"Line":2}},{"line":146,"address":[352463,352910],"length":1,"stats":{"Line":4}},{"line":149,"address":[854437],"length":1,"stats":{"Line":2}},{"line":150,"address":[854445,854507],"length":1,"stats":{"Line":4}},{"line":152,"address":[854775,854678],"length":1,"stats":{"Line":4}},{"line":155,"address":[352612],"length":1,"stats":{"Line":2}},{"line":161,"address":[854269],"length":1,"stats":{"Line":2}},{"line":175,"address":[353694,353783,353664,353761,354979],"length":1,"stats":{"Line":8}},{"line":176,"address":[353754],"length":1,"stats":{"Line":2}},{"line":178,"address":[855971],"length":1,"stats":{"Line":2}},{"line":180,"address":[856326,856157,856424],"length":1,"stats":{"Line":6}},{"line":181,"address":[856516,856837,856701],"length":1,"stats":{"Line":6}},{"line":182,"address":[857091],"length":1,"stats":{"Line":2}},{"line":183,"address":[856905,857014],"length":1,"stats":{"Line":4}},{"line":186,"address":[856897],"length":1,"stats":{"Line":2}},{"line":196,"address":[856546],"length":1,"stats":{"Line":2}}],"covered":51,"coverable":53},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","mod.rs"],"content":"//! Rule categories\n\npub mod custom;\npub mod docs;\npub mod files;\npub mod quality;\npub mod secrets;\npub mod security;\npub mod workflows;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","quality.rs"],"content":"//! Code quality rules\n//!\n//! This module provides rules for checking code quality aspects, including:\n//! - Test files and directories\n//! - Linting configuration\n//! - Editor configuration files\n\nuse crate::error::RepoLensError;\n\nuse crate::config::Config;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for checking code quality\npub struct QualityRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for QualityRules {\n    /// Get the category name\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"quality\"\n    }\n\n    /// Run all quality-related rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for quality issues\n    async fn run(\u0026self, scanner: \u0026Scanner, config: \u0026Config) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n        let mut findings = Vec::new();\n\n        // Check for tests\n        if config.is_rule_enabled(\"quality/tests\") {\n            findings.extend(check_tests(scanner).await?);\n        }\n\n        // Check for linting configuration\n        if config.is_rule_enabled(\"quality/linting\") {\n            findings.extend(check_linting(scanner).await?);\n        }\n\n        // Check for editor configuration\n        if config.is_rule_enabled(\"files/editorconfig\") {\n            findings.extend(check_editorconfig(scanner).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for test files and test configuration\n///\n/// Verifies that the repository has tests and appropriate test configuration.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for test-related issues\nasync fn check_tests(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // Check for test directories\n    let test_dirs = [\"test\", \"tests\", \"__tests__\", \"spec\", \"specs\"];\n    let has_test_dir = test_dirs.iter().any(|d| scanner.directory_exists(d));\n\n    // Check for test files\n    let test_file_patterns = [\"*.test.*\", \"*.spec.*\", \"*_test.*\", \"*Test.*\"];\n    let has_test_files = test_file_patterns\n        .iter()\n        .any(|p| !scanner.files_matching_pattern(p).is_empty());\n\n    if !has_test_dir \u0026\u0026 !has_test_files {\n        findings.push(\n            Finding::new(\n                \"QUALITY001\",\n                \"quality\",\n                Severity::Info,\n                \"No tests detected\",\n            )\n            .with_description(\n                \"Tests are important for ensuring code quality and catching regressions.\"\n            )\n            .with_remediation(\n                \"Add tests to your project. Consider using a testing framework appropriate for your language.\"\n            )\n        );\n    }\n\n    // Check if package.json has test script\n    if scanner.file_exists(\"package.json\") {\n        if let Ok(content) = scanner.read_file(\"package.json\") {\n            if !content.contains(r#\"\"test\"\"#) || content.contains(r#\"\"test\": \"echo\"#) {\n                findings.push(\n                    Finding::new(\n                        \"QUALITY002\",\n                        \"quality\",\n                        Severity::Info,\n                        \"No test script defined in package.json\",\n                    )\n                    .with_description(\n                        \"A 'test' script in package.json enables running tests with 'npm test'.\",\n                    ),\n                );\n            }\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for linting configuration files\n///\n/// Verifies that appropriate linting tools are configured based on\n/// the project type (JavaScript, Python, Ruby, Go, Rust, etc.).\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for missing linting configuration\nasync fn check_linting(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // Linting config files by language/tool\n    let linting_configs = [\n        // JavaScript/TypeScript\n        (\".eslintrc\", \"ESLint\"),\n        (\".eslintrc.js\", \"ESLint\"),\n        (\".eslintrc.json\", \"ESLint\"),\n        (\".eslintrc.yml\", \"ESLint\"),\n        (\"eslint.config.js\", \"ESLint\"),\n        (\"biome.json\", \"Biome\"),\n        // Formatting\n        (\".prettierrc\", \"Prettier\"),\n        (\".prettierrc.js\", \"Prettier\"),\n        (\".prettierrc.json\", \"Prettier\"),\n        // Python\n        (\"pyproject.toml\", \"Python tooling\"),\n        (\".flake8\", \"Flake8\"),\n        (\"setup.cfg\", \"Python tooling\"),\n        (\".pylintrc\", \"Pylint\"),\n        (\"ruff.toml\", \"Ruff\"),\n        // Ruby\n        (\".rubocop.yml\", \"RuboCop\"),\n        // Go\n        (\".golangci.yml\", \"golangci-lint\"),\n        (\".golangci.yaml\", \"golangci-lint\"),\n        // Rust\n        (\"rustfmt.toml\", \"rustfmt\"),\n        (\".rustfmt.toml\", \"rustfmt\"),\n        (\"clippy.toml\", \"Clippy\"),\n    ];\n\n    // Detect project type\n    let is_js_project = scanner.file_exists(\"package.json\");\n    let is_python_project =\n        scanner.file_exists(\"pyproject.toml\") || scanner.file_exists(\"requirements.txt\");\n    let is_ruby_project = scanner.file_exists(\"Gemfile\");\n    let is_go_project = scanner.file_exists(\"go.mod\");\n    let is_rust_project = scanner.file_exists(\"Cargo.toml\");\n\n    let has_linting = linting_configs.iter().any(|(f, _)| scanner.file_exists(f));\n\n    if !has_linting\n        \u0026\u0026 (is_js_project\n            || is_python_project\n            || is_ruby_project\n            || is_go_project\n            || is_rust_project)\n    {\n        let suggestion = if is_js_project {\n            \"ESLint for linting and Prettier for formatting\"\n        } else if is_python_project {\n            \"Ruff or Flake8 for linting\"\n        } else if is_ruby_project {\n            \"RuboCop for linting\"\n        } else if is_go_project {\n            \"golangci-lint for linting\"\n        } else {\n            \"Clippy for linting and rustfmt for formatting\"\n        };\n\n        findings.push(\n            Finding::new(\n                \"QUALITY003\",\n                \"quality\",\n                Severity::Info,\n                \"No linting configuration detected\",\n            )\n            .with_description(\n                \"Linting tools help maintain consistent code style and catch potential issues.\",\n            )\n            .with_remediation(format!(\"Consider adding {} to your project.\", suggestion)),\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check for .editorconfig file\n///\n/// Verifies that an .editorconfig file exists to maintain consistent\n/// coding styles across editors and IDEs.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for missing .editorconfig\nasync fn check_editorconfig(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    if !scanner.file_exists(\".editorconfig\") {\n        findings.push(\n            Finding::new(\n                \"QUALITY004\",\n                \"quality\",\n                Severity::Info,\n                \".editorconfig file is missing\",\n            )\n            .with_description(\n                \"EditorConfig helps maintain consistent coding styles across different editors and IDEs.\"\n            )\n            .with_remediation(\n                \"Create a .editorconfig file to define coding style preferences.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_tests_no_tests_detected() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_tests(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"QUALITY001\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_tests_package_json_no_test_script() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let package_json = root.join(\"package.json\");\n\n        // Create package.json without test script or with echo test\n        fs::write(\n            \u0026package_json,\n            r#\"{\"name\": \"test\", \"version\": \"1.0.0\", \"scripts\": {\"test\": \"echo \\\"No tests\\\"\"}}\"#,\n        )\n        .unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_tests(\u0026scanner).await.unwrap();\n\n        // Should find QUALITY002 because test script is just \"echo\"\n        assert!(findings.iter().any(|f| f.rule_id == \"QUALITY002\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_linting_no_config() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let package_json = root.join(\"package.json\");\n\n        fs::write(\u0026package_json, r#\"{\"name\": \"test\"}\"#).unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_linting(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"QUALITY003\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_editorconfig_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_editorconfig(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"QUALITY004\"));\n    }\n}\n","traces":[{"line":21,"address":[1188256],"length":1,"stats":{"Line":2}},{"line":35,"address":[1081523],"length":1,"stats":{"Line":18}},{"line":36,"address":[112461],"length":1,"stats":{"Line":3}},{"line":39,"address":[112551,112477],"length":1,"stats":{"Line":6}},{"line":40,"address":[112592,112244,112731,113284],"length":1,"stats":{"Line":3}},{"line":44,"address":[112557,113130],"length":1,"stats":{"Line":6}},{"line":45,"address":[113311,112262,113171,113965],"length":1,"stats":{"Line":3}},{"line":49,"address":[113710,113136],"length":1,"stats":{"Line":6}},{"line":50,"address":[113852,113970,112280],"length":1,"stats":{"Line":2}},{"line":53,"address":[113720],"length":1,"stats":{"Line":4}},{"line":68,"address":[993424,993553,993463,995128,995217,993575],"length":1,"stats":{"Line":13}},{"line":69,"address":[106394],"length":1,"stats":{"Line":3}},{"line":72,"address":[106470],"length":1,"stats":{"Line":2}},{"line":73,"address":[106694,106605,108096,108113],"length":1,"stats":{"Line":11}},{"line":76,"address":[993894],"length":1,"stats":{"Line":3}},{"line":77,"address":[106850],"length":1,"stats":{"Line":3}},{"line":79,"address":[108161,108144],"length":1,"stats":{"Line":6}},{"line":81,"address":[994104],"length":1,"stats":{"Line":2}},{"line":82,"address":[107145],"length":1,"stats":{"Line":2}},{"line":83,"address":[107005],"length":1,"stats":{"Line":2}},{"line":86,"address":[106997],"length":1,"stats":{"Line":2}},{"line":99,"address":[106971,107184,108041],"length":1,"stats":{"Line":6}},{"line":100,"address":[107361,107514,107423],"length":1,"stats":{"Line":6}},{"line":101,"address":[107756,107562,107633],"length":1,"stats":{"Line":6}},{"line":102,"address":[107881],"length":1,"stats":{"Line":2}},{"line":103,"address":[107846,107678],"length":1,"stats":{"Line":4}},{"line":106,"address":[107670],"length":1,"stats":{"Line":2}},{"line":117,"address":[107202],"length":1,"stats":{"Line":2}},{"line":132,"address":[995440,995470,995545,995567,998561],"length":1,"stats":{"Line":8}},{"line":133,"address":[108386],"length":1,"stats":{"Line":2}},{"line":136,"address":[109481],"length":1,"stats":{"Line":2}},{"line":138,"address":[108464],"length":1,"stats":{"Line":2}},{"line":139,"address":[108518],"length":1,"stats":{"Line":2}},{"line":140,"address":[108565],"length":1,"stats":{"Line":2}},{"line":141,"address":[108612],"length":1,"stats":{"Line":2}},{"line":142,"address":[108659],"length":1,"stats":{"Line":2}},{"line":143,"address":[108706],"length":1,"stats":{"Line":2}},{"line":145,"address":[995912],"length":1,"stats":{"Line":2}},{"line":146,"address":[995966],"length":1,"stats":{"Line":2}},{"line":147,"address":[996013],"length":1,"stats":{"Line":2}},{"line":149,"address":[996060],"length":1,"stats":{"Line":2}},{"line":150,"address":[108962],"length":1,"stats":{"Line":2}},{"line":151,"address":[996168],"length":1,"stats":{"Line":2}},{"line":152,"address":[109063],"length":1,"stats":{"Line":2}},{"line":153,"address":[996269],"length":1,"stats":{"Line":2}},{"line":155,"address":[109171],"length":1,"stats":{"Line":2}},{"line":157,"address":[109225],"length":1,"stats":{"Line":2}},{"line":158,"address":[109279],"length":1,"stats":{"Line":2}},{"line":160,"address":[109326],"length":1,"stats":{"Line":2}},{"line":161,"address":[109380],"length":1,"stats":{"Line":2}},{"line":162,"address":[996579],"length":1,"stats":{"Line":2}},{"line":166,"address":[110118,110187],"length":1,"stats":{"Line":4}},{"line":167,"address":[997348],"length":1,"stats":{"Line":2}},{"line":169,"address":[110285],"length":1,"stats":{"Line":2}},{"line":170,"address":[997478],"length":1,"stats":{"Line":2}},{"line":171,"address":[997519],"length":1,"stats":{"Line":2}},{"line":173,"address":[111472,110413,111456],"length":1,"stats":{"Line":6}},{"line":175,"address":[110496],"length":1,"stats":{"Line":2}},{"line":176,"address":[997656],"length":1,"stats":{"Line":2}},{"line":177,"address":[110661],"length":1,"stats":{"Line":3}},{"line":178,"address":[997837],"length":1,"stats":{"Line":4}},{"line":179,"address":[110695],"length":1,"stats":{"Line":2}},{"line":180,"address":[110705],"length":1,"stats":{"Line":4}},{"line":182,"address":[110675,110753],"length":1,"stats":{"Line":4}},{"line":183,"address":[997878],"length":1,"stats":{"Line":2}},{"line":184,"address":[997947,998111,997866],"length":1,"stats":{"Line":0}},{"line":185,"address":[997920],"length":1,"stats":{"Line":0}},{"line":186,"address":[110837,110762,110927],"length":1,"stats":{"Line":0}},{"line":187,"address":[997962],"length":1,"stats":{"Line":0}},{"line":188,"address":[110804,110866,110895],"length":1,"stats":{"Line":0}},{"line":189,"address":[110868],"length":1,"stats":{"Line":0}},{"line":191,"address":[110839],"length":1,"stats":{"Line":0}},{"line":194,"address":[111359],"length":1,"stats":{"Line":2}},{"line":195,"address":[111104,110999,111312],"length":1,"stats":{"Line":6}},{"line":198,"address":[998143],"length":1,"stats":{"Line":2}},{"line":204,"address":[111399,111069,111351,111174,111147],"length":1,"stats":{"Line":4}},{"line":208,"address":[110522],"length":1,"stats":{"Line":2}},{"line":223,"address":[1188240,1188248],"length":1,"stats":{"Line":8}},{"line":224,"address":[111594],"length":1,"stats":{"Line":2}},{"line":226,"address":[111672,111733],"length":1,"stats":{"Line":4}},{"line":227,"address":[112031],"length":1,"stats":{"Line":2}},{"line":228,"address":[111747,111964],"length":1,"stats":{"Line":4}},{"line":231,"address":[111739],"length":1,"stats":{"Line":2}},{"line":243,"address":[111825],"length":1,"stats":{"Line":2}}],"covered":77,"coverable":84},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","secrets.rs"],"content":"//! Secrets detection rules\n//!\n//! This module provides rules for detecting exposed secrets and credentials\n//! in repository files. It checks for:\n//! - Hardcoded secrets in source files (API keys, tokens, passwords)\n//! - Sensitive files (private keys, certificates, credentials)\n//! - Environment files (.env) that should not be committed\n\nuse rayon::prelude::*;\n\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::patterns::SECRET_PATTERNS;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for detecting secrets and credentials\npub struct SecretsRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for SecretsRules {\n    /// Get the category name\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"secrets\"\n    }\n\n    /// Run all secrets detection rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for detected secrets\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the scan fails\n    async fn run(\u0026self, scanner: \u0026Scanner, config: \u0026Config) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n        let mut findings = Vec::new();\n\n        // Check for hardcoded secrets in source files\n        if config.is_rule_enabled(\"secrets/hardcoded\") {\n            findings.extend(check_hardcoded_secrets(scanner, config).await?);\n        }\n\n        // Check for sensitive files\n        if config.is_rule_enabled(\"secrets/files\") {\n            findings.extend(check_sensitive_files(scanner, config).await?);\n        }\n\n        // Check for .env files\n        if config.is_rule_enabled(\"secrets/env\") {\n            findings.extend(check_env_files(scanner, config).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for hardcoded secrets in source files\n///\n/// Scans files with common source code extensions for patterns that indicate\n/// hardcoded secrets like API keys, tokens, and passwords.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `config` - The configuration with ignore patterns\n///\n/// # Returns\n///\n/// A vector of findings for detected secrets\nasync fn check_hardcoded_secrets(\n    scanner: \u0026Scanner,\n    config: \u0026Config,\n) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // File extensions to scan\n    let extensions = [\n        \"js\", \"ts\", \"jsx\", \"tsx\", \"py\", \"rb\", \"php\", \"java\", \"go\", \"rs\", \"cpp\", \"c\", \"yml\", \"yaml\",\n        \"json\", \"toml\", \"env\", \"config\", \"conf\", \"sql\", \"sh\", \"bash\",\n    ];\n\n    let files: Vec\u003c_\u003e = scanner\n        .files_with_extensions(\u0026extensions)\n        .into_iter()\n        .filter(|file| !config.should_ignore_file(\u0026file.path))\n        .map(|file| file.path.clone())\n        .collect();\n\n    // Process files in parallel\n    let file_findings: Vec\u003cVec\u003cFinding\u003e\u003e = files\n        .par_iter()\n        .filter_map(|file_path| {\n            let content = match scanner.read_file(file_path) {\n                Ok(c) =\u003e c,\n                Err(e) =\u003e {\n                    tracing::warn!(\"Failed to read file {}: {}\", file_path, e);\n                    return None;\n                }\n            };\n\n            match check_file_for_secrets(file_path, \u0026content, config) {\n                Ok(f) =\u003e Some(f),\n                Err(e) =\u003e {\n                    tracing::warn!(\"Error checking file {}: {}\", file_path, e);\n                    None\n                }\n            }\n        })\n        .collect();\n\n    // Flatten results\n    for file_finding in file_findings {\n        findings.extend(file_finding);\n    }\n\n    Ok(findings)\n}\n\n/// Check a single file for secrets\n///\n/// # Arguments\n///\n/// * `file_path` - Path to the file\n/// * `content` - File content\n/// * `config` - Configuration with ignore patterns\n///\n/// # Returns\n///\n/// A vector of findings for secrets found in this file\nfn check_file_for_secrets(\n    file_path: \u0026str,\n    content: \u0026str,\n    config: \u0026Config,\n) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    for pattern in SECRET_PATTERNS.iter() {\n        if let Some(captures) = pattern.regex.captures(content) {\n            if config.should_ignore_pattern(file_path) {\n                continue;\n            }\n\n            let line_num = find_line_number(content, \u0026captures)?;\n\n            findings.push(\n                Finding::new(\n                    \"SEC001\",\n                    \"secrets\",\n                    Severity::Critical,\n                    format!(\"{} detected\", pattern.name),\n                )\n                .with_location(format!(\"{}:{}\", file_path, line_num))\n                .with_description(pattern.description.to_string())\n                .with_remediation(\n                    \"Remove the secret and use environment variables or a secrets manager instead.\",\n                ),\n            );\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Find the line number where a regex match occurs\n///\n/// # Arguments\n///\n/// * `content` - File content\n/// * `captures` - Regex captures from the match\n///\n/// # Returns\n///\n/// The line number (1-indexed)\nfn find_line_number(content: \u0026str, captures: \u0026regex::Captures) -\u003e Result\u003cusize, RepoLensError\u003e {\n    let match_start = captures\n        .get(0)\n        .ok_or_else(|| {\n            RepoLensError::Rule(crate::error::RuleError::ExecutionFailed {\n                message: \"No match found in pattern capture\".to_string(),\n            })\n        })?\n        .start();\n\n    Ok(content[..match_start].matches('\\n').count() + 1)\n}\n\n/// Check for sensitive files that should not be in version control\n///\n/// Detects files like private keys, certificates, and credential files\n/// that pose a security risk if committed to the repository.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `_config` - The configuration (currently unused)\n///\n/// # Returns\n///\n/// A vector of findings for detected sensitive files\nasync fn check_sensitive_files(\n    scanner: \u0026Scanner,\n    _config: \u0026Config,\n) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // List of sensitive file patterns\n    let sensitive_patterns = [\n        (\"*.pem\", \"Private key file\"),\n        (\"*.key\", \"Private key file\"),\n        (\"*.p12\", \"PKCS#12 certificate bundle\"),\n        (\"*.pfx\", \"PKCS#12 certificate bundle\"),\n        (\"*.jks\", \"Java keystore\"),\n        (\"id_rsa\", \"SSH private key\"),\n        (\"id_dsa\", \"SSH private key\"),\n        (\"id_ecdsa\", \"SSH private key\"),\n        (\"id_ed25519\", \"SSH private key\"),\n        (\".htpasswd\", \"Apache password file\"),\n        (\"credentials.json\", \"Credentials file\"),\n        (\"service-account.json\", \"Service account credentials\"),\n        (\"secrets.yml\", \"Secrets configuration\"),\n        (\"secrets.yaml\", \"Secrets configuration\"),\n        (\"secrets.json\", \"Secrets configuration\"),\n    ];\n\n    for (pattern, description) in sensitive_patterns {\n        for file in scanner.files_matching_pattern(pattern) {\n            findings.push(\n                Finding::new(\n                    \"SEC002\",\n                    \"secrets\",\n                    Severity::Critical,\n                    format!(\"{} found in repository\", description),\n                )\n                .with_location(\u0026file.path)\n                .with_description(format!(\n                    \"The file '{}' appears to contain sensitive data and should not be committed to version control.\",\n                    file.path\n                ))\n                .with_remediation(\n                    \"Remove the file from the repository and add it to .gitignore. If the file was previously committed, consider rotating any contained credentials.\"\n                )\n            );\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for .env files that should not be committed\n///\n/// Detects environment files that may contain secrets. Example files\n/// (.env.example, .env.template) are allowed.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `_config` - The configuration (currently unused)\n///\n/// # Returns\n///\n/// A vector of findings for detected .env files\nasync fn check_env_files(\n    scanner: \u0026Scanner,\n    _config: \u0026Config,\n) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // Check for .env files (but allow .env.example)\n    let env_patterns = [\n        \".env\",\n        \".env.local\",\n        \".env.production\",\n        \".env.development\",\n        \".env.test\",\n    ];\n\n    for pattern in env_patterns {\n        for file in scanner.files_matching_pattern(pattern) {\n            // Allow example/template files\n            if file.path.contains(\".example\")\n                || file.path.contains(\".template\")\n                || file.path.contains(\".sample\")\n            {\n                continue;\n            }\n\n            findings.push(\n                Finding::new(\n                    \"SEC003\",\n                    \"secrets\",\n                    Severity::Critical,\n                    \"Environment file found in repository\",\n                )\n                .with_location(\u0026file.path)\n                .with_description(\n                    \"Environment files often contain sensitive configuration and secrets that should not be committed.\"\n                )\n                .with_remediation(\n                    \"Add the file to .gitignore and create a .env.example file as a template.\"\n                )\n            );\n        }\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_hardcoded_secrets_detects_api_key() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let config_file = root.join(\"config.js\");\n\n        fs::write(\u0026config_file, \"const apiKey = 'sk_test_1234567890abcdef';\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config::default();\n\n        let findings = check_hardcoded_secrets(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SEC001\"));\n        assert!(findings.iter().any(|f| f.message.contains(\"detected\")));\n    }\n\n    #[tokio::test]\n    async fn test_check_hardcoded_secrets_ignores_ignored_files() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let config_file = root.join(\"config.js\");\n\n        fs::write(\u0026config_file, \"const apiKey = 'sk_test_1234567890abcdef';\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let mut config = Config::default();\n        config.secrets.ignore_files.push(\"config.js\".to_string());\n\n        let findings = check_hardcoded_secrets(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(findings.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_check_sensitive_files_detects_pem() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let key_file = root.join(\"private.pem\");\n\n        fs::write(\u0026key_file, \"-----BEGIN PRIVATE KEY-----\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config::default();\n\n        let findings = check_sensitive_files(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SEC002\"));\n        assert!(findings\n            .iter()\n            .any(|f| f.message.contains(\"Private key file\")));\n    }\n\n    #[tokio::test]\n    async fn test_check_env_files_detects_env() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let env_file = root.join(\".env\");\n\n        fs::write(\u0026env_file, \"API_KEY=secret123\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config::default();\n\n        let findings = check_env_files(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SEC003\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_env_files_allows_example() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let env_example = root.join(\".env.example\");\n\n        fs::write(\u0026env_example, \"API_KEY=your_key_here\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config::default();\n\n        let findings = check_env_files(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(findings.is_empty());\n    }\n}\n","traces":[{"line":24,"address":[84400],"length":1,"stats":{"Line":4}},{"line":42,"address":[949555],"length":1,"stats":{"Line":18}},{"line":43,"address":[979901],"length":1,"stats":{"Line":5}},{"line":46,"address":[979917,979991],"length":1,"stats":{"Line":7}},{"line":47,"address":[285343,285297],"length":1,"stats":{"Line":3}},{"line":51,"address":[979997,980586],"length":1,"stats":{"Line":5}},{"line":52,"address":[980783,980627,981453,979702],"length":1,"stats":{"Line":3}},{"line":56,"address":[980592,981182],"length":1,"stats":{"Line":4}},{"line":57,"address":[981324,979720,981458],"length":1,"stats":{"Line":3}},{"line":60,"address":[981192],"length":1,"stats":{"Line":2}},{"line":77,"address":[82064],"length":1,"stats":{"Line":2}},{"line":81,"address":[971608],"length":1,"stats":{"Line":2}},{"line":84,"address":[971694],"length":1,"stats":{"Line":2}},{"line":89,"address":[972366,972302],"length":1,"stats":{"Line":5}},{"line":92,"address":[973054,973040],"length":1,"stats":{"Line":5}},{"line":93,"address":[973139,973104],"length":1,"stats":{"Line":4}},{"line":97,"address":[811447,811536],"length":1,"stats":{"Line":5}},{"line":99,"address":[973168,974498,974492],"length":1,"stats":{"Line":2}},{"line":100,"address":[973215],"length":1,"stats":{"Line":2}},{"line":101,"address":[973363],"length":1,"stats":{"Line":2}},{"line":102,"address":[973316],"length":1,"stats":{"Line":0}},{"line":103,"address":[974822,973332,974559],"length":1,"stats":{"Line":0}},{"line":104,"address":[974790],"length":1,"stats":{"Line":0}},{"line":108,"address":[973536,973427],"length":1,"stats":{"Line":4}},{"line":109,"address":[973718],"length":1,"stats":{"Line":2}},{"line":110,"address":[973634],"length":1,"stats":{"Line":0}},{"line":111,"address":[973864,974126,973682],"length":1,"stats":{"Line":0}},{"line":112,"address":[974105],"length":1,"stats":{"Line":0}},{"line":119,"address":[972590,972724],"length":1,"stats":{"Line":4}},{"line":120,"address":[972793,972988],"length":1,"stats":{"Line":4}},{"line":123,"address":[972838],"length":1,"stats":{"Line":2}},{"line":137,"address":[947200,948848,948972],"length":1,"stats":{"Line":2}},{"line":142,"address":[947272],"length":1,"stats":{"Line":2}},{"line":144,"address":[947309,947379,948948],"length":1,"stats":{"Line":10}},{"line":145,"address":[947571,947699],"length":1,"stats":{"Line":8}},{"line":146,"address":[947828,947940],"length":1,"stats":{"Line":6}},{"line":150,"address":[947972,948017],"length":1,"stats":{"Line":4}},{"line":152,"address":[948778],"length":1,"stats":{"Line":2}},{"line":153,"address":[948286,948568,948743,948696],"length":1,"stats":{"Line":8}},{"line":156,"address":[83055],"length":1,"stats":{"Line":2}},{"line":157,"address":[83063],"length":1,"stats":{"Line":2}},{"line":159,"address":[83280,83508,83253,83758],"length":1,"stats":{"Line":4}},{"line":160,"address":[83551,83631,83734,83524],"length":1,"stats":{"Line":4}},{"line":168,"address":[947595],"length":1,"stats":{"Line":2}},{"line":181,"address":[83888],"length":1,"stats":{"Line":2}},{"line":182,"address":[949056,949159],"length":1,"stats":{"Line":2}},{"line":184,"address":[814128],"length":1,"stats":{"Line":0}},{"line":185,"address":[975181],"length":1,"stats":{"Line":0}},{"line":186,"address":[975149],"length":1,"stats":{"Line":0}},{"line":191,"address":[949401,949319],"length":1,"stats":{"Line":2}},{"line":207,"address":[949440],"length":1,"stats":{"Line":2}},{"line":211,"address":[975379],"length":1,"stats":{"Line":2}},{"line":214,"address":[815205],"length":1,"stats":{"Line":2}},{"line":215,"address":[975452],"length":1,"stats":{"Line":2}},{"line":216,"address":[975506],"length":1,"stats":{"Line":2}},{"line":217,"address":[975553],"length":1,"stats":{"Line":2}},{"line":218,"address":[814599],"length":1,"stats":{"Line":2}},{"line":219,"address":[814646],"length":1,"stats":{"Line":2}},{"line":220,"address":[975708],"length":1,"stats":{"Line":2}},{"line":221,"address":[814754],"length":1,"stats":{"Line":2}},{"line":222,"address":[814801],"length":1,"stats":{"Line":2}},{"line":223,"address":[975856],"length":1,"stats":{"Line":2}},{"line":224,"address":[814895],"length":1,"stats":{"Line":2}},{"line":225,"address":[814949],"length":1,"stats":{"Line":2}},{"line":226,"address":[976011],"length":1,"stats":{"Line":2}},{"line":227,"address":[976065],"length":1,"stats":{"Line":2}},{"line":228,"address":[815111],"length":1,"stats":{"Line":2}},{"line":229,"address":[815158],"length":1,"stats":{"Line":2}},{"line":232,"address":[815768,815854,815709],"length":1,"stats":{"Line":6}},{"line":233,"address":[816147,816283,815962],"length":1,"stats":{"Line":6}},{"line":234,"address":[977885],"length":1,"stats":{"Line":2}},{"line":235,"address":[977850,977539,977803],"length":1,"stats":{"Line":6}},{"line":238,"address":[977351],"length":1,"stats":{"Line":2}},{"line":239,"address":[977359,977439],"length":1,"stats":{"Line":4}},{"line":241,"address":[977635],"length":1,"stats":{"Line":2}},{"line":242,"address":[977703,977643],"length":1,"stats":{"Line":4}},{"line":253,"address":[977000],"length":1,"stats":{"Line":2}},{"line":269,"address":[949472],"length":1,"stats":{"Line":3}},{"line":273,"address":[817097],"length":1,"stats":{"Line":3}},{"line":276,"address":[978181],"length":1,"stats":{"Line":4}},{"line":284,"address":[978459,978316,978557],"length":1,"stats":{"Line":7}},{"line":285,"address":[978652,978991,978855],"length":1,"stats":{"Line":9}},{"line":287,"address":[818043,818088],"length":1,"stats":{"Line":6}},{"line":288,"address":[979142],"length":1,"stats":{"Line":2}},{"line":289,"address":[979215],"length":1,"stats":{"Line":2}},{"line":294,"address":[979459],"length":1,"stats":{"Line":2}},{"line":295,"address":[979291],"length":1,"stats":{"Line":2}},{"line":298,"address":[979283],"length":1,"stats":{"Line":2}},{"line":312,"address":[978685],"length":1,"stats":{"Line":2}}],"covered":80,"coverable":89},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","security.rs"],"content":"//! Security rules\n//!\n//! This module provides rules for checking security-related aspects, including:\n//! - CODEOWNERS file for code review requirements\n//! - Dependency lock files for reproducible builds\n//! - Runtime version files for consistent environments\n\nuse crate::error::RepoLensError;\n\nuse crate::config::Config;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for checking security-related aspects\npub struct SecurityRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for SecurityRules {\n    /// Get the category name\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"security\"\n    }\n\n    /// Run all security-related rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for security issues\n    async fn run(\u0026self, scanner: \u0026Scanner, config: \u0026Config) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n        let mut findings = Vec::new();\n\n        // Check CODEOWNERS\n        if config.is_rule_enabled(\"security/codeowners\") {\n            findings.extend(check_codeowners(scanner, config).await?);\n        }\n\n        // Check for dependency files\n        if config.is_rule_enabled(\"security/dependencies\") {\n            findings.extend(check_dependencies(scanner).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for CODEOWNERS file\n///\n/// Verifies that a CODEOWNERS file exists. Required for enterprise preset,\n/// recommended for strict preset.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `config` - The configuration (used to determine severity)\n///\n/// # Returns\n///\n/// A vector of findings for CODEOWNERS issues\nasync fn check_codeowners(\n    scanner: \u0026Scanner,\n    config: \u0026Config,\n) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    let codeowners_files = [\"CODEOWNERS\", \".github/CODEOWNERS\", \"docs/CODEOWNERS\"];\n    let has_codeowners = codeowners_files.iter().any(|f| scanner.file_exists(f));\n\n    // CODEOWNERS is required for enterprise, recommended for strict\n    let severity = if config.preset == \"enterprise\" {\n        Severity::Critical\n    } else {\n        Severity::Info\n    };\n\n    if !has_codeowners {\n        findings.push(\n            Finding::new(\n                \"SECURITY001\",\n                \"security\",\n                severity,\n                \"CODEOWNERS file is missing\",\n            )\n            .with_description(\n                \"A CODEOWNERS file automatically assigns reviewers to pull requests based on file paths.\"\n            )\n            .with_remediation(\n                \"Create a CODEOWNERS file in .github/ to define code ownership and review requirements.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check for dependency lock files and version files\n///\n/// Verifies that lock files exist for reproducible builds and that\n/// runtime version files are specified for consistent environments.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for dependency-related issues\nasync fn check_dependencies(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // Check for lock files (indicates dependency management)\n    let _lock_files = [\n        (\"package-lock.json\", \"npm\"),\n        (\"yarn.lock\", \"Yarn\"),\n        (\"pnpm-lock.yaml\", \"pnpm\"),\n        (\"Cargo.lock\", \"Cargo\"),\n        (\"Gemfile.lock\", \"Bundler\"),\n        (\"poetry.lock\", \"Poetry\"),\n        (\"Pipfile.lock\", \"Pipenv\"),\n        (\"composer.lock\", \"Composer\"),\n        (\"go.sum\", \"Go modules\"),\n    ];\n\n    let package_files = [\n        (\"package.json\", \"package-lock.json\"),\n        (\"Cargo.toml\", \"Cargo.lock\"),\n        (\"Gemfile\", \"Gemfile.lock\"),\n        (\"pyproject.toml\", \"poetry.lock\"),\n        (\"Pipfile\", \"Pipfile.lock\"),\n        (\"composer.json\", \"composer.lock\"),\n        (\"go.mod\", \"go.sum\"),\n    ];\n\n    for (package_file, lock_file) in package_files {\n        if scanner.file_exists(package_file) \u0026\u0026 !scanner.file_exists(lock_file) {\n            findings.push(\n                Finding::new(\n                    \"SECURITY002\",\n                    \"security\",\n                    Severity::Warning,\n                    format!(\"Lock file {} is missing\", lock_file),\n                )\n                .with_description(\n                    \"Lock files ensure reproducible builds and protect against supply chain attacks.\"\n                )\n                .with_remediation(\n                    \"Generate the lock file by running your package manager's install command.\"\n                )\n            );\n        }\n    }\n\n    // Check for .nvmrc or similar version files\n    let version_managers = [\n        (\".nvmrc\", \"Node.js version\"),\n        (\".node-version\", \"Node.js version\"),\n        (\".python-version\", \"Python version\"),\n        (\".ruby-version\", \"Ruby version\"),\n        (\"rust-toolchain.toml\", \"Rust toolchain\"),\n    ];\n\n    let has_any_version_file = version_managers.iter().any(|(f, _)| scanner.file_exists(f));\n\n    // Detect project type\n    let is_node = scanner.file_exists(\"package.json\");\n    let is_python =\n        scanner.file_exists(\"pyproject.toml\") || scanner.file_exists(\"requirements.txt\");\n    let is_ruby = scanner.file_exists(\"Gemfile\");\n    let is_rust = scanner.file_exists(\"Cargo.toml\");\n\n    if !has_any_version_file \u0026\u0026 (is_node || is_python || is_ruby || is_rust) {\n        findings.push(\n            Finding::new(\n                \"SECURITY003\",\n                \"security\",\n                Severity::Info,\n                \"No runtime version file found\",\n            )\n            .with_description(\n                \"Specifying runtime versions (e.g., .nvmrc, .python-version) ensures consistent development environments.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::Config;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_codeowners_missing_enterprise() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config {\n            preset: \"enterprise\".to_string(),\n            ..Default::default()\n        };\n        let findings = check_codeowners(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SECURITY001\"));\n        assert!(findings\n            .iter()\n            .any(|f| f.severity == crate::rules::results::Severity::Critical));\n    }\n\n    #[tokio::test]\n    async fn test_check_codeowners_missing_strict() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config {\n            preset: \"strict\".to_string(),\n            ..Default::default()\n        };\n        let findings = check_codeowners(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SECURITY001\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_dependencies_missing_lock_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let package_json = root.join(\"package.json\");\n\n        fs::write(\u0026package_json, r#\"{\"name\": \"test\"}\"#).unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_dependencies(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SECURITY002\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_dependencies_no_version_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let package_json = root.join(\"package.json\");\n\n        fs::write(\u0026package_json, r#\"{\"name\": \"test\"}\"#).unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_dependencies(\u0026scanner).await.unwrap();\n\n        assert!(findings.iter().any(|f| f.rule_id == \"SECURITY003\"));\n    }\n}\n","traces":[{"line":21,"address":[1572416],"length":1,"stats":{"Line":2}},{"line":35,"address":[1436297,1437339,1436417,1436211,1436777,1436501,1437478,1436176],"length":1,"stats":{"Line":19}},{"line":36,"address":[1436517],"length":1,"stats":{"Line":3}},{"line":39,"address":[1436607,1436533],"length":1,"stats":{"Line":6}},{"line":40,"address":[1436648,1436803,1437457,1436324],"length":1,"stats":{"Line":3}},{"line":44,"address":[1436613,1437202],"length":1,"stats":{"Line":6}},{"line":45,"address":[285662,285741],"length":1,"stats":{"Line":2}},{"line":48,"address":[936108],"length":1,"stats":{"Line":3}},{"line":65,"address":[1431792],"length":1,"stats":{"Line":2}},{"line":69,"address":[1432112],"length":1,"stats":{"Line":2}},{"line":71,"address":[1432185],"length":1,"stats":{"Line":3}},{"line":72,"address":[1432833,1432263,1432816,1432346],"length":1,"stats":{"Line":10}},{"line":75,"address":[1432399,1432435],"length":1,"stats":{"Line":4}},{"line":76,"address":[1432437],"length":1,"stats":{"Line":2}},{"line":78,"address":[1432427],"length":1,"stats":{"Line":2}},{"line":81,"address":[1432449],"length":1,"stats":{"Line":2}},{"line":82,"address":[1432742],"length":1,"stats":{"Line":2}},{"line":83,"address":[1432455,1432672],"length":1,"stats":{"Line":6}},{"line":98,"address":[1432533],"length":1,"stats":{"Line":3}},{"line":113,"address":[1431824,1431832],"length":1,"stats":{"Line":9}},{"line":114,"address":[1432954],"length":1,"stats":{"Line":2}},{"line":117,"address":[1433513],"length":1,"stats":{"Line":3}},{"line":118,"address":[1433027],"length":1,"stats":{"Line":2}},{"line":119,"address":[1433081],"length":1,"stats":{"Line":2}},{"line":120,"address":[1433135],"length":1,"stats":{"Line":2}},{"line":121,"address":[1433189],"length":1,"stats":{"Line":3}},{"line":122,"address":[1433243],"length":1,"stats":{"Line":3}},{"line":123,"address":[1433297],"length":1,"stats":{"Line":2}},{"line":124,"address":[1433351],"length":1,"stats":{"Line":3}},{"line":125,"address":[1433405],"length":1,"stats":{"Line":3}},{"line":126,"address":[1433459],"length":1,"stats":{"Line":3}},{"line":129,"address":[1434130],"length":1,"stats":{"Line":3}},{"line":130,"address":[1433801],"length":1,"stats":{"Line":2}},{"line":131,"address":[1433848],"length":1,"stats":{"Line":3}},{"line":132,"address":[1433895],"length":1,"stats":{"Line":3}},{"line":133,"address":[1433942],"length":1,"stats":{"Line":4}},{"line":134,"address":[932885],"length":1,"stats":{"Line":4}},{"line":135,"address":[1434036],"length":1,"stats":{"Line":4}},{"line":136,"address":[932979],"length":1,"stats":{"Line":4}},{"line":139,"address":[1434532,1434387,1434446],"length":1,"stats":{"Line":6}},{"line":140,"address":[1435741,1434632],"length":1,"stats":{"Line":4}},{"line":141,"address":[1436064],"length":1,"stats":{"Line":2}},{"line":142,"address":[934827],"length":1,"stats":{"Line":2}},{"line":145,"address":[1435796],"length":1,"stats":{"Line":2}},{"line":146,"address":[934700],"length":1,"stats":{"Line":2}},{"line":159,"address":[1434924],"length":1,"stats":{"Line":2}},{"line":160,"address":[933557],"length":1,"stats":{"Line":2}},{"line":161,"address":[1434715],"length":1,"stats":{"Line":2}},{"line":162,"address":[1434762],"length":1,"stats":{"Line":2}},{"line":163,"address":[1434816],"length":1,"stats":{"Line":2}},{"line":164,"address":[1434870],"length":1,"stats":{"Line":2}},{"line":167,"address":[1435097,1436128,1436144],"length":1,"stats":{"Line":6}},{"line":170,"address":[934078],"length":1,"stats":{"Line":2}},{"line":171,"address":[1435223],"length":1,"stats":{"Line":2}},{"line":173,"address":[934208],"length":1,"stats":{"Line":2}},{"line":174,"address":[1435353],"length":1,"stats":{"Line":2}},{"line":176,"address":[1435559,1435394,1435651],"length":1,"stats":{"Line":8}},{"line":177,"address":[1435705],"length":1,"stats":{"Line":3}},{"line":178,"address":[1435577,1435670],"length":1,"stats":{"Line":6}},{"line":181,"address":[1435569],"length":1,"stats":{"Line":3}},{"line":190,"address":[1435420],"length":1,"stats":{"Line":3}}],"covered":61,"coverable":61},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","workflows.rs"],"content":"//! GitHub Actions workflow rules\n//!\n//! This module provides rules for checking GitHub Actions workflows, including:\n//! - Hardcoded secrets in workflow files\n//! - Explicit permissions configuration\n//! - Pinned action versions for security\n\nuse crate::error::RepoLensError;\nuse regex::Regex;\n\nuse crate::config::Config;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for checking GitHub Actions workflows\npub struct WorkflowsRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for WorkflowsRules {\n    /// Get the category name\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"workflows\"\n    }\n\n    /// Run all workflow-related rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for workflow issues\n    async fn run(\u0026self, scanner: \u0026Scanner, config: \u0026Config) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n        let mut findings = Vec::new();\n\n        // Check for workflows directory\n        if !scanner.directory_exists(\".github/workflows\") {\n            return Ok(findings);\n        }\n\n        // Check workflow security\n        if config.is_rule_enabled(\"workflows/secrets\") {\n            findings.extend(check_workflow_secrets(scanner).await?);\n        }\n\n        // Check permissions\n        if config.is_rule_enabled(\"workflows/permissions\") {\n            findings.extend(check_workflow_permissions(scanner).await?);\n        }\n\n        // Check pinned actions\n        if config.is_rule_enabled(\"workflows/pinned-actions\") {\n            findings.extend(check_pinned_actions(scanner, config).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for hardcoded secrets in workflow files\n///\n/// Detects patterns that suggest hardcoded passwords, tokens, API keys,\n/// or secrets in GitHub Actions workflow files.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for hardcoded secrets in workflows\nasync fn check_workflow_secrets(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // Patterns that suggest hardcoded secrets in workflows\n    let secret_patterns = [\n        (r#\"password\\s*:\\s*['\"][^'\"]+['\"]\"#, \"hardcoded password\"),\n        (r#\"token\\s*:\\s*['\"][^'\"]+['\"]\"#, \"hardcoded token\"),\n        (r#\"api[_-]?key\\s*:\\s*['\"][^'\"]+['\"]\"#, \"hardcoded API key\"),\n        (r#\"secret\\s*:\\s*['\"][^'\"]+['\"]\"#, \"hardcoded secret\"),\n    ];\n\n    for file in scanner.files_in_directory(\".github/workflows\") {\n        if !file.path.ends_with(\".yml\") \u0026\u0026 !file.path.ends_with(\".yaml\") {\n            continue;\n        }\n\n        if let Ok(content) = scanner.read_file(\u0026file.path) {\n            for (pattern, description) in \u0026secret_patterns {\n                let regex = match Regex::new(pattern) {\n                    Ok(r) =\u003e r,\n                    Err(e) =\u003e {\n                        tracing::warn!(\"Invalid regex pattern '{}': {}\", pattern, e);\n                        continue;\n                    }\n                };\n                if regex.is_match(\u0026content) {\n                    // Find line number\n                    let line_num = content\n                        .lines()\n                        .enumerate()\n                        .find(|(_, line)| regex.is_match(line))\n                        .map(|(i, _)| i + 1)\n                        .unwrap_or(0);\n\n                    findings.push(\n                        Finding::new(\n                            \"WF001\",\n                            \"workflows\",\n                            Severity::Critical,\n                            format!(\"Potential {} in workflow\", description),\n                        )\n                        .with_location(format!(\"{}:{}\", file.path, line_num))\n                        .with_description(\"Secrets should never be hardcoded in workflow files.\")\n                        .with_remediation(\n                            \"Use GitHub Secrets (secrets.SECRET_NAME) instead of hardcoded values.\",\n                        ),\n                    );\n                }\n            }\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for explicit permissions in workflow files\n///\n/// Verifies that workflows define explicit permissions to follow\n/// the principle of least privilege.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for missing permissions\nasync fn check_workflow_permissions(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    for file in scanner.files_in_directory(\".github/workflows\") {\n        if !file.path.ends_with(\".yml\") \u0026\u0026 !file.path.ends_with(\".yaml\") {\n            continue;\n        }\n\n        if let Ok(content) = scanner.read_file(\u0026file.path) {\n            // Check if permissions are defined\n            if !content.contains(\"permissions:\") {\n                findings.push(\n                    Finding::new(\n                        \"WF002\",\n                        \"workflows\",\n                        Severity::Warning,\n                        \"Workflow missing explicit permissions\",\n                    )\n                    .with_location(\u0026file.path)\n                    .with_description(\n                        \"Workflows without explicit permissions use the default permissions, which may be more permissive than necessary.\"\n                    )\n                    .with_remediation(\n                        \"Add a 'permissions:' block to explicitly define the minimum required permissions.\"\n                    )\n                );\n            }\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for pinned action versions\n///\n/// In strict mode, verifies that actions are pinned to specific versions\n/// instead of using @main, @master, or @latest.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `config` - The configuration (used to check preset)\n///\n/// # Returns\n///\n/// A vector of findings for unpinned actions\nasync fn check_pinned_actions(\n    scanner: \u0026Scanner,\n    config: \u0026Config,\n) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // Only check in strict mode\n    if config.preset != \"strict\" {\n        return Ok(findings);\n    }\n\n    let unpinned_patterns = [\n        r\"uses:\\s+\\S+@main\\b\",\n        r\"uses:\\s+\\S+@master\\b\",\n        r\"uses:\\s+\\S+@latest\\b\",\n    ];\n\n    for file in scanner.files_in_directory(\".github/workflows\") {\n        if !file.path.ends_with(\".yml\") \u0026\u0026 !file.path.ends_with(\".yaml\") {\n            continue;\n        }\n\n        if let Ok(content) = scanner.read_file(\u0026file.path) {\n            for pattern in \u0026unpinned_patterns {\n                let regex = match Regex::new(pattern) {\n                    Ok(r) =\u003e r,\n                    Err(e) =\u003e {\n                        tracing::warn!(\"Invalid regex pattern '{}': {}\", pattern, e);\n                        continue;\n                    }\n                };\n                for (line_num, line) in content.lines().enumerate() {\n                    if regex.is_match(line) {\n                        findings.push(\n                            Finding::new(\n                                \"WF003\",\n                                \"workflows\",\n                                Severity::Warning,\n                                \"Workflow uses unpinned action reference\",\n                            )\n                            .with_location(format!(\"{}:{}\", file.path, line_num + 1))\n                            .with_description(\n                                \"Using @main, @master, or @latest for actions can introduce breaking changes or security vulnerabilities.\"\n                            )\n                            .with_remediation(\n                                \"Pin actions to a specific version tag (e.g., @v4) or commit SHA for maximum security.\"\n                            )\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::Config;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_workflow_secrets_detects_hardcoded_password() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let workflows_dir = root.join(\".github\").join(\"workflows\");\n        fs::create_dir_all(\u0026workflows_dir).unwrap();\n\n        let workflow_file = workflows_dir.join(\"ci.yml\");\n        fs::write(\n            \u0026workflow_file,\n            \"name: CI\\non: push\\njobs:\\n  test:\\n    password: 'secret123'\",\n        )\n        .unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_workflow_secrets(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"WF001\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_workflow_permissions_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let workflows_dir = root.join(\".github\").join(\"workflows\");\n        fs::create_dir_all(\u0026workflows_dir).unwrap();\n\n        let workflow_file = workflows_dir.join(\"ci.yml\");\n        fs::write(\n            \u0026workflow_file,\n            \"name: CI\\non: push\\njobs:\\n  test:\\n    runs-on: ubuntu-latest\",\n        )\n        .unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_workflow_permissions(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"WF002\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_pinned_actions_detects_unpinned() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let workflows_dir = root.join(\".github\").join(\"workflows\");\n        fs::create_dir_all(\u0026workflows_dir).unwrap();\n\n        let workflow_file = workflows_dir.join(\"ci.yml\");\n        fs::write(\n            \u0026workflow_file,\n            \"name: CI\\njobs:\\n  test:\\n    uses: actions/checkout@main\",\n        )\n        .unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config {\n            preset: \"strict\".to_string(),\n            ..Default::default()\n        };\n        let findings = check_pinned_actions(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"WF003\"));\n    }\n}\n","traces":[{"line":22,"address":[671792],"length":1,"stats":{"Line":2}},{"line":36,"address":[1150813,1150035,1151949,1151390,1150000,1150352,1150268,1150130],"length":1,"stats":{"Line":15}},{"line":37,"address":[1150369],"length":1,"stats":{"Line":2}},{"line":40,"address":[1150493,1150414],"length":1,"stats":{"Line":7}},{"line":41,"address":[1150499],"length":1,"stats":{"Line":3}},{"line":45,"address":[491938,491994],"length":1,"stats":{"Line":0}},{"line":46,"address":[286159,286113],"length":1,"stats":{"Line":0}},{"line":50,"address":[1151238,1150672],"length":1,"stats":{"Line":0}},{"line":51,"address":[1151279,1150175,1151396,1152075],"length":1,"stats":{"Line":0}},{"line":55,"address":[1151795,1151244],"length":1,"stats":{"Line":0}},{"line":56,"address":[1151954,1150193,1152080],"length":1,"stats":{"Line":0}},{"line":59,"address":[1151805],"length":1,"stats":{"Line":0}},{"line":75,"address":[486195,482780,482679,482802,482640,485501],"length":1,"stats":{"Line":8}},{"line":76,"address":[1141445],"length":1,"stats":{"Line":2}},{"line":79,"address":[1141745],"length":1,"stats":{"Line":2}},{"line":80,"address":[1141529],"length":1,"stats":{"Line":2}},{"line":81,"address":[1141583],"length":1,"stats":{"Line":2}},{"line":82,"address":[1141637],"length":1,"stats":{"Line":2}},{"line":83,"address":[1141691],"length":1,"stats":{"Line":2}},{"line":86,"address":[1141873,1141956,1144843,1142098],"length":1,"stats":{"Line":8}},{"line":87,"address":[1142161,1142380,1142501],"length":1,"stats":{"Line":6}},{"line":91,"address":[1142614,1142712,1142462],"length":1,"stats":{"Line":6}},{"line":92,"address":[1142760,1142843],"length":1,"stats":{"Line":4}},{"line":93,"address":[1142965,1143087],"length":1,"stats":{"Line":4}},{"line":94,"address":[1143181],"length":1,"stats":{"Line":2}},{"line":95,"address":[1143118],"length":1,"stats":{"Line":0}},{"line":96,"address":[1143150,1144230,1144475],"length":1,"stats":{"Line":0}},{"line":100,"address":[1143332,1143253],"length":1,"stats":{"Line":4}},{"line":102,"address":[1143383],"length":1,"stats":{"Line":2}},{"line":105,"address":[1144912,1144896],"length":1,"stats":{"Line":4}},{"line":106,"address":[1144960,1144964],"length":1,"stats":{"Line":4}},{"line":109,"address":[1144120],"length":1,"stats":{"Line":2}},{"line":110,"address":[1143721,1144050,1144003],"length":1,"stats":{"Line":6}},{"line":113,"address":[1143551],"length":1,"stats":{"Line":2}},{"line":114,"address":[1143621,1143559],"length":1,"stats":{"Line":4}},{"line":116,"address":[1143586,1144042,1144163,1143800,1143819],"length":1,"stats":{"Line":4}},{"line":127,"address":[1142210],"length":1,"stats":{"Line":2}},{"line":142,"address":[487761,486465,487850,486375,486487,486336],"length":1,"stats":{"Line":8}},{"line":143,"address":[1145130],"length":1,"stats":{"Line":2}},{"line":145,"address":[486619,487826,486755,486539],"length":1,"stats":{"Line":8}},{"line":146,"address":[1145694,1145785,1145487],"length":1,"stats":{"Line":6}},{"line":150,"address":[487211,487309,487086],"length":1,"stats":{"Line":6}},{"line":152,"address":[1146100,1146029],"length":1,"stats":{"Line":4}},{"line":153,"address":[1146335],"length":1,"stats":{"Line":2}},{"line":154,"address":[1146145,1146258],"length":1,"stats":{"Line":4}},{"line":157,"address":[1146137],"length":1,"stats":{"Line":2}},{"line":172,"address":[486858],"length":1,"stats":{"Line":2}},{"line":188,"address":[1168304],"length":1,"stats":{"Line":2}},{"line":192,"address":[488049],"length":1,"stats":{"Line":2}},{"line":195,"address":[1146805,1146870],"length":1,"stats":{"Line":4}},{"line":196,"address":[488320],"length":1,"stats":{"Line":0}},{"line":199,"address":[1146884],"length":1,"stats":{"Line":2}},{"line":205,"address":[491270,488449,488293,488591],"length":1,"stats":{"Line":8}},{"line":206,"address":[1147666,1147545,1147326],"length":1,"stats":{"Line":6}},{"line":210,"address":[1147877,1147627,1147779],"length":1,"stats":{"Line":6}},{"line":211,"address":[1148008,1147925],"length":1,"stats":{"Line":4}},{"line":212,"address":[1148108,1148230],"length":1,"stats":{"Line":4}},{"line":213,"address":[1148321],"length":1,"stats":{"Line":2}},{"line":214,"address":[489589],"length":1,"stats":{"Line":0}},{"line":215,"address":[1149574,1149329,1148293],"length":1,"stats":{"Line":0}},{"line":219,"address":[489800,489721],"length":1,"stats":{"Line":4}},{"line":220,"address":[1148678,1148715],"length":1,"stats":{"Line":4}},{"line":221,"address":[1149222],"length":1,"stats":{"Line":2}},{"line":222,"address":[1149152,1149105,1148732],"length":1,"stats":{"Line":6}},{"line":225,"address":[1148724],"length":1,"stats":{"Line":2}},{"line":228,"address":[1148802,1149144,1149265,1148872,1148853],"length":1,"stats":{"Line":4}},{"line":242,"address":[1147367],"length":1,"stats":{"Line":2}}],"covered":55,"coverable":67},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","engine.rs"],"content":"//! Rules evaluation engine\n\nuse crate::error::RepoLensError;\nuse tracing::{debug, info, span, Level};\n\nuse super::categories::{\n    custom::CustomRules, docs::DocsRules, files::FilesRules, quality::QualityRules,\n    secrets::SecretsRules, security::SecurityRules, workflows::WorkflowsRules,\n};\nuse super::results::AuditResults;\nuse crate::config::Config;\nuse crate::scanner::Scanner;\n\n/// Trait for rule categories\n#[async_trait::async_trait]\npub trait RuleCategory: Send + Sync {\n    /// Get the category name\n    fn name(\u0026self) -\u003e \u0026'static str;\n\n    /// Run the rules in this category\n    async fn run(\n        \u0026self,\n        scanner: \u0026Scanner,\n        config: \u0026Config,\n    ) -\u003e Result\u003cVec\u003csuper::Finding\u003e, RepoLensError\u003e;\n}\n\n/// Main rules evaluation engine\npub struct RulesEngine {\n    config: Config,\n    only_categories: Option\u003cVec\u003cString\u003e\u003e,\n    skip_categories: Option\u003cVec\u003cString\u003e\u003e,\n}\n\nimpl RulesEngine {\n    /// Create a new rules engine with the given configuration\n    pub fn new(config: Config) -\u003e Self {\n        Self {\n            config,\n            only_categories: None,\n            skip_categories: None,\n        }\n    }\n\n    /// Set categories to exclusively run\n    pub fn set_only_categories(\u0026mut self, categories: Vec\u003cString\u003e) {\n        self.only_categories = Some(categories);\n    }\n\n    /// Set categories to skip\n    pub fn set_skip_categories(\u0026mut self, categories: Vec\u003cString\u003e) {\n        self.skip_categories = Some(categories);\n    }\n\n    /// Check if a category should be run\n    fn should_run_category(\u0026self, category: \u0026str) -\u003e bool {\n        if let Some(only) = \u0026self.only_categories {\n            return only.iter().any(|c| c == category);\n        }\n\n        if let Some(skip) = \u0026self.skip_categories {\n            return !skip.iter().any(|c| c == category);\n        }\n\n        true\n    }\n\n    /// Run all enabled rules and return results\n    pub async fn run(\u0026self, scanner: \u0026Scanner) -\u003e Result\u003cAuditResults, RepoLensError\u003e {\n        info!(\"Starting audit with preset: {}\", self.config.preset);\n\n        let repo_name = scanner.repository_name();\n        let repo_name_ref = \u0026repo_name;\n        let mut results = AuditResults::new(repo_name.clone(), \u0026self.config.preset);\n\n        // Get all rule categories\n        let categories: Vec\u003cBox\u003cdyn RuleCategory\u003e\u003e = vec![\n            Box::new(SecretsRules),\n            Box::new(FilesRules),\n            Box::new(DocsRules),\n            Box::new(SecurityRules),\n            Box::new(WorkflowsRules),\n            Box::new(QualityRules),\n            Box::new(CustomRules),\n        ];\n\n        // Run each category\n        for category in categories {\n            let category_name = category.name();\n\n            if !self.should_run_category(category_name) {\n                debug!(category = category_name, \"Skipping category\");\n                continue;\n            }\n\n            let span = span!(Level::INFO, \"category\", category = category_name, repository = %repo_name_ref);\n            let _guard = span.enter();\n\n            debug!(category = category_name, \"Running category\");\n\n            match category.run(scanner, \u0026self.config).await {\n                Ok(findings) =\u003e {\n                    let count = findings.len();\n                    debug!(\n                        category = category_name,\n                        findings_count = count,\n                        \"Category completed\"\n                    );\n                    results.add_findings(findings);\n                }\n                Err(e) =\u003e {\n                    tracing::warn!(\n                        category = category_name,\n                        error = %e,\n                        \"Error running category\"\n                    );\n                }\n            }\n        }\n\n        info!(\n            \"Audit complete: {} critical, {} warnings, {} info\",\n            results.count_by_severity(super::Severity::Critical),\n            results.count_by_severity(super::Severity::Warning),\n            results.count_by_severity(super::Severity::Info),\n        );\n\n        Ok(results)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_rules_engine_runs_all_categories() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Create a basic file structure\n        fs::write(root.join(\"README.md\"), \"# Test Project\").unwrap();\n\n        let config = Config::default();\n        let scanner = Scanner::new(root.to_path_buf());\n        let engine = RulesEngine::new(config);\n\n        let results = engine.run(\u0026scanner).await.unwrap();\n\n        // Verify that results are returned (may be empty if no issues found)\n        let _ = results.findings().len();\n        assert_eq!(results.preset, \"opensource\");\n    }\n\n    #[tokio::test]\n    async fn test_rules_engine_filters_with_only() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        fs::write(root.join(\"README.md\"), \"# Test\").unwrap();\n\n        let config = Config::default();\n        let scanner = Scanner::new(root.to_path_buf());\n        let mut engine = RulesEngine::new(config);\n        engine.set_only_categories(vec![\"secrets\".to_string()]);\n\n        let results = engine.run(\u0026scanner).await.unwrap();\n\n        // Verify that only secrets category was run\n        // All findings should be from secrets category\n        for finding in results.findings() {\n            assert_eq!(finding.category, \"secrets\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_rules_engine_filters_with_skip() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        fs::write(root.join(\"README.md\"), \"# Test\").unwrap();\n\n        let config = Config::default();\n        let scanner = Scanner::new(root.to_path_buf());\n        let mut engine = RulesEngine::new(config);\n        engine.set_skip_categories(vec![\"secrets\".to_string()]);\n\n        let results = engine.run(\u0026scanner).await.unwrap();\n\n        // Verify that secrets category was skipped\n        for finding in results.findings() {\n            assert_ne!(finding.category, \"secrets\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_rules_engine_handles_category_errors_gracefully() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Create a file that might cause issues\n        fs::write(root.join(\"test.txt\"), \"test\").unwrap();\n\n        let config = Config::default();\n        let scanner = Scanner::new(root.to_path_buf());\n        let engine = RulesEngine::new(config);\n\n        // Should not panic even if a category fails\n        let results = engine.run(\u0026scanner).await;\n        assert!(results.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_rules_engine_collects_all_findings() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Create files that should trigger findings\n        fs::write(\n            root.join(\"test.js\"),\n            \"const apiKey = 'sk_test_1234567890abcdef';\",\n        )\n        .unwrap();\n\n        let config = Config::default();\n        let scanner = Scanner::new(root.to_path_buf());\n        let engine = RulesEngine::new(config);\n\n        let results = engine.run(\u0026scanner).await.unwrap();\n\n        // Should have collected findings from multiple categories\n        // (at least secrets should find something)\n        let _ = results.findings().len();\n    }\n\n    #[test]\n    fn test_should_run_category_with_only() {\n        let config = Config::default();\n        let mut engine = RulesEngine::new(config);\n        engine.set_only_categories(vec![\"secrets\".to_string(), \"files\".to_string()]);\n\n        assert!(engine.should_run_category(\"secrets\"));\n        assert!(engine.should_run_category(\"files\"));\n        assert!(!engine.should_run_category(\"docs\"));\n    }\n\n    #[test]\n    fn test_should_run_category_with_skip() {\n        let config = Config::default();\n        let mut engine = RulesEngine::new(config);\n        engine.set_skip_categories(vec![\"secrets\".to_string()]);\n\n        assert!(!engine.should_run_category(\"secrets\"));\n        assert!(engine.should_run_category(\"files\"));\n        assert!(engine.should_run_category(\"docs\"));\n    }\n\n    #[test]\n    fn test_should_run_category_default() {\n        let config = Config::default();\n        let engine = RulesEngine::new(config);\n\n        // By default, all categories should run\n        assert!(engine.should_run_category(\"secrets\"));\n        assert!(engine.should_run_category(\"files\"));\n        assert!(engine.should_run_category(\"docs\"));\n    }\n}\n","traces":[{"line":37,"address":[1198816],"length":1,"stats":{"Line":3}},{"line":46,"address":[1198960,1199046],"length":1,"stats":{"Line":2}},{"line":47,"address":[1199077,1198974],"length":1,"stats":{"Line":4}},{"line":51,"address":[1199120,1199206],"length":1,"stats":{"Line":2}},{"line":52,"address":[1199134,1199237],"length":1,"stats":{"Line":4}},{"line":56,"address":[1199280],"length":1,"stats":{"Line":2}},{"line":57,"address":[1199304],"length":1,"stats":{"Line":2}},{"line":58,"address":[1199364],"length":1,"stats":{"Line":6}},{"line":61,"address":[1199420,1199486],"length":1,"stats":{"Line":4}},{"line":62,"address":[1199491],"length":1,"stats":{"Line":6}},{"line":65,"address":[1199544],"length":1,"stats":{"Line":2}},{"line":69,"address":[893759,893712,893934,895787,893891,895776],"length":1,"stats":{"Line":10}},{"line":70,"address":[1185287,1185415,1185706],"length":1,"stats":{"Line":6}},{"line":72,"address":[1185680],"length":1,"stats":{"Line":3}},{"line":73,"address":[1185992],"length":1,"stats":{"Line":3}},{"line":74,"address":[1186090,1186011],"length":1,"stats":{"Line":6}},{"line":77,"address":[895303,895782,894971,895137,895220,894888,895054,894802,894771,894707,895332],"length":1,"stats":{"Line":11}},{"line":78,"address":[1186203,1186266],"length":1,"stats":{"Line":10}},{"line":79,"address":[894865,894925],"length":1,"stats":{"Line":9}},{"line":80,"address":[1186432,1186372],"length":1,"stats":{"Line":10}},{"line":81,"address":[895031,895091],"length":1,"stats":{"Line":10}},{"line":82,"address":[1186538,1186598],"length":1,"stats":{"Line":10}},{"line":83,"address":[1186681,1186621],"length":1,"stats":{"Line":10}},{"line":84,"address":[895280],"length":1,"stats":{"Line":6}},{"line":88,"address":[1187067,1187142,1189565],"length":1,"stats":{"Line":17}},{"line":89,"address":[1190835,1189646],"length":1,"stats":{"Line":8}},{"line":91,"address":[1190842],"length":1,"stats":{"Line":3}},{"line":92,"address":[899523,899813,899471],"length":1,"stats":{"Line":4}},{"line":96,"address":[1190923,1191544,1191961],"length":1,"stats":{"Line":7}},{"line":97,"address":[900488,900868],"length":1,"stats":{"Line":7}},{"line":99,"address":[1192372,1192295,1192646],"length":1,"stats":{"Line":8}},{"line":101,"address":[303143],"length":1,"stats":{"Line":17}},{"line":102,"address":[896229],"length":1,"stats":{"Line":3}},{"line":103,"address":[1187765,1187701],"length":1,"stats":{"Line":5}},{"line":104,"address":[1188143,1187773],"length":1,"stats":{"Line":3}},{"line":109,"address":[1188073],"length":1,"stats":{"Line":2}},{"line":111,"address":[1187574],"length":1,"stats":{"Line":0}},{"line":112,"address":[1188641,1187622,1188924],"length":1,"stats":{"Line":0}},{"line":121,"address":[1190340],"length":1,"stats":{"Line":1}},{"line":128,"address":[1190032],"length":1,"stats":{"Line":2}}],"covered":38,"coverable":40},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","mod.rs"],"content":"//! Rules module - Audit rules and evaluation engine\n\npub mod categories;\npub mod engine;\npub mod patterns;\npub mod results;\n\npub use results::{Finding, Severity};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","patterns","mod.rs"],"content":"//! Pattern definitions for secret detection\n\nmod secrets;\n\npub use secrets::SECRET_PATTERNS;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","patterns","secrets.rs"],"content":"//! Secret detection patterns\n\nuse lazy_static::lazy_static;\nuse regex::Regex;\n\n/// A pattern for detecting secrets\npub struct SecretPattern {\n    pub name: \u0026'static str,\n    pub description: \u0026'static str,\n    pub regex: Regex,\n}\n\nlazy_static! {\n    /// Collection of secret patterns to detect\n    pub static ref SECRET_PATTERNS: Vec\u003cSecretPattern\u003e = vec![\n        // GitHub tokens\n        SecretPattern {\n            name: \"GitHub Personal Access Token\",\n            description: \"GitHub personal access tokens start with 'ghp_'\",\n            regex: Regex::new(r\"ghp_[A-Za-z0-9]{36}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"GitHub OAuth Token\",\n            description: \"GitHub OAuth tokens start with 'gho_'\",\n            regex: Regex::new(r\"gho_[A-Za-z0-9]{36}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"GitHub User-to-Server Token\",\n            description: \"GitHub user-to-server tokens start with 'ghu_'\",\n            regex: Regex::new(r\"ghu_[A-Za-z0-9]{36}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"GitHub Server-to-Server Token\",\n            description: \"GitHub server-to-server tokens start with 'ghs_'\",\n            regex: Regex::new(r\"ghs_[A-Za-z0-9]{36}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"GitHub Refresh Token\",\n            description: \"GitHub refresh tokens start with 'ghr_'\",\n            regex: Regex::new(r\"ghr_[A-Za-z0-9]{36}\").unwrap(),\n        },\n\n        // AWS\n        SecretPattern {\n            name: \"AWS Access Key ID\",\n            description: \"AWS access keys start with 'AKIA'\",\n            regex: Regex::new(r\"AKIA[0-9A-Z]{16}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"AWS Secret Access Key\",\n            description: \"AWS secret access keys are 40 character strings\",\n            regex: Regex::new(r#\"(?i)(aws_secret_access_key|aws_secret_key)\\s*[=:]\\s*['\"]?[A-Za-z0-9/+=]{40}['\"]?\"#).unwrap(),\n        },\n\n        // Stripe\n        SecretPattern {\n            name: \"Stripe Live Secret Key\",\n            description: \"Stripe live secret keys start with 'sk_live_'\",\n            regex: Regex::new(r\"sk_live_[0-9a-zA-Z]{24,}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"Stripe Test Secret Key\",\n            description: \"Stripe test secret keys start with 'sk_test_'\",\n            regex: Regex::new(r\"sk_test_[0-9a-zA-Z]{24,}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"Stripe Restricted Key\",\n            description: \"Stripe restricted keys start with 'rk_live_' or 'rk_test_'\",\n            regex: Regex::new(r\"rk_(live|test)_[0-9a-zA-Z]{24,}\").unwrap(),\n        },\n\n        // Slack\n        SecretPattern {\n            name: \"Slack Token\",\n            description: \"Slack tokens start with 'xox'\",\n            regex: Regex::new(r\"xox[baprs]-[0-9a-zA-Z-]{10,48}\").unwrap(),\n        },\n\n        // Google\n        SecretPattern {\n            name: \"Google API Key\",\n            description: \"Google API keys start with 'AIza'\",\n            regex: Regex::new(r\"AIza[0-9A-Za-z\\-_]{35}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"Google OAuth Token\",\n            description: \"Google OAuth tokens start with 'ya29.'\",\n            regex: Regex::new(r\"ya29\\.[0-9A-Za-z\\-_]+\").unwrap(),\n        },\n\n        // Firebase\n        SecretPattern {\n            name: \"Firebase Cloud Messaging\",\n            description: \"Firebase server keys\",\n            regex: Regex::new(r\"AAAA[A-Za-z0-9_-]{7}:[A-Za-z0-9_-]{140}\").unwrap(),\n        },\n\n        // Twilio\n        SecretPattern {\n            name: \"Twilio API Key\",\n            description: \"Twilio API keys start with 'SK'\",\n            regex: Regex::new(r\"SK[0-9a-fA-F]{32}\").unwrap(),\n        },\n\n        // SendGrid\n        SecretPattern {\n            name: \"SendGrid API Key\",\n            description: \"SendGrid API keys start with 'SG.'\",\n            regex: Regex::new(r\"SG\\.[0-9A-Za-z\\-_]{22}\\.[0-9A-Za-z\\-_]{43}\").unwrap(),\n        },\n\n        // Mailgun\n        SecretPattern {\n            name: \"Mailgun API Key\",\n            description: \"Mailgun API keys start with 'key-'\",\n            regex: Regex::new(r\"key-[0-9a-zA-Z]{32}\").unwrap(),\n        },\n\n        // npm\n        SecretPattern {\n            name: \"npm Token\",\n            description: \"npm tokens start with 'npm_'\",\n            regex: Regex::new(r\"npm_[A-Za-z0-9]{36}\").unwrap(),\n        },\n\n        // Discord\n        SecretPattern {\n            name: \"Discord Token\",\n            description: \"Discord bot tokens\",\n            regex: Regex::new(r\"[MN][A-Za-z\\d]{23,}\\.[\\w-]{6}\\.[\\w-]{27}\").unwrap(),\n        },\n\n        // Generic patterns\n        SecretPattern {\n            name: \"Private Key\",\n            description: \"PEM encoded private key\",\n            regex: Regex::new(r\"-----BEGIN (RSA|DSA|EC|OPENSSH) PRIVATE KEY-----\").unwrap(),\n        },\n        SecretPattern {\n            name: \"JWT Token\",\n            description: \"JSON Web Token\",\n            regex: Regex::new(r\"eyJ[A-Za-z0-9-_=]+\\.eyJ[A-Za-z0-9-_=]+\\.[A-Za-z0-9-_.+/=]+\").unwrap(),\n        },\n\n        // Database connection strings\n        SecretPattern {\n            name: \"MongoDB Connection String\",\n            description: \"MongoDB connection string with credentials\",\n            regex: Regex::new(r\"mongodb(\\+srv)?://[^:]+:[^@]+@\").unwrap(),\n        },\n        SecretPattern {\n            name: \"PostgreSQL Connection String\",\n            description: \"PostgreSQL connection string with credentials\",\n            regex: Regex::new(r\"postgres(ql)?://[^:]+:[^@]+@\").unwrap(),\n        },\n        SecretPattern {\n            name: \"MySQL Connection String\",\n            description: \"MySQL connection string with credentials\",\n            regex: Regex::new(r\"mysql://[^:]+:[^@]+@\").unwrap(),\n        },\n        SecretPattern {\n            name: \"Redis Connection String\",\n            description: \"Redis connection string with credentials\",\n            regex: Regex::new(r\"redis://[^:]+:[^@]+@\").unwrap(),\n        },\n\n        // Generic credential patterns\n        SecretPattern {\n            name: \"Generic Password Assignment\",\n            description: \"Password assigned in code\",\n            regex: Regex::new(r#\"(?i)(password|passwd|pwd)\\s*[=:]\\s*['\"][^'\"]{8,}['\"]\"#).unwrap(),\n        },\n        SecretPattern {\n            name: \"Generic API Key Assignment\",\n            description: \"API key assigned in code\",\n            regex: Regex::new(r#\"(?i)(api[_-]?key|apikey)\\s*[=:]\\s*['\"][^'\"]{16,}['\"]\"#).unwrap(),\n        },\n        SecretPattern {\n            name: \"Generic Secret Assignment\",\n            description: \"Secret assigned in code\",\n            regex: Regex::new(r#\"(?i)(secret[_-]?key|secretkey)\\s*[=:]\\s*['\"][^'\"]{16,}['\"]\"#).unwrap(),\n        },\n        SecretPattern {\n            name: \"Generic Token Assignment\",\n            description: \"Token assigned in code\",\n            regex: Regex::new(r#\"(?i)(access[_-]?token|auth[_-]?token)\\s*[=:]\\s*['\"][^'\"]{16,}['\"]\"#).unwrap(),\n        },\n\n        // URL with credentials\n        SecretPattern {\n            name: \"URL with Embedded Credentials\",\n            description: \"URL containing username:password\",\n            regex: Regex::new(r\"https?://[^:]+:[^@]+@[^/]+\").unwrap(),\n        },\n    ];\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_github_token_detection() {\n        let pattern = \u0026SECRET_PATTERNS[0]; // GitHub PAT\n        assert!(pattern\n            .regex\n            .is_match(\"ghp_abcdefghijklmnopqrstuvwxyz1234567890\"));\n        assert!(!pattern.regex.is_match(\"ghp_short\"));\n    }\n\n    #[test]\n    fn test_aws_key_detection() {\n        let pattern = \u0026SECRET_PATTERNS[5]; // AWS Access Key\n        assert!(pattern.regex.is_match(\"AKIAIOSFODNN7EXAMPLE\"));\n        assert!(!pattern.regex.is_match(\"NOTANAWSKEY12345678\"));\n    }\n\n    #[test]\n    fn test_stripe_key_detection() {\n        let pattern = \u0026SECRET_PATTERNS[7]; // Stripe Live Key\n        assert!(pattern.regex.is_match(\"sk_live_abcdefghijklmnopqrstuvwx\"));\n        assert!(!pattern.regex.is_match(\"sk_live_short\"));\n    }\n}\n","traces":[{"line":15,"address":[144268,145577,140745,143520,143146,142398,146138,142585,145951,145764,140902,141276,144829,144081,141837,145016,146318,147306,141089,143707,143894,142772,142024,144642,143333,145203,144455,142211,140699,142959,141650,145390,141463],"length":1,"stats":{"Line":4}},{"line":17,"address":[140804],"length":1,"stats":{"Line":2}},{"line":20,"address":[1522521,1522453],"length":1,"stats":{"Line":4}},{"line":22,"address":[1522708],"length":1,"stats":{"Line":2}},{"line":25,"address":[1522610,1522678],"length":1,"stats":{"Line":4}},{"line":27,"address":[1522895],"length":1,"stats":{"Line":2}},{"line":30,"address":[1522865,1522794],"length":1,"stats":{"Line":4}},{"line":32,"address":[1523082],"length":1,"stats":{"Line":2}},{"line":35,"address":[141237,141308],"length":1,"stats":{"Line":4}},{"line":37,"address":[1523269],"length":1,"stats":{"Line":2}},{"line":40,"address":[141424,141495],"length":1,"stats":{"Line":4}},{"line":44,"address":[1523456],"length":1,"stats":{"Line":2}},{"line":47,"address":[1523426,1523355],"length":1,"stats":{"Line":4}},{"line":49,"address":[1523643],"length":1,"stats":{"Line":2}},{"line":52,"address":[1523542,1523613],"length":1,"stats":{"Line":4}},{"line":56,"address":[1523830],"length":1,"stats":{"Line":2}},{"line":59,"address":[1523729,1523800],"length":1,"stats":{"Line":4}},{"line":61,"address":[1524017],"length":1,"stats":{"Line":2}},{"line":64,"address":[1523987,1523916],"length":1,"stats":{"Line":4}},{"line":66,"address":[1524204],"length":1,"stats":{"Line":2}},{"line":69,"address":[1524103,1524174],"length":1,"stats":{"Line":4}},{"line":73,"address":[1524391],"length":1,"stats":{"Line":2}},{"line":76,"address":[1524290,1524361],"length":1,"stats":{"Line":4}},{"line":80,"address":[1524578],"length":1,"stats":{"Line":2}},{"line":83,"address":[1524548,1524477],"length":1,"stats":{"Line":4}},{"line":85,"address":[1524765],"length":1,"stats":{"Line":2}},{"line":88,"address":[1524664,1524735],"length":1,"stats":{"Line":4}},{"line":92,"address":[1524952],"length":1,"stats":{"Line":2}},{"line":95,"address":[1524922,1524851],"length":1,"stats":{"Line":4}},{"line":99,"address":[1525139],"length":1,"stats":{"Line":2}},{"line":102,"address":[1525038,1525109],"length":1,"stats":{"Line":4}},{"line":106,"address":[1525326],"length":1,"stats":{"Line":2}},{"line":109,"address":[1525296,1525225],"length":1,"stats":{"Line":4}},{"line":113,"address":[1525513],"length":1,"stats":{"Line":2}},{"line":116,"address":[1525412,1525483],"length":1,"stats":{"Line":4}},{"line":120,"address":[1525700],"length":1,"stats":{"Line":2}},{"line":123,"address":[1525599,1525670],"length":1,"stats":{"Line":4}},{"line":127,"address":[1525887],"length":1,"stats":{"Line":2}},{"line":130,"address":[1525786,1525857],"length":1,"stats":{"Line":4}},{"line":134,"address":[1526074],"length":1,"stats":{"Line":2}},{"line":137,"address":[144229,144300],"length":1,"stats":{"Line":4}},{"line":139,"address":[1526261],"length":1,"stats":{"Line":2}},{"line":142,"address":[144416,144487],"length":1,"stats":{"Line":4}},{"line":146,"address":[1526448],"length":1,"stats":{"Line":2}},{"line":149,"address":[1526347,1526418],"length":1,"stats":{"Line":4}},{"line":151,"address":[1526635],"length":1,"stats":{"Line":2}},{"line":154,"address":[1526534,1526605],"length":1,"stats":{"Line":4}},{"line":156,"address":[1526822],"length":1,"stats":{"Line":2}},{"line":159,"address":[145048,144977],"length":1,"stats":{"Line":4}},{"line":161,"address":[1527009],"length":1,"stats":{"Line":2}},{"line":164,"address":[1526908,1526979],"length":1,"stats":{"Line":4}},{"line":168,"address":[1527196],"length":1,"stats":{"Line":2}},{"line":171,"address":[145422,145351],"length":1,"stats":{"Line":4}},{"line":173,"address":[1527383],"length":1,"stats":{"Line":2}},{"line":176,"address":[145538,145609],"length":1,"stats":{"Line":4}},{"line":178,"address":[1527570],"length":1,"stats":{"Line":2}},{"line":181,"address":[1527540,1527469],"length":1,"stats":{"Line":4}},{"line":183,"address":[1527757],"length":1,"stats":{"Line":2}},{"line":186,"address":[1527727,1527656],"length":1,"stats":{"Line":4}},{"line":190,"address":[1527944],"length":1,"stats":{"Line":2}},{"line":193,"address":[1527914,1527843],"length":1,"stats":{"Line":4}}],"covered":61,"coverable":61},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","results.rs"],"content":"//! Audit results structures\n\nuse serde::{Deserialize, Serialize};\n\n/// Severity levels for findings\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum Severity {\n    /// Critical issues that must be resolved\n    Critical,\n    /// Warnings that should be addressed\n    Warning,\n    /// Informational suggestions\n    Info,\n}\n\nimpl Severity {\n    #[allow(dead_code)]\n    pub fn from_string(s: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"critical\" | \"error\" =\u003e Some(Self::Critical),\n            \"warning\" | \"warn\" =\u003e Some(Self::Warning),\n            \"info\" | \"information\" | \"note\" =\u003e Some(Self::Info),\n            _ =\u003e None,\n        }\n    }\n}\n\n/// A single audit finding\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Finding {\n    /// Unique rule identifier (e.g., \"SEC001\")\n    pub rule_id: String,\n\n    /// Category of the rule (e.g., \"secrets\", \"docs\")\n    pub category: String,\n\n    /// Severity of the finding\n    pub severity: Severity,\n\n    /// Short message describing the finding\n    pub message: String,\n\n    /// Optional file location (e.g., \"src/config.ts:42\")\n    pub location: Option\u003cString\u003e,\n\n    /// Detailed description of the issue\n    pub description: Option\u003cString\u003e,\n\n    /// Suggested remediation steps\n    pub remediation: Option\u003cString\u003e,\n}\n\nimpl Finding {\n    /// Create a new finding\n    pub fn new(\n        rule_id: impl Into\u003cString\u003e,\n        category: impl Into\u003cString\u003e,\n        severity: Severity,\n        message: impl Into\u003cString\u003e,\n    ) -\u003e Self {\n        Self {\n            rule_id: rule_id.into(),\n            category: category.into(),\n            severity,\n            message: message.into(),\n            location: None,\n            description: None,\n            remediation: None,\n        }\n    }\n\n    /// Set the location\n    pub fn with_location(mut self, location: impl Into\u003cString\u003e) -\u003e Self {\n        self.location = Some(location.into());\n        self\n    }\n\n    /// Set the description\n    pub fn with_description(mut self, description: impl Into\u003cString\u003e) -\u003e Self {\n        self.description = Some(description.into());\n        self\n    }\n\n    /// Set the remediation\n    pub fn with_remediation(mut self, remediation: impl Into\u003cString\u003e) -\u003e Self {\n        self.remediation = Some(remediation.into());\n        self\n    }\n}\n\n/// Collection of audit results\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AuditResults {\n    /// Repository name\n    pub repository_name: String,\n\n    /// Preset used for the audit\n    pub preset: String,\n\n    /// List of findings\n    findings: Vec\u003cFinding\u003e,\n}\n\nimpl AuditResults {\n    /// Create new audit results\n    pub fn new(repository_name: impl Into\u003cString\u003e, preset: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            repository_name: repository_name.into(),\n            preset: preset.into(),\n            findings: Vec::new(),\n        }\n    }\n\n    /// Add a finding\n    #[allow(dead_code)]\n    pub fn add_finding(\u0026mut self, finding: Finding) {\n        self.findings.push(finding);\n    }\n\n    /// Add multiple findings\n    pub fn add_findings(\u0026mut self, findings: impl IntoIterator\u003cItem = Finding\u003e) {\n        self.findings.extend(findings);\n    }\n\n    /// Get all findings\n    pub fn findings(\u0026self) -\u003e \u0026[Finding] {\n        \u0026self.findings\n    }\n\n    /// Get findings by severity\n    pub fn findings_by_severity(\u0026self, severity: Severity) -\u003e impl Iterator\u003cItem = \u0026Finding\u003e {\n        self.findings.iter().filter(move |f| f.severity == severity)\n    }\n\n    /// Get findings by category\n    pub fn findings_by_category\u003c'a\u003e(\n        \u0026'a self,\n        category: \u0026'a str,\n    ) -\u003e impl Iterator\u003cItem = \u0026'a Finding\u003e {\n        self.findings.iter().filter(move |f| f.category == category)\n    }\n\n    /// Count findings by severity\n    pub fn count_by_severity(\u0026self, severity: Severity) -\u003e usize {\n        self.findings\n            .iter()\n            .filter(|f| f.severity == severity)\n            .count()\n    }\n\n    /// Check if there are any critical findings\n    pub fn has_critical(\u0026self) -\u003e bool {\n        self.findings\n            .iter()\n            .any(|f| f.severity == Severity::Critical)\n    }\n\n    /// Check if there are any warnings\n    pub fn has_warnings(\u0026self) -\u003e bool {\n        self.findings\n            .iter()\n            .any(|f| f.severity == Severity::Warning)\n    }\n\n    /// Get total number of findings\n    #[allow(dead_code)]\n    pub fn total_count(\u0026self) -\u003e usize {\n        self.findings.len()\n    }\n\n    /// Check if there are no findings\n    #[allow(dead_code)]\n    pub fn is_clean(\u0026self) -\u003e bool {\n        self.findings.is_empty()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_finding_builder() {\n        let finding = Finding::new(\"SEC001\", \"secrets\", Severity::Critical, \"Secret detected\")\n            .with_location(\"src/config.ts:42\")\n            .with_description(\"A hardcoded secret was found\")\n            .with_remediation(\"Move the secret to environment variables\");\n\n        assert_eq!(finding.rule_id, \"SEC001\");\n        assert_eq!(finding.location, Some(\"src/config.ts:42\".to_string()));\n    }\n\n    #[test]\n    fn test_audit_results() {\n        let mut results = AuditResults::new(\"test-repo\", \"opensource\");\n\n        results.add_finding(Finding::new(\n            \"SEC001\",\n            \"secrets\",\n            Severity::Critical,\n            \"Secret found\",\n        ));\n        results.add_finding(Finding::new(\n            \"DOC001\",\n            \"docs\",\n            Severity::Warning,\n            \"README missing\",\n        ));\n\n        assert_eq!(results.total_count(), 2);\n        assert!(results.has_critical());\n        assert!(results.has_warnings());\n        assert_eq!(results.count_by_severity(Severity::Critical), 1);\n    }\n}\n","traces":[{"line":19,"address":[1074104,1074098,1073600],"length":1,"stats":{"Line":0}},{"line":20,"address":[1073623,1073712],"length":1,"stats":{"Line":0}},{"line":21,"address":[1073728],"length":1,"stats":{"Line":0}},{"line":22,"address":[1073832],"length":1,"stats":{"Line":0}},{"line":23,"address":[1073936],"length":1,"stats":{"Line":0}},{"line":24,"address":[1074070],"length":1,"stats":{"Line":0}},{"line":56,"address":[1098476,1098496,1097104,1097808,1097746,1097780],"length":1,"stats":{"Line":10}},{"line":63,"address":[],"length":0,"stats":{"Line":10}},{"line":64,"address":[],"length":0,"stats":{"Line":10}},{"line":66,"address":[418442,419197],"length":1,"stats":{"Line":10}},{"line":74,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[420163,420222,419642,419704,419902,419961],"length":1,"stats":{"Line":12}},{"line":76,"address":[1098757,1099011,1099272],"length":1,"stats":{"Line":8}},{"line":80,"address":[420384,420615,420908,420640],"length":1,"stats":{"Line":4}},{"line":81,"address":[420698,420473,420414,420760],"length":1,"stats":{"Line":8}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":87,"address":[420958,421017,421258,421320],"length":1,"stats":{"Line":8}},{"line":88,"address":[1100113,1100383],"length":1,"stats":{"Line":4}},{"line":107,"address":[421504,421855,421888,422196,421861],"length":1,"stats":{"Line":10}},{"line":109,"address":[],"length":0,"stats":{"Line":13}},{"line":110,"address":[421988,421641],"length":1,"stats":{"Line":11}},{"line":111,"address":[1100976,1100600],"length":1,"stats":{"Line":13}},{"line":117,"address":[1074128],"length":1,"stats":{"Line":8}},{"line":118,"address":[1074133],"length":1,"stats":{"Line":8}},{"line":122,"address":[422224],"length":1,"stats":{"Line":3}},{"line":123,"address":[422229],"length":1,"stats":{"Line":3}},{"line":127,"address":[1292448],"length":1,"stats":{"Line":2}},{"line":128,"address":[1292453],"length":1,"stats":{"Line":2}},{"line":132,"address":[1292464],"length":1,"stats":{"Line":0}},{"line":133,"address":[1101184,1101204],"length":1,"stats":{"Line":0}},{"line":137,"address":[1074272],"length":1,"stats":{"Line":8}},{"line":141,"address":[1074324],"length":1,"stats":{"Line":24}},{"line":145,"address":[1074384],"length":1,"stats":{"Line":2}},{"line":146,"address":[1074400],"length":1,"stats":{"Line":2}},{"line":148,"address":[422369,422352],"length":1,"stats":{"Line":4}},{"line":153,"address":[1074464],"length":1,"stats":{"Line":2}},{"line":154,"address":[1074473],"length":1,"stats":{"Line":2}},{"line":156,"address":[422400,422425],"length":1,"stats":{"Line":4}},{"line":160,"address":[1074528],"length":1,"stats":{"Line":2}},{"line":161,"address":[1074537],"length":1,"stats":{"Line":2}},{"line":163,"address":[422464,422489],"length":1,"stats":{"Line":4}},{"line":168,"address":[1074592],"length":1,"stats":{"Line":2}},{"line":169,"address":[1074597],"length":1,"stats":{"Line":2}},{"line":174,"address":[1074608],"length":1,"stats":{"Line":0}},{"line":175,"address":[1074613],"length":1,"stats":{"Line":0}}],"covered":36,"coverable":46},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","scanner","filesystem.rs"],"content":"//! File system scanning utilities\n\nuse ignore::WalkBuilder;\nuse rayon::prelude::*;\nuse std::path::Path;\n\n/// Information about a file in the repository\n#[derive(Debug, Clone)]\npub struct FileInfo {\n    /// Relative path from repository root\n    pub path: String,\n    /// File size in bytes\n    pub size: u64,\n    /// Whether the file is a directory\n    #[allow(dead_code)]\n    pub is_dir: bool,\n}\n\n/// Scan a directory and return information about all files\n///\n/// Uses parallel processing for better performance on large repositories.\npub fn scan_directory(root: \u0026Path) -\u003e Vec\u003cFileInfo\u003e {\n    let walker = WalkBuilder::new(root)\n        .hidden(false)\n        .git_ignore(true)\n        .git_global(true)\n        .git_exclude(true)\n        .ignore(true)\n        .parents(true)\n        .build();\n\n    walker\n        .into_iter()\n        .par_bridge()\n        .filter_map(|entry_result| {\n            let entry = entry_result.ok()?;\n            let path = entry.path();\n\n            // Skip the root directory itself\n            if path == root {\n                return None;\n            }\n\n            // Skip .git directory\n            if path.components().any(|c| c.as_os_str() == \".git\") {\n                return None;\n            }\n\n            // Get relative path - handle errors gracefully\n            let relative_path = match path.strip_prefix(root) {\n                Ok(stripped) =\u003e stripped\n                    .to_str()\n                    .map(|s| s.to_string())\n                    .unwrap_or_else(|| stripped.to_string_lossy().to_string()),\n                Err(_) =\u003e {\n                    return None;\n                }\n            };\n\n            if relative_path.is_empty() {\n                return None;\n            }\n\n            // Get file metadata\n            let metadata = entry.metadata().ok()?;\n\n            Some(FileInfo {\n                path: relative_path,\n                size: metadata.len(),\n                is_dir: metadata.is_dir(),\n            })\n        })\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_scan_directory() {\n        let dir = tempdir().unwrap();\n        let root = dir.path();\n\n        // Create test files\n        fs::write(root.join(\"test.txt\"), \"hello\").unwrap();\n        fs::create_dir(root.join(\"subdir\")).unwrap();\n        fs::write(root.join(\"subdir/nested.txt\"), \"world\").unwrap();\n\n        let files = scan_directory(root);\n\n        assert!(files.iter().any(|f| f.path == \"test.txt\"));\n        assert!(files\n            .iter()\n            .any(|f| f.path == \"subdir/nested.txt\" || f.path == \"subdir\\\\nested.txt\"));\n    }\n}\n","traces":[{"line":22,"address":[447536,447507,447008],"length":1,"stats":{"Line":2}},{"line":23,"address":[447143,447035],"length":1,"stats":{"Line":5}},{"line":32,"address":[447357],"length":1,"stats":{"Line":3}},{"line":35,"address":[1135479,1135554,1134032],"length":1,"stats":{"Line":2}},{"line":36,"address":[1134090],"length":1,"stats":{"Line":2}},{"line":37,"address":[1134402,1134493],"length":1,"stats":{"Line":4}},{"line":40,"address":[1134509],"length":1,"stats":{"Line":2}},{"line":41,"address":[1134588],"length":1,"stats":{"Line":2}},{"line":45,"address":[1135568,1135577,1134545,1134614],"length":1,"stats":{"Line":8}},{"line":46,"address":[1134694],"length":1,"stats":{"Line":0}},{"line":50,"address":[1134643,1134722],"length":1,"stats":{"Line":4}},{"line":51,"address":[1134795],"length":1,"stats":{"Line":2}},{"line":53,"address":[1135648,1135670],"length":1,"stats":{"Line":4}},{"line":54,"address":[1135696,1135720,1134919],"length":1,"stats":{"Line":2}},{"line":56,"address":[1134777],"length":1,"stats":{"Line":0}},{"line":60,"address":[1134935,1134991],"length":1,"stats":{"Line":4}},{"line":61,"address":[1135032],"length":1,"stats":{"Line":0}},{"line":65,"address":[1134997,1135485,1135050],"length":1,"stats":{"Line":4}},{"line":67,"address":[1135358],"length":1,"stats":{"Line":2}},{"line":68,"address":[1135226],"length":1,"stats":{"Line":2}},{"line":69,"address":[1135266],"length":1,"stats":{"Line":2}},{"line":70,"address":[1135330],"length":1,"stats":{"Line":2}}],"covered":19,"coverable":22},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","scanner","git.rs"],"content":"//! Git repository utilities\n\nuse std::path::Path;\nuse std::process::Command;\n\n/// Get the repository name from git remote\npub fn get_repository_name(root: \u0026Path) -\u003e Option\u003cString\u003e {\n    // Try to get the remote URL\n    let output = Command::new(\"git\")\n        .args([\"remote\", \"get-url\", \"origin\"])\n        .current_dir(root)\n        .output()\n        .ok()?;\n\n    if !output.status.success() {\n        return None;\n    }\n\n    let url = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n    parse_repo_name_from_url(\u0026url)\n}\n\n/// Parse repository name from a git URL\nfn parse_repo_name_from_url(url: \u0026str) -\u003e Option\u003cString\u003e {\n    // Handle SSH URLs: git@github.com:owner/repo.git\n    if url.starts_with(\"git@\") {\n        let parts: Vec\u003c\u0026str\u003e = url.split(':').collect();\n        if parts.len() == 2 {\n            let repo_path = parts[1].trim_end_matches(\".git\");\n            return Some(repo_path.to_string());\n        }\n    }\n\n    // Handle HTTPS URLs: https://github.com/owner/repo.git\n    if url.starts_with(\"https://\") || url.starts_with(\"http://\") {\n        let url = url.trim_end_matches(\".git\");\n        let parts: Vec\u003c\u0026str\u003e = url.split('/').collect();\n        if parts.len() \u003e= 2 {\n            let owner = parts[parts.len() - 2];\n            let repo = parts[parts.len() - 1];\n            return Some(format!(\"{}/{}\", owner, repo));\n        }\n    }\n\n    None\n}\n\n/// Get the default branch name\n#[allow(dead_code)]\npub fn get_default_branch(root: \u0026Path) -\u003e Option\u003cString\u003e {\n    // Try to get from git symbolic-ref\n    let output = Command::new(\"git\")\n        .args([\"symbolic-ref\", \"refs/remotes/origin/HEAD\", \"--short\"])\n        .current_dir(root)\n        .output()\n        .ok()?;\n\n    if output.status.success() {\n        let branch = String::from_utf8_lossy(\u0026output.stdout)\n            .trim()\n            .trim_start_matches(\"origin/\")\n            .to_string();\n        if !branch.is_empty() {\n            return Some(branch);\n        }\n    }\n\n    // Fall back to checking for main or master\n    let branches = [\"main\", \"master\"];\n    for branch in branches {\n        let output = Command::new(\"git\")\n            .args([\n                \"show-ref\",\n                \"--verify\",\n                \"--quiet\",\n                \u0026format!(\"refs/heads/{}\", branch),\n            ])\n            .current_dir(root)\n            .output()\n            .ok()?;\n\n        if output.status.success() {\n            return Some(branch.to_string());\n        }\n    }\n\n    None\n}\n\n/// Check if the repository is a git repository\n#[allow(dead_code)]\npub fn is_git_repository(root: \u0026Path) -\u003e bool {\n    root.join(\".git\").exists()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_ssh_url() {\n        let url = \"git@github.com:owner/repo.git\";\n        assert_eq!(\n            parse_repo_name_from_url(url),\n            Some(\"owner/repo\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_parse_https_url() {\n        let url = \"https://github.com/owner/repo.git\";\n        assert_eq!(\n            parse_repo_name_from_url(url),\n            Some(\"owner/repo\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_parse_https_url_without_git() {\n        let url = \"https://github.com/owner/repo\";\n        assert_eq!(\n            parse_repo_name_from_url(url),\n            Some(\"owner/repo\".to_string())\n        );\n    }\n}\n","traces":[{"line":7,"address":[1129850,1128880,1129856],"length":1,"stats":{"Line":3}},{"line":9,"address":[1129118,1128923,1129047],"length":1,"stats":{"Line":12}},{"line":10,"address":[1128958],"length":1,"stats":{"Line":3}},{"line":15,"address":[1129443],"length":1,"stats":{"Line":3}},{"line":16,"address":[1129477],"length":1,"stats":{"Line":3}},{"line":19,"address":[1129505,1129557],"length":1,"stats":{"Line":0}},{"line":20,"address":[1129776],"length":1,"stats":{"Line":0}},{"line":24,"address":[1129888,1131133,1131139],"length":1,"stats":{"Line":3}},{"line":26,"address":[1129959],"length":1,"stats":{"Line":3}},{"line":27,"address":[1130038],"length":1,"stats":{"Line":2}},{"line":28,"address":[1130162,1130097],"length":1,"stats":{"Line":4}},{"line":29,"address":[1130228,1130168],"length":1,"stats":{"Line":4}},{"line":30,"address":[1130290],"length":1,"stats":{"Line":2}},{"line":35,"address":[1129994,1130395],"length":1,"stats":{"Line":2}},{"line":36,"address":[1130432],"length":1,"stats":{"Line":3}},{"line":37,"address":[903567],"length":1,"stats":{"Line":3}},{"line":38,"address":[1130527,1130618],"length":1,"stats":{"Line":7}},{"line":39,"address":[1130640],"length":1,"stats":{"Line":4}},{"line":40,"address":[1130771],"length":1,"stats":{"Line":4}},{"line":41,"address":[1130901],"length":1,"stats":{"Line":4}},{"line":45,"address":[903650],"length":1,"stats":{"Line":0}},{"line":50,"address":[1133602,1133558,1131152],"length":1,"stats":{"Line":0}},{"line":52,"address":[1131207,1131337,1131420],"length":1,"stats":{"Line":0}},{"line":53,"address":[1131248],"length":1,"stats":{"Line":0}},{"line":58,"address":[904858],"length":1,"stats":{"Line":0}},{"line":59,"address":[1131901,1132042],"length":1,"stats":{"Line":0}},{"line":63,"address":[1132202],"length":1,"stats":{"Line":0}},{"line":64,"address":[1132231],"length":1,"stats":{"Line":0}},{"line":69,"address":[1131789],"length":1,"stats":{"Line":0}},{"line":70,"address":[1131843,1132457,1132356],"length":1,"stats":{"Line":0}},{"line":71,"address":[906095,905640],"length":1,"stats":{"Line":0}},{"line":72,"address":[1132878],"length":1,"stats":{"Line":0}},{"line":76,"address":[1132628,1132699],"length":1,"stats":{"Line":0}},{"line":82,"address":[1133412],"length":1,"stats":{"Line":0}},{"line":83,"address":[1133459],"length":1,"stats":{"Line":0}},{"line":87,"address":[1132586],"length":1,"stats":{"Line":0}},{"line":92,"address":[1133803,1133648,1133797],"length":1,"stats":{"Line":0}},{"line":93,"address":[1133764,1133668],"length":1,"stats":{"Line":0}}],"covered":18,"coverable":38},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","scanner","mod.rs"],"content":"//! Scanner module - File system and repository scanning\n\nmod filesystem;\nmod git;\n\nuse std::path::PathBuf;\n\npub use filesystem::FileInfo;\n\n/// Main scanner for repository analysis\n///\n/// The `Scanner` provides access to repository files and metadata.\n/// It caches file information for efficient access during rule execution.\npub struct Scanner {\n    /// Root directory of the repository\n    root: PathBuf,\n    /// Cached file information\n    file_cache: Vec\u003cFileInfo\u003e,\n}\n\nimpl Scanner {\n    /// Create a new scanner for the given root directory\n    ///\n    /// Scans the directory and caches file information for later use.\n    ///\n    /// # Arguments\n    ///\n    /// * `root` - The root directory of the repository to scan\n    ///\n    /// # Returns\n    ///\n    /// A new `Scanner` instance with cached file information\n    pub fn new(root: PathBuf) -\u003e Self {\n        let file_cache = filesystem::scan_directory(\u0026root);\n\n        Self { root, file_cache }\n    }\n\n    /// Get the repository name from the root path or git remote\n    ///\n    /// First attempts to get the repository name from git remote.\n    /// Falls back to the directory name if git information is unavailable.\n    ///\n    /// # Returns\n    ///\n    /// The repository name as a string\n    pub fn repository_name(\u0026self) -\u003e String {\n        // Try to get from git remote first\n        if let Some(name) = git::get_repository_name(\u0026self.root) {\n            return name;\n        }\n\n        // Fall back to directory name\n        self.root\n            .file_name()\n            .and_then(|n| n.to_str())\n            .map(|s| s.to_string())\n            .unwrap_or_else(|| {\n                // If directory name contains non-UTF8, use lossy conversion\n                self.root.to_string_lossy().to_string()\n            })\n    }\n\n    /// Check if a file exists in the repository\n    ///\n    /// # Arguments\n    ///\n    /// * `path` - Relative path to the file from repository root\n    ///\n    /// # Returns\n    ///\n    /// `true` if the file exists, `false` otherwise\n    pub fn file_exists(\u0026self, path: \u0026str) -\u003e bool {\n        self.root.join(path).exists()\n    }\n\n    /// Check if a directory exists in the repository\n    ///\n    /// # Arguments\n    ///\n    /// * `path` - Relative path to the directory from repository root\n    ///\n    /// # Returns\n    ///\n    /// `true` if the directory exists, `false` otherwise\n    pub fn directory_exists(\u0026self, path: \u0026str) -\u003e bool {\n        let full_path = self.root.join(path);\n        full_path.exists() \u0026\u0026 full_path.is_dir()\n    }\n\n    /// Read file content as a string\n    ///\n    /// # Arguments\n    ///\n    /// * `path` - Relative path to the file from repository root\n    ///\n    /// # Returns\n    ///\n    /// The file content as a string, or an I/O error if reading fails\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the file cannot be read or is not valid UTF-8\n    pub fn read_file(\u0026self, path: \u0026str) -\u003e std::io::Result\u003cString\u003e {\n        std::fs::read_to_string(self.root.join(path))\n    }\n\n    /// Get files with specific extensions\n    ///\n    /// # Arguments\n    ///\n    /// * `extensions` - Slice of file extensions (without the dot), e.g., `[\"rs\", \"toml\"]`\n    ///\n    /// # Returns\n    ///\n    /// A vector of references to `FileInfo` for matching files\n    pub fn files_with_extensions(\u0026self, extensions: \u0026[\u0026str]) -\u003e Vec\u003c\u0026FileInfo\u003e {\n        self.file_cache\n            .iter()\n            .filter(|f| {\n                extensions\n                    .iter()\n                    .any(|ext| f.path.ends_with(\u0026format!(\".{}\", ext)))\n            })\n            .collect()\n    }\n\n    /// Get files matching a glob pattern\n    ///\n    /// Supports simple glob patterns like `*.rs`, `**/test/**`, etc.\n    ///\n    /// # Arguments\n    ///\n    /// * `pattern` - Glob pattern to match against file paths\n    ///\n    /// # Returns\n    ///\n    /// A vector of references to `FileInfo` for matching files\n    pub fn files_matching_pattern(\u0026self, pattern: \u0026str) -\u003e Vec\u003c\u0026FileInfo\u003e {\n        self.file_cache\n            .iter()\n            .filter(|f| {\n                if pattern.contains('*') {\n                    glob_match(pattern, \u0026f.path)\n                } else {\n                    f.path.ends_with(pattern) || f.path.contains(pattern)\n                }\n            })\n            .collect()\n    }\n\n    /// Get files larger than a given size in bytes\n    ///\n    /// # Arguments\n    ///\n    /// * `size` - Minimum file size in bytes\n    ///\n    /// # Returns\n    ///\n    /// A vector of references to `FileInfo` for files larger than the specified size\n    pub fn files_larger_than(\u0026self, size: u64) -\u003e Vec\u003c\u0026FileInfo\u003e {\n        self.file_cache.iter().filter(|f| f.size \u003e size).collect()\n    }\n\n    /// Get files in a specific directory\n    ///\n    /// # Arguments\n    ///\n    /// * `dir` - Directory path (with or without trailing slash)\n    ///\n    /// # Returns\n    ///\n    /// A vector of references to `FileInfo` for files in the specified directory\n    pub fn files_in_directory(\u0026self, dir: \u0026str) -\u003e Vec\u003c\u0026FileInfo\u003e {\n        let dir_path = if dir.ends_with('/') {\n            dir.to_string()\n        } else {\n            format!(\"{}/\", dir)\n        };\n\n        self.file_cache\n            .iter()\n            .filter(|f| f.path.starts_with(\u0026dir_path) || f.path.starts_with(dir))\n            .collect()\n    }\n\n    /// Get all files in the repository\n    ///\n    /// # Returns\n    ///\n    /// A slice of all `FileInfo` entries\n    #[allow(dead_code)]\n    pub fn all_files(\u0026self) -\u003e \u0026[FileInfo] {\n        \u0026self.file_cache\n    }\n}\n\n/// Simple glob matching\nfn glob_match(pattern: \u0026str, text: \u0026str) -\u003e bool {\n    if pattern == \"*\" {\n        return true;\n    }\n\n    if pattern.starts_with(\"*.\") {\n        let ext = \u0026pattern[1..];\n        return text.ends_with(ext);\n    }\n\n    if pattern.contains(\"**\") {\n        let parts: Vec\u003c\u0026str\u003e = pattern.split(\"**\").collect();\n        if parts.len() == 2 {\n            let prefix = parts[0].trim_end_matches('/');\n            let suffix = parts[1].trim_start_matches('/');\n\n            if !prefix.is_empty() \u0026\u0026 !text.starts_with(prefix) {\n                return false;\n            }\n            if !suffix.is_empty() {\n                return text.ends_with(suffix) || text.contains(\u0026format!(\"/{}\", suffix));\n            }\n            return true;\n        }\n    }\n\n    text.contains(pattern.trim_start_matches('*').trim_end_matches('*'))\n}\n","traces":[{"line":33,"address":[1161008,1161204],"length":1,"stats":{"Line":2}},{"line":34,"address":[1161033,1161099],"length":1,"stats":{"Line":4}},{"line":47,"address":[1161232],"length":1,"stats":{"Line":3}},{"line":49,"address":[1161262],"length":1,"stats":{"Line":5}},{"line":50,"address":[1161349],"length":1,"stats":{"Line":0}},{"line":54,"address":[1161392],"length":1,"stats":{"Line":3}},{"line":56,"address":[859680,859694],"length":1,"stats":{"Line":4}},{"line":57,"address":[859734,859712],"length":1,"stats":{"Line":4}},{"line":58,"address":[859879,859885,859760],"length":1,"stats":{"Line":0}},{"line":60,"address":[1584034],"length":1,"stats":{"Line":0}},{"line":73,"address":[1161641,1161472,1161635],"length":1,"stats":{"Line":2}},{"line":74,"address":[1161602,1161501],"length":1,"stats":{"Line":4}},{"line":86,"address":[1161664,1161927,1161921],"length":1,"stats":{"Line":2}},{"line":87,"address":[1161699],"length":1,"stats":{"Line":2}},{"line":88,"address":[1161741,1161809,1161894],"length":1,"stats":{"Line":4}},{"line":104,"address":[1161952],"length":1,"stats":{"Line":2}},{"line":105,"address":[1162002],"length":1,"stats":{"Line":2}},{"line":117,"address":[1162064],"length":1,"stats":{"Line":2}},{"line":118,"address":[1162116],"length":1,"stats":{"Line":2}},{"line":120,"address":[859904],"length":1,"stats":{"Line":2}},{"line":121,"address":[859925,859955],"length":1,"stats":{"Line":5}},{"line":123,"address":[1584240,1584260,1584208],"length":1,"stats":{"Line":9}},{"line":139,"address":[1162192],"length":1,"stats":{"Line":3}},{"line":140,"address":[468952],"length":1,"stats":{"Line":3}},{"line":142,"address":[860256],"length":1,"stats":{"Line":4}},{"line":143,"address":[860280],"length":1,"stats":{"Line":6}},{"line":144,"address":[860361],"length":1,"stats":{"Line":3}},{"line":146,"address":[860430,860310],"length":1,"stats":{"Line":6}},{"line":161,"address":[1162304],"length":1,"stats":{"Line":2}},{"line":162,"address":[860506,860496],"length":1,"stats":{"Line":6}},{"line":174,"address":[1162791,1162416,1162797],"length":1,"stats":{"Line":3}},{"line":175,"address":[1162456],"length":1,"stats":{"Line":3}},{"line":176,"address":[1162597],"length":1,"stats":{"Line":0}},{"line":178,"address":[1162481],"length":1,"stats":{"Line":3}},{"line":181,"address":[1162695,1162623],"length":1,"stats":{"Line":6}},{"line":183,"address":[1584784,1584807],"length":1,"stats":{"Line":4}},{"line":193,"address":[1162816],"length":1,"stats":{"Line":10}},{"line":194,"address":[1162821],"length":1,"stats":{"Line":2}},{"line":199,"address":[1164027,1162832,1164004],"length":1,"stats":{"Line":3}},{"line":200,"address":[469601],"length":1,"stats":{"Line":2}},{"line":201,"address":[1162946],"length":1,"stats":{"Line":0}},{"line":204,"address":[469626],"length":1,"stats":{"Line":2}},{"line":205,"address":[1163003],"length":1,"stats":{"Line":2}},{"line":206,"address":[469796],"length":1,"stats":{"Line":2}},{"line":209,"address":[1162959],"length":1,"stats":{"Line":2}},{"line":210,"address":[469902],"length":1,"stats":{"Line":0}},{"line":211,"address":[1163322,1163257],"length":1,"stats":{"Line":0}},{"line":212,"address":[1163328,1163387],"length":1,"stats":{"Line":0}},{"line":213,"address":[1163462],"length":1,"stats":{"Line":0}},{"line":215,"address":[1163655,1163568],"length":1,"stats":{"Line":0}},{"line":216,"address":[1163661],"length":1,"stats":{"Line":0}},{"line":218,"address":[1163692,1163624],"length":1,"stats":{"Line":0}},{"line":219,"address":[1163708,1163753],"length":1,"stats":{"Line":0}},{"line":221,"address":[1163739],"length":1,"stats":{"Line":0}},{"line":225,"address":[1163096],"length":1,"stats":{"Line":2}}],"covered":41,"coverable":55},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","utils","mod.rs"],"content":"//! Utility modules for RepoLens\n\npub mod prerequisites;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","utils","prerequisites.rs"],"content":"//! Prerequisites checking for RepoLens initialization\n//!\n//! This module verifies that required tools and configurations are available\n//! before running RepoLens commands.\n\nuse anyhow::{bail, Context, Result};\nuse colored::Colorize;\nuse std::path::Path;\nuse std::process::Command;\n\n/// Level of importance for a prerequisite check\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum CheckLevel {\n    /// Required for operation - failure blocks execution\n    Required,\n    /// Optional - failure generates a warning\n    Optional,\n}\n\n/// Status of a prerequisite check\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum CheckStatus {\n    /// Check passed successfully\n    Ok,\n    /// Check failed\n    Failed,\n    /// Check was skipped (due to dependency failure)\n    Skipped,\n}\n\n/// Result of a single prerequisite check\n#[derive(Debug, Clone)]\npub struct CheckResult {\n    /// Name of the check\n    pub name: String,\n    /// Whether this check is required or optional\n    pub level: CheckLevel,\n    /// Status of the check\n    pub status: CheckStatus,\n    /// Human-readable message (shown on failure)\n    pub message: Option\u003cString\u003e,\n    /// Suggested fix for the issue\n    pub fix: Option\u003cString\u003e,\n}\n\nimpl CheckResult {\n    /// Create a successful check result\n    pub fn ok(name: \u0026str, level: CheckLevel) -\u003e Self {\n        Self {\n            name: name.to_string(),\n            level,\n            status: CheckStatus::Ok,\n            message: None,\n            fix: None,\n        }\n    }\n\n    /// Create a failed check result\n    pub fn failed(name: \u0026str, level: CheckLevel, message: \u0026str, fix: Option\u003c\u0026str\u003e) -\u003e Self {\n        Self {\n            name: name.to_string(),\n            level,\n            status: CheckStatus::Failed,\n            message: Some(message.to_string()),\n            fix: fix.map(|s| s.to_string()),\n        }\n    }\n\n    /// Create a skipped check result\n    pub fn skipped(name: \u0026str, level: CheckLevel) -\u003e Self {\n        Self {\n            name: name.to_string(),\n            level,\n            status: CheckStatus::Skipped,\n            message: None,\n            fix: None,\n        }\n    }\n\n    /// Check if this result represents a failure\n    #[allow(dead_code)]\n    pub fn is_failed(\u0026self) -\u003e bool {\n        self.status == CheckStatus::Failed\n    }\n\n    /// Check if this is a required check that failed\n    pub fn is_required_failure(\u0026self) -\u003e bool {\n        self.level == CheckLevel::Required \u0026\u0026 self.status == CheckStatus::Failed\n    }\n\n    /// Check if this is an optional check that failed\n    pub fn is_optional_failure(\u0026self) -\u003e bool {\n        self.level == CheckLevel::Optional \u0026\u0026 self.status == CheckStatus::Failed\n    }\n}\n\n/// Aggregated report of all prerequisite checks\n#[derive(Debug, Clone)]\npub struct PrerequisitesReport {\n    /// All check results\n    pub checks: Vec\u003cCheckResult\u003e,\n}\n\nimpl PrerequisitesReport {\n    /// Create a new empty report\n    pub fn new() -\u003e Self {\n        Self { checks: Vec::new() }\n    }\n\n    /// Add a check result to the report\n    pub fn add(\u0026mut self, result: CheckResult) {\n        self.checks.push(result);\n    }\n\n    /// Check if all required checks passed\n    pub fn all_required_passed(\u0026self) -\u003e bool {\n        !self.checks.iter().any(|c| c.is_required_failure())\n    }\n\n    /// Get all failed required checks\n    pub fn required_failures(\u0026self) -\u003e Vec\u003c\u0026CheckResult\u003e {\n        self.checks\n            .iter()\n            .filter(|c| c.is_required_failure())\n            .collect()\n    }\n\n    /// Get all failed optional checks (warnings)\n    pub fn optional_failures(\u0026self) -\u003e Vec\u003c\u0026CheckResult\u003e {\n        self.checks\n            .iter()\n            .filter(|c| c.is_optional_failure())\n            .collect()\n    }\n\n    /// Check if there are any warnings\n    pub fn has_warnings(\u0026self) -\u003e bool {\n        self.checks.iter().any(|c| c.is_optional_failure())\n    }\n}\n\nimpl Default for PrerequisitesReport {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n// ============================================================================\n// Check functions\n// ============================================================================\n\n/// Check if git is installed\npub fn check_git_installed() -\u003e CheckResult {\n    let output = Command::new(\"git\").arg(\"--version\").output();\n\n    match output {\n        Ok(o) if o.status.success() =\u003e CheckResult::ok(\"Git installed\", CheckLevel::Required),\n        _ =\u003e CheckResult::failed(\n            \"Git installed\",\n            CheckLevel::Required,\n            \"Git is not installed\",\n            Some(\"Install git: https://git-scm.com/downloads\"),\n        ),\n    }\n}\n\n/// Check if the current directory is a git repository\npub fn check_is_git_repo(root: \u0026Path) -\u003e CheckResult {\n    let git_dir = root.join(\".git\");\n\n    if git_dir.exists() {\n        CheckResult::ok(\"Git repository\", CheckLevel::Required)\n    } else {\n        CheckResult::failed(\n            \"Git repository\",\n            CheckLevel::Required,\n            \"Not a git repository\",\n            Some(\"Run: git init\"),\n        )\n    }\n}\n\n/// Check if GitHub CLI (gh) is installed\npub fn check_gh_installed() -\u003e CheckResult {\n    let output = Command::new(\"gh\").arg(\"--version\").output();\n\n    match output {\n        Ok(o) if o.status.success() =\u003e {\n            CheckResult::ok(\"GitHub CLI installed\", CheckLevel::Required)\n        }\n        _ =\u003e CheckResult::failed(\n            \"GitHub CLI installed\",\n            CheckLevel::Required,\n            \"GitHub CLI (gh) is not installed\",\n            Some(\"Install gh: https://cli.github.com/\"),\n        ),\n    }\n}\n\n/// Check if GitHub CLI is authenticated\npub fn check_gh_authenticated() -\u003e CheckResult {\n    let output = Command::new(\"gh\").args([\"auth\", \"status\"]).output();\n\n    match output {\n        Ok(o) if o.status.success() =\u003e {\n            CheckResult::ok(\"GitHub CLI authenticated\", CheckLevel::Required)\n        }\n        _ =\u003e CheckResult::failed(\n            \"GitHub CLI authenticated\",\n            CheckLevel::Required,\n            \"GitHub CLI is not authenticated\",\n            Some(\"Run: gh auth login\"),\n        ),\n    }\n}\n\n/// Check if a remote origin is configured\npub fn check_remote_origin(root: \u0026Path) -\u003e CheckResult {\n    let output = Command::new(\"git\")\n        .args([\"remote\", \"get-url\", \"origin\"])\n        .current_dir(root)\n        .output();\n\n    match output {\n        Ok(o) if o.status.success() =\u003e {\n            CheckResult::ok(\"Remote origin configured\", CheckLevel::Optional)\n        }\n        _ =\u003e CheckResult::failed(\n            \"Remote origin configured\",\n            CheckLevel::Optional,\n            \"No remote origin configured\",\n            Some(\"Run: git remote add origin \u003curl\u003e\"),\n        ),\n    }\n}\n\n/// Check if the remote origin is a GitHub repository\npub fn check_remote_is_github(root: \u0026Path) -\u003e CheckResult {\n    let output = Command::new(\"git\")\n        .args([\"remote\", \"get-url\", \"origin\"])\n        .current_dir(root)\n        .output();\n\n    match output {\n        Ok(o) if o.status.success() =\u003e {\n            let url = String::from_utf8_lossy(\u0026o.stdout);\n            if url.contains(\"github.com\") {\n                CheckResult::ok(\"Remote is GitHub\", CheckLevel::Optional)\n            } else {\n                CheckResult::failed(\n                    \"Remote is GitHub\",\n                    CheckLevel::Optional,\n                    \"Remote origin is not a GitHub repository\",\n                    Some(\"RepoLens works best with GitHub repositories\"),\n                )\n            }\n        }\n        _ =\u003e CheckResult::skipped(\"Remote is GitHub\", CheckLevel::Optional),\n    }\n}\n\n// ============================================================================\n// Run all checks\n// ============================================================================\n\n/// Options for running prerequisite checks\n#[derive(Debug, Clone, Default)]\npub struct CheckOptions {\n    /// Skip optional checks\n    #[allow(dead_code)]\n    pub skip_optional: bool,\n}\n\n/// Run all prerequisite checks\npub fn run_all_checks(root: \u0026Path, _options: \u0026CheckOptions) -\u003e PrerequisitesReport {\n    let mut report = PrerequisitesReport::new();\n\n    // Required checks\n    let git_installed = check_git_installed();\n    let git_ok = git_installed.status == CheckStatus::Ok;\n    report.add(git_installed);\n\n    if git_ok {\n        report.add(check_is_git_repo(root));\n    } else {\n        report.add(CheckResult::skipped(\"Git repository\", CheckLevel::Required));\n    }\n\n    let gh_installed = check_gh_installed();\n    let gh_ok = gh_installed.status == CheckStatus::Ok;\n    report.add(gh_installed);\n\n    if gh_ok {\n        report.add(check_gh_authenticated());\n    } else {\n        report.add(CheckResult::skipped(\n            \"GitHub CLI authenticated\",\n            CheckLevel::Required,\n        ));\n    }\n\n    // Optional checks (only if git repo exists)\n    let is_repo = report\n        .checks\n        .iter()\n        .find(|c| c.name == \"Git repository\")\n        .map(|c| c.status == CheckStatus::Ok)\n        .unwrap_or(false);\n\n    if is_repo {\n        let remote_result = check_remote_origin(root);\n        let has_remote = remote_result.status == CheckStatus::Ok;\n        report.add(remote_result);\n\n        if has_remote {\n            report.add(check_remote_is_github(root));\n        } else {\n            report.add(CheckResult::skipped(\n                \"Remote is GitHub\",\n                CheckLevel::Optional,\n            ));\n        }\n    } else {\n        report.add(CheckResult::skipped(\n            \"Remote origin configured\",\n            CheckLevel::Optional,\n        ));\n        report.add(CheckResult::skipped(\n            \"Remote is GitHub\",\n            CheckLevel::Optional,\n        ));\n    }\n\n    report\n}\n\n// ============================================================================\n// Display functions\n// ============================================================================\n\n/// Display the full prerequisites report\npub fn display_report(report: \u0026PrerequisitesReport, _verbose: bool) {\n    println!(\"{}\\n\", \"Checking prerequisites...\".bold());\n\n    for check in \u0026report.checks {\n        let icon = match check.status {\n            CheckStatus::Ok =\u003e \"‚úì\".green(),\n            CheckStatus::Failed if check.level == CheckLevel::Required =\u003e \"‚úó\".red(),\n            CheckStatus::Failed =\u003e \"!\".yellow(),\n            CheckStatus::Skipped =\u003e \"‚óã\".dimmed(),\n        };\n\n        let name = match check.status {\n            CheckStatus::Ok =\u003e check.name.normal(),\n            CheckStatus::Failed if check.level == CheckLevel::Required =\u003e check.name.red(),\n            CheckStatus::Failed =\u003e check.name.yellow(),\n            CheckStatus::Skipped =\u003e check.name.dimmed(),\n        };\n\n        let suffix = match check.status {\n            CheckStatus::Skipped =\u003e \" (skipped)\".dimmed().to_string(),\n            CheckStatus::Failed if check.level == CheckLevel::Optional =\u003e {\n                \" (optional)\".dimmed().to_string()\n            }\n            _ =\u003e String::new(),\n        };\n\n        println!(\"  {} {}{}\", icon, name, suffix);\n\n        // Show message and fix for failures\n        if check.status == CheckStatus::Failed {\n            if let Some(msg) = \u0026check.message {\n                println!(\"    {}\", msg.dimmed());\n            }\n            if let Some(fix) = \u0026check.fix {\n                println!(\"    {}: {}\", \"Fix\".cyan(), fix);\n            }\n        }\n    }\n\n    println!();\n}\n\n/// Display error summary for failed required checks\npub fn display_error_summary(report: \u0026PrerequisitesReport) {\n    let failures = report.required_failures();\n    if failures.is_empty() {\n        return;\n    }\n\n    eprintln!(\n        \"{} {} required prerequisite(s) failed:\",\n        \"Error:\".red().bold(),\n        failures.len()\n    );\n\n    for check in failures {\n        eprintln!(\"  {} {}\", \"‚Ä¢\".red(), check.name);\n        if let Some(fix) = \u0026check.fix {\n            eprintln!(\"    {}: {}\", \"Fix\".cyan(), fix);\n        }\n    }\n}\n\n/// Display warnings for failed optional checks\npub fn display_warnings(report: \u0026PrerequisitesReport) {\n    let warnings = report.optional_failures();\n    if warnings.is_empty() {\n        return;\n    }\n\n    println!(\n        \"{} {} optional check(s) failed:\",\n        \"Warning:\".yellow().bold(),\n        warnings.len()\n    );\n\n    for check in warnings {\n        if let Some(msg) = \u0026check.message {\n            println!(\"  {} {}\", \"‚Ä¢\".yellow(), msg);\n        }\n    }\n\n    println!();\n}\n\n// ============================================================================\n// Centralized utility functions (used by other modules)\n// ============================================================================\n\n/// Check if gh CLI is available and authenticated\npub fn is_gh_available() -\u003e bool {\n    Command::new(\"gh\")\n        .args([\"auth\", \"status\"])\n        .output()\n        .map(|o| o.status.success())\n        .unwrap_or(false)\n}\n\n/// Get repository info (owner/name) from GitHub CLI\npub fn get_repo_info() -\u003e Result\u003cString\u003e {\n    let output = Command::new(\"gh\")\n        .args([\n            \"repo\",\n            \"view\",\n            \"--json\",\n            \"nameWithOwner\",\n            \"-q\",\n            \".nameWithOwner\",\n        ])\n        .output()\n        .context(\"Failed to get repository info\")?;\n\n    if !output.status.success() {\n        bail!(\"Failed to get repository info. Make sure you're in a git repository.\");\n    }\n\n    Ok(String::from_utf8_lossy(\u0026output.stdout).trim().to_string())\n}\n","traces":[{"line":48,"address":[956400],"length":1,"stats":{"Line":0}},{"line":50,"address":[1269482],"length":1,"stats":{"Line":0}},{"line":59,"address":[957035,957041,956608],"length":1,"stats":{"Line":0}},{"line":61,"address":[956731],"length":1,"stats":{"Line":0}},{"line":64,"address":[956778,956833],"length":1,"stats":{"Line":0}},{"line":65,"address":[956867],"length":1,"stats":{"Line":0}},{"line":70,"address":[1270096],"length":1,"stats":{"Line":0}},{"line":72,"address":[957098],"length":1,"stats":{"Line":0}},{"line":82,"address":[957264],"length":1,"stats":{"Line":0}},{"line":83,"address":[957269],"length":1,"stats":{"Line":0}},{"line":87,"address":[957296],"length":1,"stats":{"Line":0}},{"line":88,"address":[957309],"length":1,"stats":{"Line":0}},{"line":92,"address":[957376],"length":1,"stats":{"Line":0}},{"line":93,"address":[957389],"length":1,"stats":{"Line":0}},{"line":106,"address":[957456],"length":1,"stats":{"Line":0}},{"line":107,"address":[957469],"length":1,"stats":{"Line":0}},{"line":111,"address":[957520],"length":1,"stats":{"Line":0}},{"line":112,"address":[957525],"length":1,"stats":{"Line":0}},{"line":116,"address":[957552],"length":1,"stats":{"Line":0}},{"line":117,"address":[957561],"length":1,"stats":{"Line":0}},{"line":121,"address":[957616],"length":1,"stats":{"Line":0}},{"line":122,"address":[957648],"length":1,"stats":{"Line":0}},{"line":124,"address":[1073312,1073326],"length":1,"stats":{"Line":0}},{"line":129,"address":[957712],"length":1,"stats":{"Line":0}},{"line":130,"address":[957744],"length":1,"stats":{"Line":0}},{"line":132,"address":[993086,993072],"length":1,"stats":{"Line":0}},{"line":137,"address":[957808],"length":1,"stats":{"Line":0}},{"line":138,"address":[1270857],"length":1,"stats":{"Line":0}},{"line":143,"address":[957872],"length":1,"stats":{"Line":0}},{"line":144,"address":[957880],"length":1,"stats":{"Line":0}},{"line":153,"address":[957904,958597,958510],"length":1,"stats":{"Line":0}},{"line":154,"address":[957921],"length":1,"stats":{"Line":0}},{"line":156,"address":[1271174],"length":1,"stats":{"Line":0}},{"line":157,"address":[958282],"length":1,"stats":{"Line":0}},{"line":160,"address":[958173],"length":1,"stats":{"Line":0}},{"line":162,"address":[958181],"length":1,"stats":{"Line":0}},{"line":168,"address":[958624,958936,958930],"length":1,"stats":{"Line":0}},{"line":169,"address":[958654],"length":1,"stats":{"Line":0}},{"line":171,"address":[958691,958759],"length":1,"stats":{"Line":0}},{"line":172,"address":[958928,958873],"length":1,"stats":{"Line":0}},{"line":176,"address":[1271825],"length":1,"stats":{"Line":0}},{"line":178,"address":[958790],"length":1,"stats":{"Line":0}},{"line":184,"address":[959566,959653,958960],"length":1,"stats":{"Line":0}},{"line":185,"address":[1272017],"length":1,"stats":{"Line":0}},{"line":187,"address":[959190],"length":1,"stats":{"Line":0}},{"line":188,"address":[1272378],"length":1,"stats":{"Line":0}},{"line":189,"address":[959440],"length":1,"stats":{"Line":0}},{"line":193,"address":[959229],"length":1,"stats":{"Line":0}},{"line":195,"address":[959237],"length":1,"stats":{"Line":0}},{"line":201,"address":[960423,959680,960336],"length":1,"stats":{"Line":0}},{"line":202,"address":[959697],"length":1,"stats":{"Line":0}},{"line":204,"address":[959960],"length":1,"stats":{"Line":0}},{"line":205,"address":[960108],"length":1,"stats":{"Line":0}},{"line":206,"address":[960210],"length":1,"stats":{"Line":0}},{"line":210,"address":[959999],"length":1,"stats":{"Line":0}},{"line":212,"address":[960007],"length":1,"stats":{"Line":0}},{"line":218,"address":[961286,960448,961199],"length":1,"stats":{"Line":0}},{"line":219,"address":[960491,960623,960694],"length":1,"stats":{"Line":0}},{"line":220,"address":[1273574],"length":1,"stats":{"Line":0}},{"line":224,"address":[960817],"length":1,"stats":{"Line":0}},{"line":225,"address":[1274005],"length":1,"stats":{"Line":0}},{"line":226,"address":[961073],"length":1,"stats":{"Line":0}},{"line":230,"address":[960856],"length":1,"stats":{"Line":0}},{"line":232,"address":[960864],"length":1,"stats":{"Line":0}},{"line":238,"address":[962391,961312,962304],"length":1,"stats":{"Line":0}},{"line":239,"address":[961487,961558,961355],"length":1,"stats":{"Line":0}},{"line":240,"address":[1274438],"length":1,"stats":{"Line":0}},{"line":244,"address":[961681],"length":1,"stats":{"Line":0}},{"line":245,"address":[1274803],"length":1,"stats":{"Line":0}},{"line":246,"address":[961948,961869],"length":1,"stats":{"Line":0}},{"line":247,"address":[961967,962047],"length":1,"stats":{"Line":0}},{"line":248,"address":[962251,962195],"length":1,"stats":{"Line":0}},{"line":252,"address":[962089],"length":1,"stats":{"Line":0}},{"line":254,"address":[962097],"length":1,"stats":{"Line":0}},{"line":258,"address":[962310,961720],"length":1,"stats":{"Line":0}},{"line":275,"address":[963905,963944,962416],"length":1,"stats":{"Line":0}},{"line":276,"address":[962467],"length":1,"stats":{"Line":0}},{"line":279,"address":[962506],"length":1,"stats":{"Line":0}},{"line":280,"address":[962626,962550],"length":1,"stats":{"Line":0}},{"line":281,"address":[1275675],"length":1,"stats":{"Line":0}},{"line":283,"address":[962744],"length":1,"stats":{"Line":0}},{"line":284,"address":[962811,962868],"length":1,"stats":{"Line":0}},{"line":286,"address":[1275871,1275790],"length":1,"stats":{"Line":0}},{"line":289,"address":[1275888],"length":1,"stats":{"Line":0}},{"line":290,"address":[962956,962877],"length":1,"stats":{"Line":0}},{"line":291,"address":[1276005],"length":1,"stats":{"Line":0}},{"line":293,"address":[1276117],"length":1,"stats":{"Line":0}},{"line":294,"address":[1276238,1276174],"length":1,"stats":{"Line":0}},{"line":296,"address":[963154,963091],"length":1,"stats":{"Line":0}},{"line":298,"address":[963083],"length":1,"stats":{"Line":0}},{"line":303,"address":[1276257,1276208],"length":1,"stats":{"Line":0}},{"line":306,"address":[993152,993166],"length":1,"stats":{"Line":0}},{"line":307,"address":[1073472,1073481],"length":1,"stats":{"Line":0}},{"line":310,"address":[963860,963336],"length":1,"stats":{"Line":0}},{"line":311,"address":[963556,963401],"length":1,"stats":{"Line":0}},{"line":312,"address":[963635,963564],"length":1,"stats":{"Line":0}},{"line":313,"address":[1276684],"length":1,"stats":{"Line":0}},{"line":315,"address":[1276796],"length":1,"stats":{"Line":0}},{"line":316,"address":[963823,963878],"length":1,"stats":{"Line":0}},{"line":318,"address":[963770,963843],"length":1,"stats":{"Line":0}},{"line":320,"address":[1276802],"length":1,"stats":{"Line":0}},{"line":324,"address":[963348,963424],"length":1,"stats":{"Line":0}},{"line":326,"address":[1276380],"length":1,"stats":{"Line":0}},{"line":328,"address":[963439],"length":1,"stats":{"Line":0}},{"line":330,"address":[1276471],"length":1,"stats":{"Line":0}},{"line":334,"address":[1276546],"length":1,"stats":{"Line":0}},{"line":342,"address":[1277008,1279229,1278253],"length":1,"stats":{"Line":0}},{"line":343,"address":[964003],"length":1,"stats":{"Line":0}},{"line":345,"address":[964202,964223],"length":1,"stats":{"Line":0}},{"line":346,"address":[1277339],"length":1,"stats":{"Line":0}},{"line":347,"address":[1277421],"length":1,"stats":{"Line":0}},{"line":348,"address":[1277572,1277457],"length":1,"stats":{"Line":0}},{"line":349,"address":[1277544],"length":1,"stats":{"Line":0}},{"line":350,"address":[1277479],"length":1,"stats":{"Line":0}},{"line":353,"address":[964473],"length":1,"stats":{"Line":0}},{"line":354,"address":[1277608,1277740],"length":1,"stats":{"Line":0}},{"line":355,"address":[1277633,1277915,1277815,1277854],"length":1,"stats":{"Line":0}},{"line":356,"address":[964789,964841],"length":1,"stats":{"Line":0}},{"line":357,"address":[964626,964909],"length":1,"stats":{"Line":0}},{"line":360,"address":[1277769],"length":1,"stats":{"Line":0}},{"line":361,"address":[1278275,1278003],"length":1,"stats":{"Line":0}},{"line":362,"address":[1278103,1277981],"length":1,"stats":{"Line":0}},{"line":363,"address":[1278109],"length":1,"stats":{"Line":0}},{"line":365,"address":[965305,965005],"length":1,"stats":{"Line":0}},{"line":368,"address":[965183,965351],"length":1,"stats":{"Line":0}},{"line":371,"address":[1278554],"length":1,"stats":{"Line":0}},{"line":372,"address":[965576],"length":1,"stats":{"Line":0}},{"line":373,"address":[965634,965722],"length":1,"stats":{"Line":0}},{"line":375,"address":[965907,965659],"length":1,"stats":{"Line":0}},{"line":376,"address":[1278955],"length":1,"stats":{"Line":0}},{"line":381,"address":[964336],"length":1,"stats":{"Line":0}},{"line":385,"address":[966208,967441,967447],"length":1,"stats":{"Line":0}},{"line":386,"address":[1279266],"length":1,"stats":{"Line":0}},{"line":387,"address":[1279358,1279302],"length":1,"stats":{"Line":0}},{"line":391,"address":[1279418,1279364],"length":1,"stats":{"Line":0}},{"line":397,"address":[1279671,1279857],"length":1,"stats":{"Line":0}},{"line":398,"address":[966877,966939],"length":1,"stats":{"Line":0}},{"line":399,"address":[1280183],"length":1,"stats":{"Line":0}},{"line":400,"address":[967205],"length":1,"stats":{"Line":0}},{"line":406,"address":[1281543,1280512,1281549],"length":1,"stats":{"Line":0}},{"line":407,"address":[967490],"length":1,"stats":{"Line":0}},{"line":408,"address":[967526,967582],"length":1,"stats":{"Line":0}},{"line":412,"address":[967745],"length":1,"stats":{"Line":0}},{"line":418,"address":[968075,967889],"length":1,"stats":{"Line":0}},{"line":419,"address":[968130,968259],"length":1,"stats":{"Line":0}},{"line":420,"address":[968267],"length":1,"stats":{"Line":0}},{"line":424,"address":[968194],"length":1,"stats":{"Line":0}},{"line":432,"address":[968544,968776,968782],"length":1,"stats":{"Line":0}},{"line":433,"address":[968645,968551,968700],"length":1,"stats":{"Line":0}},{"line":434,"address":[1281623],"length":1,"stats":{"Line":0}},{"line":436,"address":[1073504,1073513],"length":1,"stats":{"Line":0}},{"line":441,"address":[969824,968800,969818],"length":1,"stats":{"Line":0}},{"line":442,"address":[969022,969218,968817,969083],"length":1,"stats":{"Line":0}},{"line":443,"address":[968852],"length":1,"stats":{"Line":0}},{"line":454,"address":[969413],"length":1,"stats":{"Line":0}},{"line":455,"address":[969502,969442],"length":1,"stats":{"Line":0}},{"line":458,"address":[969582,969468,969674],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":157}]};
        var previousData = {"files":[{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","scripts","check-quality-gates.rs"],"content":"//! Script de v√©rification des seuils de qualit√©\n//! \n//! Ce script v√©rifie que tous les seuils d√©finis dans `.github/quality-gates.toml`\n//! sont respect√©s avant de permettre la cr√©ation d'une nightly build.\n\nuse std::fs;\nuse std::path::Path;\nuse std::process::{Command, Stdio};\n\nuse anyhow::{Context, Result};\nuse serde::Deserialize;\nuse toml;\n\n#[derive(Debug, Deserialize)]\nstruct QualityGates {\n    coverage: Option\u003cCoverage\u003e,\n    clippy: Option\u003cClippy\u003e,\n    security: Option\u003cSecurity\u003e,\n    dependencies: Option\u003cDependencies\u003e,\n    code_metrics: Option\u003cCodeMetrics\u003e,\n    documentation: Option\u003cDocumentation\u003e,\n    tests: Option\u003cTests\u003e,\n    build: Option\u003cBuild\u003e,\n    nightly: Option\u003cNightly\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Coverage {\n    minimum: Option\u003cf64\u003e,\n    target: Option\u003cf64\u003e,\n    exclude: Option\u003cVec\u003cString\u003e\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Clippy {\n    max_warnings: Option\u003cu32\u003e,\n    severity: Option\u003cString\u003e,\n    strict: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Security {\n    max_critical_vulnerabilities: Option\u003cu32\u003e,\n    max_high_vulnerabilities: Option\u003cu32\u003e,\n    max_medium_vulnerabilities: Option\u003cu32\u003e,\n    allow_unpatched: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Dependencies {\n    max_outdated: Option\u003cu32\u003e,\n    max_duplicates: Option\u003cu32\u003e,\n    check_licenses: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct CodeMetrics {\n    max_binary_size: Option\u003cu64\u003e,\n    min_tests: Option\u003cu32\u003e,\n    min_integration_tests: Option\u003cu32\u003e,\n    max_cyclomatic_complexity: Option\u003cu32\u003e,\n    max_unsafe_percentage: Option\u003cf64\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Documentation {\n    min_documentation_coverage: Option\u003cf64\u003e,\n    require_public_docs: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Tests {\n    require_all_tests_pass: Option\u003cbool\u003e,\n    max_test_duration: Option\u003cu32\u003e,\n    enable_performance_tests: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Build {\n    require_build_success: Option\u003cbool\u003e,\n    max_build_duration: Option\u003cu32\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Nightly {\n    strict_mode: Option\u003cbool\u003e,\n    block_on_coverage_decrease: Option\u003cbool\u003e,\n    block_on_new_vulnerabilities: Option\u003cbool\u003e,\n    block_on_new_warnings: Option\u003cbool\u003e,\n}\n\nstruct CheckResult {\n    name: String,\n    passed: bool,\n    message: String,\n}\n\nfn main() -\u003e Result\u003c()\u003e {\n    println!(\"üîç V√©rification des seuils de qualit√©...\\n\");\n\n    let gates = load_quality_gates()?;\n    let mut results = Vec::new();\n    let mut failed_checks = 0;\n\n    // V√©rifier la couverture\n    if let Some(coverage) = \u0026gates.coverage {\n        if let Some(minimum) = coverage.minimum {\n            match check_coverage(minimum) {\n                Ok(result) =\u003e {\n                    if !result.passed {\n                        failed_checks += 1;\n                    }\n                    results.push(result);\n                }\n                Err(e) =\u003e {\n                    println!(\"‚ö†Ô∏è  V√©rification de couverture ignor√©e: {}\", e);\n                }\n            }\n        }\n    }\n\n    // V√©rifier Clippy\n    if let Some(clippy) = \u0026gates.clippy {\n        if let Some(max_warnings) = clippy.max_warnings {\n            match check_clippy(max_warnings) {\n                Ok(result) =\u003e {\n                    if !result.passed {\n                        failed_checks += 1;\n                    }\n                    results.push(result);\n                }\n                Err(e) =\u003e {\n                    println!(\"‚ö†Ô∏è  V√©rification Clippy ignor√©e: {}\", e);\n                }\n            }\n        }\n    }\n\n    // V√©rifier la s√©curit√©\n    if let Some(security) = \u0026gates.security {\n        match check_security(security) {\n            Ok(result) =\u003e {\n                if !result.passed {\n                    failed_checks += 1;\n                }\n                results.push(result);\n            }\n            Err(e) =\u003e {\n                println!(\"‚ö†Ô∏è  V√©rification de s√©curit√© ignor√©e: {}\", e);\n            }\n        }\n    }\n\n    // V√©rifier les d√©pendances\n    if let Some(deps) = \u0026gates.dependencies {\n        match check_dependencies(deps) {\n            Ok(result) =\u003e {\n                if !result.passed {\n                    failed_checks += 1;\n                }\n                results.push(result);\n            }\n            Err(e) =\u003e {\n                println!(\"‚ö†Ô∏è  V√©rification des d√©pendances ignor√©e: {}\", e);\n            }\n        }\n    }\n\n    // V√©rifier les m√©triques de code\n    if let Some(metrics) = \u0026gates.code_metrics {\n        match check_code_metrics(metrics) {\n            Ok(result) =\u003e {\n                for r in result {\n                    if !r.passed {\n                        failed_checks += 1;\n                    }\n                    results.push(r);\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"‚ö†Ô∏è  V√©rification des m√©triques ignor√©e: {}\", e);\n            }\n        }\n    }\n\n    // Afficher les r√©sultats\n    println!();\n    for result in \u0026results {\n        if result.passed {\n            println!(\"‚úÖ {}: {}\", result.name, result.message);\n        } else {\n            println!(\"‚ùå {}: {}\", result.name, result.message);\n        }\n    }\n\n    println!();\n    if failed_checks == 0 {\n        println!(\"‚úÖ Tous les seuils de qualit√© sont respect√©s !\");\n        Ok(())\n    } else {\n        println!(\"‚ùå {} seuil(s) de qualit√© non respect√©(s)\", failed_checks);\n        println!(\"La nightly build ne peut pas √™tre cr√©√©e.\");\n        std::process::exit(1);\n    }\n}\n\nfn load_quality_gates() -\u003e Result\u003cQualityGates\u003e {\n    let content = fs::read_to_string(\".github/quality-gates.toml\")\n        .context(\"Impossible de lire le fichier de configuration des seuils\")?;\n    let gates: QualityGates = toml::from_str(\u0026content)\n        .context(\"Erreur lors du parsing du fichier de configuration\")?;\n    Ok(gates)\n}\n\nfn check_coverage(minimum: f64) -\u003e Result\u003cCheckResult\u003e {\n    // Essayer de lire depuis un fichier XML de couverture\n    let coverage_file = \"coverage/cobertura.xml\";\n    if Path::new(coverage_file).exists() {\n        // Pour une impl√©mentation compl√®te, il faudrait parser le XML\n        // Ici, on utilise une approche simplifi√©e\n        let coverage = extract_coverage_from_xml(coverage_file)?;\n        let passed = coverage \u003e= minimum;\n        Ok(CheckResult {\n            name: \"Couverture de code\".to_string(),\n            passed,\n            message: format!(\"{:.2}% (minimum: {:.2}%)\", coverage, minimum),\n        })\n    } else {\n        // Essayer avec cargo-tarpaulin directement\n        let output = Command::new(\"cargo\")\n            .args(\u0026[\"tarpaulin\", \"--out\", \"Xml\", \"--output-dir\", \"/tmp\"])\n            .stderr(Stdio::null())\n            .output()?;\n\n        if output.status.success() {\n            // Parser la sortie pour extraire le pourcentage\n            let stdout = String::from_utf8_lossy(\u0026output.stdout);\n            let coverage = extract_coverage_from_output(\u0026stdout)?;\n            let passed = coverage \u003e= minimum;\n            Ok(CheckResult {\n                name: \"Couverture de code\".to_string(),\n                passed,\n                message: format!(\"{:.2}% (minimum: {:.2}%)\", coverage, minimum),\n            })\n        } else {\n            Err(anyhow::anyhow!(\"cargo-tarpaulin non disponible\"))\n        }\n    }\n}\n\nfn extract_coverage_from_xml(_file: \u0026str) -\u003e Result\u003cf64\u003e {\n    // Impl√©mentation simplifi√©e - dans un vrai projet, utiliser un parser XML\n    // Pour l'instant, on retourne une valeur par d√©faut\n    Ok(0.0)\n}\n\nfn extract_coverage_from_output(output: \u0026str) -\u003e Result\u003cf64\u003e {\n    // Extraire le pourcentage depuis la sortie de cargo-tarpaulin\n    for line in output.lines() {\n        if line.contains(\"%\") {\n            if let Some(percent_str) = line.split('%').next() {\n                if let Ok(coverage) = percent_str.trim().parse::\u003cf64\u003e() {\n                    return Ok(coverage);\n                }\n            }\n        }\n    }\n    Err(anyhow::anyhow!(\"Impossible d'extraire la couverture\"))\n}\n\nfn check_clippy(max_warnings: u32) -\u003e Result\u003cCheckResult\u003e {\n    let output = Command::new(\"cargo\")\n        .args(\u0026[\"clippy\", \"--all-targets\", \"--all-features\", \"--message-format=json\"])\n        .output()?;\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    let warnings = stdout\n        .lines()\n        .filter(|line| line.contains(r#\"\"level\":\"warning\"\"#))\n        .count() as u32;\n\n    let passed = warnings \u003c= max_warnings;\n    Ok(CheckResult {\n        name: \"Clippy warnings\".to_string(),\n        passed,\n        message: format!(\"{} warnings (maximum: {})\", warnings, max_warnings),\n    })\n}\n\nfn check_security(security: \u0026Security) -\u003e Result\u003cCheckResult\u003e {\n    let output = Command::new(\"cargo\")\n        .args(\u0026[\"audit\", \"--json\"])\n        .output();\n\n    match output {\n        Ok(output) =\u003e {\n            let stdout = String::from_utf8_lossy(\u0026output.stdout);\n            let critical = stdout.matches(r#\"\"severity\":\"critical\"\"#).count() as u32;\n            let high = stdout.matches(r#\"\"severity\":\"high\"\"#).count() as u32;\n\n            let max_critical = security.max_critical_vulnerabilities.unwrap_or(0);\n            let max_high = security.max_high_vulnerabilities.unwrap_or(0);\n\n            let passed = critical \u003c= max_critical \u0026\u0026 high \u003c= max_high;\n            Ok(CheckResult {\n                name: \"Vuln√©rabilit√©s de s√©curit√©\".to_string(),\n                passed,\n                message: format!(\n                    \"Critiques: {} (max: {}), Importantes: {} (max: {})\",\n                    critical, max_critical, high, max_high\n                ),\n            })\n        }\n        Err(_) =\u003e Err(anyhow::anyhow!(\"cargo-audit non disponible\")),\n    }\n}\n\nfn check_dependencies(deps: \u0026Dependencies) -\u003e Result\u003cCheckResult\u003e {\n    if let Some(max_outdated) = deps.max_outdated {\n        let output = Command::new(\"cargo\")\n            .args(\u0026[\"outdated\", \"--format\", \"json\"])\n            .output();\n\n        match output {\n            Ok(output) =\u003e {\n                let stdout = String::from_utf8_lossy(\u0026output.stdout);\n                let outdated = stdout.matches(r#\"\"name\"\"#).count() as u32;\n\n                let passed = outdated \u003c= max_outdated;\n                Ok(CheckResult {\n                    name: \"D√©pendances obsol√®tes\".to_string(),\n                    passed,\n                    message: format!(\"{} d√©pendances (maximum: {})\", outdated, max_outdated),\n                })\n            }\n            Err(_) =\u003e Err(anyhow::anyhow!(\"cargo-outdated non disponible\")),\n        }\n    } else {\n        Ok(CheckResult {\n            name: \"D√©pendances obsol√®tes\".to_string(),\n            passed: true,\n            message: \"V√©rification d√©sactiv√©e\".to_string(),\n        })\n    }\n}\n\nfn check_code_metrics(metrics: \u0026CodeMetrics) -\u003e Result\u003cVec\u003cCheckResult\u003e\u003e {\n    let mut results = Vec::new();\n\n    // V√©rifier le nombre de tests\n    if let Some(min_tests) = metrics.min_tests {\n        let output = Command::new(\"cargo\")\n            .args(\u0026[\"test\", \"--all-features\", \"--lib\", \"--tests\", \"--no-run\", \"--message-format=json\"])\n            .output()?;\n\n        let stdout = String::from_utf8_lossy(\u0026output.stdout);\n        let test_count = stdout.matches(r#\"\"type\":\"test\"\"#).count() as u32;\n\n        results.push(CheckResult {\n            name: \"Nombre de tests\".to_string(),\n            passed: test_count \u003e= min_tests,\n            message: format!(\"{} tests (minimum: {})\", test_count, min_tests),\n        });\n    }\n\n    // V√©rifier la taille du binaire\n    if let Some(max_size) = metrics.max_binary_size {\n        let binary_path = \"target/release/repolens\";\n        if Path::new(binary_path).exists() {\n            let metadata = fs::metadata(binary_path)?;\n            let size = metadata.len();\n            results.push(CheckResult {\n                name: \"Taille du binaire\".to_string(),\n                passed: size \u003c= max_size,\n                message: format!(\"{} bytes (maximum: {} bytes)\", size, max_size),\n            });\n        }\n    }\n\n    Ok(results)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","branch_protection.rs"],"content":"//! Branch protection configuration via GitHub API\n\nuse crate::error::{ActionError, ProviderError, RepoLensError};\nuse std::process::Command;\n\nuse super::plan::BranchProtectionSettings;\nuse crate::utils::prerequisites::{get_repo_info, is_gh_available};\n\n/// Configure branch protection for a branch\npub async fn configure(\n    branch: \u0026str,\n    settings: \u0026BranchProtectionSettings,\n) -\u003e Result\u003c(), RepoLensError\u003e {\n    // Check if gh CLI is available\n    if !is_gh_available() {\n        return Err(RepoLensError::Provider(\n            ProviderError::GitHubCliNotAvailable,\n        ));\n    }\n\n    // Get repository info\n    let repo = get_repo_info().map_err(|e| {\n        RepoLensError::Action(ActionError::ExecutionFailed {\n            message: format!(\"Failed to get repository info: {}\", e),\n        })\n    })?;\n\n    // Build the API request\n    let required_pr_reviews = if settings.required_approvals \u003e 0 {\n        format!(\n            r#\"{{\"required_approving_review_count\":{},\"dismiss_stale_reviews\":true}}\"#,\n            settings.required_approvals\n        )\n    } else {\n        \"null\".to_string()\n    };\n\n    let required_status_checks = if settings.require_status_checks {\n        r#\"{\"strict\":true,\"contexts\":[]}\"#.to_string()\n    } else {\n        \"null\".to_string()\n    };\n\n    // Execute the API call\n    let output = Command::new(\"gh\")\n        .args([\n            \"api\",\n            \u0026format!(\"repos/{}/branches/{}/protection\", repo, branch),\n            \"--method\",\n            \"PUT\",\n            \"--field\",\n            \u0026format!(\"required_status_checks={}\", required_status_checks),\n            \"--field\",\n            \u0026format!(\"enforce_admins={}\", settings.enforce_admins),\n            \"--field\",\n            \u0026format!(\"required_pull_request_reviews={}\", required_pr_reviews),\n            \"--field\",\n            \"restrictions=null\",\n            \"--field\",\n            \u0026format!(\n                \"required_linear_history={}\",\n                settings.require_linear_history\n            ),\n            \"--field\",\n            \u0026format!(\"allow_force_pushes={}\", !settings.block_force_push),\n            \"--field\",\n            \u0026format!(\"allow_deletions={}\", !settings.block_deletions),\n            \"--field\",\n            \u0026format!(\n                \"required_conversation_resolution={}\",\n                settings.require_conversation_resolution\n            ),\n        ])\n        .output()\n        .map_err(|_| {\n            RepoLensError::Provider(ProviderError::CommandFailed {\n                command: format!(\"gh api repos/{}/branches/{}/protection\", repo, branch),\n            })\n        })?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n\n        // Check for common errors\n        if stderr.contains(\"Resource not accessible\") {\n            return Err(RepoLensError::Action(ActionError::ExecutionFailed {\n                message: \"Cannot configure branch protection. This may require admin access or \\\n                the repository may not support this feature (e.g., free private repos).\"\n                    .to_string(),\n            }));\n        }\n\n        return Err(RepoLensError::Action(ActionError::ExecutionFailed {\n            message: format!(\"Failed to configure branch protection: {}\", stderr),\n        }));\n    }\n\n    // Configure signed commits if required (separate API call)\n    if settings.require_signed_commits {\n        let output = Command::new(\"gh\")\n            .args([\n                \"api\",\n                \u0026format!(\n                    \"repos/{}/branches/{}/protection/required_signatures\",\n                    repo, branch\n                ),\n                \"--method\",\n                \"POST\",\n            ])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: format!(\n                        \"gh api repos/{}/branches/{}/protection/required_signatures\",\n                        repo, branch\n                    ),\n                })\n            })?;\n\n        if !output.status.success() {\n            // Non-fatal: signed commits may not be available\n            tracing::warn!(\"Could not enable signed commits requirement (may require GitHub Pro)\");\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":10,"address":[103936],"length":1,"stats":{"Line":0}},{"line":15,"address":[1071421,1071331],"length":1,"stats":{"Line":0}},{"line":16,"address":[1071439],"length":1,"stats":{"Line":0}},{"line":17,"address":[1071427],"length":1,"stats":{"Line":0}},{"line":22,"address":[1078208,1071638,1078164,1071744,1078457,1078463,1071551],"length":1,"stats":{"Line":0}},{"line":23,"address":[1078379],"length":1,"stats":{"Line":0}},{"line":24,"address":[730178,730226],"length":1,"stats":{"Line":0}},{"line":29,"address":[1071881],"length":1,"stats":{"Line":0}},{"line":30,"address":[1072010,1071925],"length":1,"stats":{"Line":0}},{"line":35,"address":[1071988,1071886],"length":1,"stats":{"Line":0}},{"line":38,"address":[1071998],"length":1,"stats":{"Line":0}},{"line":39,"address":[1072247,1072143],"length":1,"stats":{"Line":0}},{"line":41,"address":[1072218,1072112],"length":1,"stats":{"Line":0}},{"line":45,"address":[1072220,1075014,1074825],"length":1,"stats":{"Line":0}},{"line":46,"address":[1074382],"length":1,"stats":{"Line":0}},{"line":48,"address":[724294,724226],"length":1,"stats":{"Line":0}},{"line":52,"address":[1072608],"length":1,"stats":{"Line":0}},{"line":54,"address":[1072850],"length":1,"stats":{"Line":0}},{"line":56,"address":[1073080],"length":1,"stats":{"Line":0}},{"line":60,"address":[1073322],"length":1,"stats":{"Line":0}},{"line":65,"address":[1073560],"length":1,"stats":{"Line":0}},{"line":67,"address":[1073816],"length":1,"stats":{"Line":0}},{"line":69,"address":[1074072],"length":1,"stats":{"Line":0}},{"line":75,"address":[730755,730416,730761],"length":1,"stats":{"Line":0}},{"line":76,"address":[1078713],"length":1,"stats":{"Line":0}},{"line":77,"address":[1078512,1078577],"length":1,"stats":{"Line":0}},{"line":81,"address":[1075714],"length":1,"stats":{"Line":0}},{"line":82,"address":[1075811,1075749],"length":1,"stats":{"Line":0}},{"line":85,"address":[727849,727766],"length":1,"stats":{"Line":0}},{"line":86,"address":[1076242],"length":1,"stats":{"Line":0}},{"line":87,"address":[727913],"length":1,"stats":{"Line":0}},{"line":93,"address":[1076111],"length":1,"stats":{"Line":0}},{"line":94,"address":[1075950,1076011],"length":1,"stats":{"Line":0}},{"line":99,"address":[1075786],"length":1,"stats":{"Line":0}},{"line":100,"address":[728965,728782,728349],"length":1,"stats":{"Line":0}},{"line":101,"address":[1076733],"length":1,"stats":{"Line":0}},{"line":103,"address":[728447,728376],"length":1,"stats":{"Line":0}},{"line":111,"address":[1078848,1079187,1079193],"length":1,"stats":{"Line":0}},{"line":112,"address":[1079081],"length":1,"stats":{"Line":0}},{"line":113,"address":[1078880,1078945],"length":1,"stats":{"Line":0}},{"line":120,"address":[1077309],"length":1,"stats":{"Line":0}},{"line":122,"address":[1077338,1077385],"length":1,"stats":{"Line":0}},{"line":126,"address":[1076383],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":43},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","executor.rs"],"content":"//! Action executor - Executes planned actions\n//!\n//! This module provides functionality to execute actions from an action plan.\n//! It handles the actual execution of file creation, .gitignore updates,\n//! branch protection configuration, and GitHub settings updates.\n\nuse crate::error::RepoLensError;\nuse tracing::{debug, info};\n\nuse crate::config::Config;\n\nuse super::plan::{Action, ActionOperation, ActionPlan};\nuse super::{branch_protection, github_settings, gitignore, templates};\n\n/// Result of executing a single action\n///\n/// Contains information about whether an action succeeded or failed,\n/// along with any error message if it failed.\n#[derive(Debug)]\npub struct ActionResult {\n    /// Name/description of the action that was executed\n    pub action_name: String,\n    /// Whether the action succeeded\n    pub success: bool,\n    /// Error message if the action failed, `None` if it succeeded\n    pub error: Option\u003cString\u003e,\n}\n\n/// Executes actions from an action plan\n///\n/// The `ActionExecutor` takes an `ActionPlan` and executes each action\n/// sequentially. It handles different types of operations like file creation,\n/// .gitignore updates, and GitHub API calls.\npub struct ActionExecutor {\n    /// Configuration (currently unused but kept for future extensibility)\n    _config: Config,\n}\n\nimpl ActionExecutor {\n    /// Create a new action executor with the given configuration\n    ///\n    /// # Arguments\n    ///\n    /// * `config` - The configuration to use for execution\n    ///\n    /// # Returns\n    ///\n    /// A new `ActionExecutor` instance\n    pub fn new(config: Config) -\u003e Self {\n        Self { _config: config }\n    }\n\n    /// Execute all actions in the plan\n    ///\n    /// Executes each action sequentially and collects results. If an action\n    /// fails, execution continues with the next action.\n    ///\n    /// # Arguments\n    ///\n    /// * `plan` - The action plan to execute\n    ///\n    /// # Returns\n    ///\n    /// A vector of `ActionResult` for each action, indicating success or failure\n    ///\n    /// # Errors\n    ///\n    /// Returns an error only if there's a critical failure in the executor itself\n    pub async fn execute(\u0026self, plan: \u0026ActionPlan) -\u003e Result\u003cVec\u003cActionResult\u003e, RepoLensError\u003e {\n        let mut results = Vec::new();\n\n        for action in plan.actions() {\n            info!(\"Executing action: {}\", action.id());\n\n            let result = self.execute_action(action).await;\n\n            results.push(ActionResult {\n                action_name: action.description().to_string(),\n                success: result.is_ok(),\n                error: result.err().map(|e| e.to_string()),\n            });\n        }\n\n        Ok(results)\n    }\n\n    /// Execute a single action\n    ///\n    /// # Arguments\n    ///\n    /// * `action` - The action to execute\n    ///\n    /// # Returns\n    ///\n    /// `Ok(())` if the action succeeded, or an error if it failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the action execution fails\n    async fn execute_action(\u0026self, action: \u0026Action) -\u003e Result\u003c(), RepoLensError\u003e {\n        match action.operation() {\n            ActionOperation::UpdateGitignore { entries } =\u003e {\n                debug!(\"Updating .gitignore with {} entries\", entries.len());\n                // Get current directory at the start to avoid race conditions in parallel tests\n                let current_dir = std::env::current_dir().map_err(|e| {\n                    RepoLensError::Action(crate::error::ActionError::ExecutionFailed {\n                        message: format!(\"Failed to get current directory: {}\", e),\n                    })\n                })?;\n                gitignore::update_gitignore_at(\u0026current_dir, entries)?;\n            }\n\n            ActionOperation::CreateFile {\n                path,\n                template,\n                variables,\n            } =\u003e {\n                debug!(\"Creating file {} from template {}\", path, template);\n                templates::create_file_from_template(path, template, variables)?;\n            }\n\n            ActionOperation::ConfigureBranchProtection { branch, settings } =\u003e {\n                debug!(\"Configuring branch protection for {}\", branch);\n                branch_protection::configure(branch, settings).await?;\n            }\n\n            ActionOperation::UpdateGitHubSettings { settings } =\u003e {\n                debug!(\"Updating GitHub repository settings\");\n                github_settings::update(settings).await?;\n            }\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::actions::plan::{ActionOperation, ActionPlan};\n    use std::collections::HashMap;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_execute_action_update_gitignore() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let root_abs = root.canonicalize().unwrap_or_else(|_| root.to_path_buf());\n\n        // Save current directory (fallback to /tmp if current dir is invalid)\n        let original_dir =\n            std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from(\"/tmp\"));\n\n        // Ensure we're in a valid directory before changing\n        if std::env::current_dir().is_err() {\n            let _ = std::env::set_current_dir(\"/tmp\");\n        }\n\n        // Change to temp directory\n        std::env::set_current_dir(\u0026root_abs).expect(\"Failed to change to temp directory\");\n\n        let config = Config::default();\n        let executor = ActionExecutor::new(config);\n\n        let action = Action::new(\n            \"test-gitignore\",\n            \"gitignore\",\n            \"Test gitignore update\",\n            ActionOperation::UpdateGitignore {\n                entries: vec![\".env\".to_string(), \"*.key\".to_string()],\n            },\n        );\n\n        // Execute action - it will get current_dir at start, but we ensure it's correct\n        // by setting it just before execution. However, parallel tests might still interfere,\n        // so we also verify the file was created using absolute path.\n        std::env::set_current_dir(\u0026root_abs)\n            .expect(\"Failed to restore temp directory before execution\");\n\n        let result = executor.execute_action(\u0026action).await;\n\n        // Restore directory immediately after execution\n        let _ = std::env::set_current_dir(\u0026original_dir);\n\n        // Check result after restoring directory\n        assert!(\n            result.is_ok(),\n            \"Action execution failed: {:?}\",\n            result.err()\n        );\n\n        // Verify file was created in the temp directory using absolute path\n        // This works regardless of what the current directory is\n        let gitignore_path = root_abs.join(\".gitignore\");\n        assert!(\n            gitignore_path.exists(),\n            \".gitignore not found at {:?}. Root was: {:?}\",\n            gitignore_path,\n            root_abs\n        );\n    }\n\n    #[tokio::test]\n    async fn test_execute_action_create_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Save current directory (fallback to /tmp if current dir is invalid)\n        let original_dir =\n            std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from(\"/tmp\"));\n\n        // Ensure we're in a valid directory before changing\n        if std::env::current_dir().is_err() {\n            let _ = std::env::set_current_dir(\"/tmp\");\n        }\n\n        std::env::set_current_dir(root).expect(\"Failed to change to temp directory\");\n\n        let config = Config::default();\n        let executor = ActionExecutor::new(config);\n\n        let action = Action::new(\n            \"test-create\",\n            \"file\",\n            \"Test file creation\",\n            ActionOperation::CreateFile {\n                path: \"TEST.md\".to_string(),\n                template: \"CONTRIBUTING.md\".to_string(),\n                variables: HashMap::new(),\n            },\n        );\n\n        let result = executor.execute_action(\u0026action).await;\n\n        // May fail if template doesn't exist, but that's ok for test\n        // We're testing that the function handles it gracefully\n        let _ = result;\n\n        // Restore directory (ignore errors if directory no longer exists)\n        let _ = std::env::set_current_dir(\u0026original_dir);\n    }\n\n    #[tokio::test]\n    async fn test_execute_all_actions() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Save current directory (fallback to /tmp if current dir is invalid)\n        let original_dir =\n            std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from(\"/tmp\"));\n\n        // Ensure we're in a valid directory before changing\n        if std::env::current_dir().is_err() {\n            let _ = std::env::set_current_dir(\"/tmp\");\n        }\n\n        std::env::set_current_dir(root).expect(\"Failed to change to temp directory\");\n\n        let config = Config::default();\n        let executor = ActionExecutor::new(config);\n\n        let mut plan = ActionPlan::new();\n        plan.add(Action::new(\n            \"test-1\",\n            \"gitignore\",\n            \"Test 1\",\n            ActionOperation::UpdateGitignore {\n                entries: vec![\".env\".to_string()],\n            },\n        ));\n\n        let results = executor.execute(\u0026plan).await.unwrap();\n\n        assert_eq!(results.len(), 1);\n        assert!(results[0].success);\n\n        // Restore directory (ignore errors if directory no longer exists)\n        let _ = std::env::set_current_dir(\u0026original_dir);\n    }\n\n    #[tokio::test]\n    async fn test_execute_handles_errors_gracefully() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Save current directory (fallback to /tmp if current dir is invalid)\n        let original_dir =\n            std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from(\"/tmp\"));\n\n        // Ensure we're in a valid directory before changing\n        if std::env::current_dir().is_err() {\n            let _ = std::env::set_current_dir(\"/tmp\");\n        }\n\n        std::env::set_current_dir(root).expect(\"Failed to change to temp directory\");\n\n        let config = Config::default();\n        let executor = ActionExecutor::new(config);\n\n        let mut plan = ActionPlan::new();\n        // Add an action that will fail (invalid template)\n        plan.add(Action::new(\n            \"test-fail\",\n            \"file\",\n            \"Test failure\",\n            ActionOperation::CreateFile {\n                path: \"INVALID.md\".to_string(),\n                template: \"NONEXISTENT_TEMPLATE.md\".to_string(),\n                variables: HashMap::new(),\n            },\n        ));\n\n        let results = executor.execute(\u0026plan).await.unwrap();\n\n        assert_eq!(results.len(), 1);\n        assert!(!results[0].success);\n        assert!(results[0].error.is_some());\n\n        // Restore directory (ignore errors if directory no longer exists)\n        let _ = std::env::set_current_dir(\u0026original_dir);\n    }\n}\n","traces":[{"line":49,"address":[436768],"length":1,"stats":{"Line":8}},{"line":69,"address":[894735,895121,894870,896757,894688,894913],"length":1,"stats":{"Line":16}},{"line":70,"address":[894851],"length":1,"stats":{"Line":4}},{"line":72,"address":[895051,895857,894971],"length":1,"stats":{"Line":10}},{"line":73,"address":[896119,895926,896376],"length":1,"stats":{"Line":6}},{"line":75,"address":[252327],"length":1,"stats":{"Line":9}},{"line":77,"address":[895754,895475],"length":1,"stats":{"Line":4}},{"line":78,"address":[895564,895495],"length":1,"stats":{"Line":4}},{"line":79,"address":[895591],"length":1,"stats":{"Line":2}},{"line":80,"address":[896784,896800,895643],"length":1,"stats":{"Line":6}},{"line":84,"address":[895962],"length":1,"stats":{"Line":2}},{"line":100,"address":[897043,897107,898766,900900,896880,896927],"length":1,"stats":{"Line":16}},{"line":101,"address":[897162,897028],"length":1,"stats":{"Line":8}},{"line":102,"address":[897234],"length":1,"stats":{"Line":2}},{"line":103,"address":[897511,897798,897254],"length":1,"stats":{"Line":4}},{"line":105,"address":[897776,898772,898139,901632,901891,898245,901885],"length":1,"stats":{"Line":4}},{"line":106,"address":[443695],"length":1,"stats":{"Line":0}},{"line":107,"address":[901653,901718],"length":1,"stats":{"Line":0}},{"line":110,"address":[440238,440345],"length":1,"stats":{"Line":5}},{"line":113,"address":[897293],"length":1,"stats":{"Line":2}},{"line":118,"address":[898781,897336,899080],"length":1,"stats":{"Line":4}},{"line":119,"address":[899657,899437,899046],"length":1,"stats":{"Line":6}},{"line":122,"address":[439263],"length":1,"stats":{"Line":0}},{"line":123,"address":[897414,899669,899930],"length":1,"stats":{"Line":0}},{"line":124,"address":[252785],"length":1,"stats":{"Line":0}},{"line":127,"address":[897453],"length":1,"stats":{"Line":0}},{"line":128,"address":[900350,900599,897473],"length":1,"stats":{"Line":0}},{"line":129,"address":[252801],"length":1,"stats":{"Line":0}},{"line":133,"address":[898679],"length":1,"stats":{"Line":3}}],"covered":21,"coverable":29},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","github_settings.rs"],"content":"//! GitHub repository settings management\n\nuse crate::error::{ActionError, ProviderError, RepoLensError};\nuse std::process::Command;\n\nuse super::plan::GitHubRepoSettings;\nuse crate::utils::prerequisites::{get_repo_info, is_gh_available};\n\n/// Update GitHub repository settings\npub async fn update(settings: \u0026GitHubRepoSettings) -\u003e Result\u003c(), RepoLensError\u003e {\n    // Check if gh CLI is available\n    if !is_gh_available() {\n        return Err(RepoLensError::Provider(\n            ProviderError::GitHubCliNotAvailable,\n        ));\n    }\n\n    // Get repository info\n    let repo = get_repo_info().map_err(|e| {\n        RepoLensError::Action(ActionError::ExecutionFailed {\n            message: format!(\"Failed to get repository info: {}\", e),\n        })\n    })?;\n\n    // Update repository settings\n    let mut args = vec![\"repo\", \"edit\"];\n\n    if let Some(true) = settings.enable_discussions {\n        args.push(\"--enable-discussions\");\n    }\n\n    if let Some(false) = settings.enable_wiki {\n        args.push(\"--enable-wiki=false\");\n    }\n\n    // Execute repository edit\n    if args.len() \u003e 2 {\n        let output = Command::new(\"gh\").args(\u0026args).output().map_err(|_| {\n            RepoLensError::Provider(ProviderError::CommandFailed {\n                command: format!(\"gh {}\", args.join(\" \")),\n            })\n        })?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(\u0026output.stderr);\n            tracing::warn!(\"Could not update some repository settings: {}\", stderr);\n        }\n    }\n\n    // Enable vulnerability alerts\n    if let Some(true) = settings.enable_vulnerability_alerts {\n        let output = Command::new(\"gh\")\n            .args([\n                \"api\",\n                \u0026format!(\"repos/{}/vulnerability-alerts\", repo),\n                \"--method\",\n                \"PUT\",\n            ])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: format!(\"gh api repos/{}/vulnerability-alerts\", repo),\n                })\n            })?;\n\n        if !output.status.success() {\n            tracing::warn!(\n                \"Could not enable vulnerability alerts (may require specific permissions)\"\n            );\n        }\n    }\n\n    // Enable automated security fixes\n    if let Some(true) = settings.enable_automated_security_fixes {\n        let output = Command::new(\"gh\")\n            .args([\n                \"api\",\n                \u0026format!(\"repos/{}/automated-security-fixes\", repo),\n                \"--method\",\n                \"PUT\",\n            ])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: format!(\"gh api repos/{}/automated-security-fixes\", repo),\n                })\n            })?;\n\n        if !output.status.success() {\n            tracing::warn!(\n                \"Could not enable automated security fixes (may require specific permissions)\"\n            );\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":10,"address":[301816,301808],"length":1,"stats":{"Line":0}},{"line":12,"address":[1362551,1362461],"length":1,"stats":{"Line":0}},{"line":13,"address":[1362569],"length":1,"stats":{"Line":0}},{"line":14,"address":[537533],"length":1,"stats":{"Line":0}},{"line":19,"address":[1362681,1367762,1367808,1368057,1368063,1362758,1362864],"length":1,"stats":{"Line":0}},{"line":20,"address":[1367979],"length":1,"stats":{"Line":0}},{"line":21,"address":[1367842,1367890],"length":1,"stats":{"Line":0}},{"line":26,"address":[1363038,1362971],"length":1,"stats":{"Line":0}},{"line":28,"address":[1363189],"length":1,"stats":{"Line":0}},{"line":29,"address":[1363257,1363339],"length":1,"stats":{"Line":0}},{"line":32,"address":[1363349,1363232],"length":1,"stats":{"Line":0}},{"line":33,"address":[1363382],"length":1,"stats":{"Line":0}},{"line":37,"address":[1363355,1363430],"length":1,"stats":{"Line":0}},{"line":38,"address":[1363476,1363586,1368590,1368584,1363744,1368080],"length":1,"stats":{"Line":0}},{"line":39,"address":[1368478],"length":1,"stats":{"Line":0}},{"line":40,"address":[1368184,1368107],"length":1,"stats":{"Line":0}},{"line":44,"address":[1363964],"length":1,"stats":{"Line":0}},{"line":45,"address":[1363999,1364068],"length":1,"stats":{"Line":0}},{"line":46,"address":[1364453,1364087,1364166],"length":1,"stats":{"Line":0}},{"line":51,"address":[1363444,1364749],"length":1,"stats":{"Line":0}},{"line":52,"address":[1364795,1365378,1365197],"length":1,"stats":{"Line":0}},{"line":53,"address":[540060],"length":1,"stats":{"Line":0}},{"line":55,"address":[1364822,1364893],"length":1,"stats":{"Line":0}},{"line":60,"address":[1368608,1368894,1368900],"length":1,"stats":{"Line":0}},{"line":61,"address":[1368788],"length":1,"stats":{"Line":0}},{"line":62,"address":[1368634,1368699],"length":1,"stats":{"Line":0}},{"line":66,"address":[1365658],"length":1,"stats":{"Line":0}},{"line":67,"address":[540669,540722],"length":1,"stats":{"Line":0}},{"line":74,"address":[1364763,1366255],"length":1,"stats":{"Line":0}},{"line":75,"address":[1366685,1366295,1366860],"length":1,"stats":{"Line":0}},{"line":76,"address":[1366572],"length":1,"stats":{"Line":0}},{"line":78,"address":[1366393,1366322],"length":1,"stats":{"Line":0}},{"line":83,"address":[1368928,1369214,1369220],"length":1,"stats":{"Line":0}},{"line":84,"address":[1369108],"length":1,"stats":{"Line":0}},{"line":85,"address":[1369019,1368954],"length":1,"stats":{"Line":0}},{"line":89,"address":[1367140],"length":1,"stats":{"Line":0}},{"line":90,"address":[1367216,1367169],"length":1,"stats":{"Line":0}},{"line":96,"address":[1366261],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":38},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","gitignore.rs"],"content":"//! Gitignore file management\n\nuse crate::error::{ActionError, RepoLensError};\nuse std::fs;\nuse std::path::Path;\n\n/// Update .gitignore with new entries at the given root path\npub fn update_gitignore_at(root: \u0026Path, entries: \u0026[String]) -\u003e Result\u003c(), RepoLensError\u003e {\n    let gitignore_path = root.join(\".gitignore\");\n\n    // Read existing content or create empty\n    let mut content = if gitignore_path.exists() {\n        fs::read_to_string(\u0026gitignore_path).map_err(|e| {\n            RepoLensError::Scan(crate::error::ScanError::FileRead {\n                path: gitignore_path.display().to_string(),\n                source: e,\n            })\n        })?\n    } else {\n        String::new()\n    };\n\n    // Track what we add\n    let mut added = Vec::new();\n\n    for entry in entries {\n        // Check if entry already exists (handle various formats)\n        let entry_clean = entry.trim_end_matches('/');\n        let entry_patterns = [\n            entry.as_str(),\n            \u0026format!(\"/{}\", entry),\n            \u0026format!(\"{}/\", entry),\n            entry_clean,\n            \u0026format!(\"/{}\", entry_clean),\n            \u0026format!(\"{}/\", entry_clean),\n        ];\n\n        let exists = content.lines().any(|line| {\n            let line = line.trim();\n            let line_clean = line.trim_end_matches('/');\n            entry_patterns\n                .iter()\n                .any(|p| line == *p || line_clean == entry_clean)\n        });\n\n        if !exists {\n            added.push(entry.clone());\n        }\n    }\n\n    if added.is_empty() {\n        return Ok(());\n    }\n\n    // Add a newline if the file doesn't end with one\n    if !content.is_empty() \u0026\u0026 !content.ends_with('\\n') {\n        content.push('\\n');\n    }\n\n    // Add comment separator if there's existing content\n    if !content.is_empty() {\n        content.push_str(\"\\n# Added by repolens\\n\");\n    }\n\n    // Add new entries\n    for entry in \u0026added {\n        content.push_str(entry);\n        content.push('\\n');\n    }\n\n    // Write back\n    fs::write(\u0026gitignore_path, content).map_err(|e| {\n        RepoLensError::Action(ActionError::FileWrite {\n            path: gitignore_path.display().to_string(),\n            source: e,\n        })\n    })?;\n\n    Ok(())\n}\n\n/// Update .gitignore with new entries in current directory\n#[allow(dead_code)] // Kept for public API, may be used by external code\npub fn update_gitignore(entries: \u0026[String]) -\u003e Result\u003c(), RepoLensError\u003e {\n    let current_dir = std::env::current_dir().map_err(|e| {\n        RepoLensError::Action(ActionError::ExecutionFailed {\n            message: format!(\"Failed to get current directory: {}\", e),\n        })\n    })?;\n    update_gitignore_at(\u0026current_dir, entries)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_update_gitignore_new_file() {\n        let dir = tempdir().unwrap();\n\n        update_gitignore_at(dir.path(), \u0026[\".env\".to_string(), \"*.key\".to_string()]).unwrap();\n\n        let content = fs::read_to_string(dir.path().join(\".gitignore\")).unwrap();\n        assert!(content.contains(\".env\"));\n        assert!(content.contains(\"*.key\"));\n    }\n\n    #[test]\n    fn test_update_gitignore_existing_file() {\n        let dir = tempdir().unwrap();\n\n        fs::write(dir.path().join(\".gitignore\"), \"node_modules/\\n\").unwrap();\n\n        update_gitignore_at(\n            dir.path(),\n            \u0026[\".env\".to_string(), \"node_modules\".to_string()],\n        )\n        .unwrap();\n\n        let content = fs::read_to_string(dir.path().join(\".gitignore\")).unwrap();\n        assert!(content.contains(\"node_modules\"));\n        assert!(content.contains(\".env\"));\n        // Should not duplicate\n        assert_eq!(content.matches(\"node_modules\").count(), 1);\n    }\n}\n","traces":[{"line":8,"address":[320960,324111,324144],"length":1,"stats":{"Line":4}},{"line":9,"address":[1387416],"length":1,"stats":{"Line":4}},{"line":12,"address":[1387470,1387915,1387553],"length":1,"stats":{"Line":10}},{"line":13,"address":[28646,28384,28640],"length":1,"stats":{"Line":4}},{"line":14,"address":[28554],"length":1,"stats":{"Line":0}},{"line":15,"address":[245636,245563],"length":1,"stats":{"Line":0}},{"line":16,"address":[28549],"length":1,"stats":{"Line":0}},{"line":20,"address":[1387588,1387618],"length":1,"stats":{"Line":4}},{"line":24,"address":[1387626],"length":1,"stats":{"Line":2}},{"line":26,"address":[1387977,1388061],"length":1,"stats":{"Line":8}},{"line":28,"address":[1389097,1388167],"length":1,"stats":{"Line":8}},{"line":29,"address":[1390136],"length":1,"stats":{"Line":4}},{"line":30,"address":[1389161],"length":1,"stats":{"Line":4}},{"line":31,"address":[1389224],"length":1,"stats":{"Line":4}},{"line":32,"address":[1389452],"length":1,"stats":{"Line":4}},{"line":34,"address":[1389668],"length":1,"stats":{"Line":4}},{"line":35,"address":[1389884],"length":1,"stats":{"Line":4}},{"line":38,"address":[323872],"length":1,"stats":{"Line":6}},{"line":39,"address":[28720],"length":1,"stats":{"Line":2}},{"line":40,"address":[28735],"length":1,"stats":{"Line":2}},{"line":41,"address":[28829,28771],"length":1,"stats":{"Line":4}},{"line":43,"address":[245952,246035,246016],"length":1,"stats":{"Line":6}},{"line":46,"address":[1390349],"length":1,"stats":{"Line":2}},{"line":47,"address":[324015,323969],"length":1,"stats":{"Line":4}},{"line":51,"address":[1388201],"length":1,"stats":{"Line":2}},{"line":52,"address":[1388270],"length":1,"stats":{"Line":1}},{"line":56,"address":[321864,321980,321905],"length":1,"stats":{"Line":6}},{"line":57,"address":[1388413],"length":1,"stats":{"Line":0}},{"line":61,"address":[321950,322045],"length":1,"stats":{"Line":4}},{"line":62,"address":[1388435,1388497],"length":1,"stats":{"Line":4}},{"line":66,"address":[1388462,1388515],"length":1,"stats":{"Line":4}},{"line":67,"address":[1388621,1388996],"length":1,"stats":{"Line":6}},{"line":68,"address":[322632],"length":1,"stats":{"Line":3}},{"line":72,"address":[29198,29192,28944],"length":1,"stats":{"Line":5}},{"line":73,"address":[29117],"length":1,"stats":{"Line":0}},{"line":74,"address":[28971,29044],"length":1,"stats":{"Line":0}},{"line":75,"address":[246264],"length":1,"stats":{"Line":0}},{"line":79,"address":[322502],"length":1,"stats":{"Line":3}},{"line":84,"address":[1390884,1390878,1390544],"length":1,"stats":{"Line":0}},{"line":85,"address":[29216,29469,29475],"length":1,"stats":{"Line":0}},{"line":86,"address":[29391],"length":1,"stats":{"Line":0}},{"line":87,"address":[29302,29237],"length":1,"stats":{"Line":0}},{"line":90,"address":[1390847,1390769],"length":1,"stats":{"Line":0}}],"covered":31,"coverable":43},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","mod.rs"],"content":"//! Actions module - Planned changes and execution\n\nmod branch_protection;\npub mod executor;\nmod github_settings;\nmod gitignore;\npub mod plan;\npub mod planner;\nmod templates;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","plan.rs"],"content":"//! Action plan structures\n\nuse serde::{Deserialize, Serialize};\n\n/// A single action to be performed\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Action {\n    /// Action identifier\n    id: String,\n    /// Action category\n    category: String,\n    /// Human-readable description\n    description: String,\n    /// Additional details about what will be changed\n    details: Vec\u003cString\u003e,\n    /// The actual operation to perform\n    operation: ActionOperation,\n}\n\nimpl Action {\n    /// Create a new action\n    pub fn new(\n        id: impl Into\u003cString\u003e,\n        category: impl Into\u003cString\u003e,\n        description: impl Into\u003cString\u003e,\n        operation: ActionOperation,\n    ) -\u003e Self {\n        Self {\n            id: id.into(),\n            category: category.into(),\n            description: description.into(),\n            details: Vec::new(),\n            operation,\n        }\n    }\n\n    /// Add a detail line\n    pub fn with_detail(mut self, detail: impl Into\u003cString\u003e) -\u003e Self {\n        self.details.push(detail.into());\n        self\n    }\n\n    /// Add multiple details\n    pub fn with_details(mut self, details: impl IntoIterator\u003cItem = impl Into\u003cString\u003e\u003e) -\u003e Self {\n        self.details.extend(details.into_iter().map(|d| d.into()));\n        self\n    }\n\n    /// Get the action ID\n    pub fn id(\u0026self) -\u003e \u0026str {\n        \u0026self.id\n    }\n\n    /// Get the category\n    pub fn category(\u0026self) -\u003e \u0026str {\n        \u0026self.category\n    }\n\n    /// Get the description\n    pub fn description(\u0026self) -\u003e \u0026str {\n        \u0026self.description\n    }\n\n    /// Get the details\n    pub fn details(\u0026self) -\u003e \u0026[String] {\n        \u0026self.details\n    }\n\n    /// Get the operation\n    pub fn operation(\u0026self) -\u003e \u0026ActionOperation {\n        \u0026self.operation\n    }\n}\n\n/// The type of operation to perform\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ActionOperation {\n    /// Update .gitignore file\n    UpdateGitignore { entries: Vec\u003cString\u003e },\n\n    /// Create a file from template\n    CreateFile {\n        path: String,\n        template: String,\n        variables: std::collections::HashMap\u003cString, String\u003e,\n    },\n\n    /// Configure branch protection\n    ConfigureBranchProtection {\n        branch: String,\n        settings: BranchProtectionSettings,\n    },\n\n    /// Update GitHub repository settings\n    UpdateGitHubSettings { settings: GitHubRepoSettings },\n}\n\n/// Branch protection settings\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BranchProtectionSettings {\n    pub required_approvals: u32,\n    pub require_status_checks: bool,\n    pub require_conversation_resolution: bool,\n    pub require_linear_history: bool,\n    pub block_force_push: bool,\n    pub block_deletions: bool,\n    pub enforce_admins: bool,\n    pub require_signed_commits: bool,\n}\n\nimpl Default for BranchProtectionSettings {\n    fn default() -\u003e Self {\n        Self {\n            required_approvals: 1,\n            require_status_checks: true,\n            require_conversation_resolution: true,\n            require_linear_history: true,\n            block_force_push: true,\n            block_deletions: true,\n            enforce_admins: true,\n            require_signed_commits: false,\n        }\n    }\n}\n\n/// GitHub repository settings\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct GitHubRepoSettings {\n    pub enable_discussions: Option\u003cbool\u003e,\n    pub enable_issues: Option\u003cbool\u003e,\n    pub enable_wiki: Option\u003cbool\u003e,\n    pub enable_vulnerability_alerts: Option\u003cbool\u003e,\n    pub enable_automated_security_fixes: Option\u003cbool\u003e,\n}\n\n/// A collection of actions to perform\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ActionPlan {\n    actions: Vec\u003cAction\u003e,\n}\n\nimpl ActionPlan {\n    /// Create a new empty action plan\n    pub fn new() -\u003e Self {\n        Self {\n            actions: Vec::new(),\n        }\n    }\n\n    /// Add an action to the plan\n    pub fn add(\u0026mut self, action: Action) {\n        self.actions.push(action);\n    }\n\n    /// Get all actions\n    pub fn actions(\u0026self) -\u003e \u0026[Action] {\n        \u0026self.actions\n    }\n\n    /// Check if the plan is empty\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.actions.is_empty()\n    }\n\n    /// Get the number of actions\n    #[allow(dead_code)]\n    pub fn len(\u0026self) -\u003e usize {\n        self.actions.len()\n    }\n\n    /// Filter to only include specific action categories\n    pub fn filter_only(\u0026mut self, categories: \u0026[String]) {\n        self.actions\n            .retain(|a| categories.contains(\u0026a.category.to_string()));\n    }\n\n    /// Filter to skip specific action categories\n    pub fn filter_skip(\u0026mut self, categories: \u0026[String]) {\n        self.actions\n            .retain(|a| !categories.contains(\u0026a.category.to_string()));\n    }\n}\n\nimpl Default for ActionPlan {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":22,"address":[1042609,1042579,1041984,1042624,1043213,1043257],"length":1,"stats":{"Line":8}},{"line":29,"address":[45229,44618],"length":1,"stats":{"Line":6}},{"line":30,"address":[],"length":0,"stats":{"Line":14}},{"line":31,"address":[],"length":0,"stats":{"Line":10}},{"line":32,"address":[1042977,1042340],"length":1,"stats":{"Line":14}},{"line":38,"address":[1043280,1043430,1043456,1043627],"length":1,"stats":{"Line":2}},{"line":39,"address":[1043509,1043574,1043312,1043377],"length":1,"stats":{"Line":4}},{"line":40,"address":[46135,45938],"length":1,"stats":{"Line":2}},{"line":44,"address":[1043802,1043648],"length":1,"stats":{"Line":7}},{"line":45,"address":[46352,46269,46206,46380],"length":1,"stats":{"Line":24}},{"line":46,"address":[1043782],"length":1,"stats":{"Line":5}},{"line":50,"address":[439088],"length":1,"stats":{"Line":2}},{"line":51,"address":[439093],"length":1,"stats":{"Line":2}},{"line":55,"address":[439104],"length":1,"stats":{"Line":0}},{"line":56,"address":[948933],"length":1,"stats":{"Line":0}},{"line":60,"address":[439120],"length":1,"stats":{"Line":2}},{"line":61,"address":[439125],"length":1,"stats":{"Line":2}},{"line":65,"address":[439136],"length":1,"stats":{"Line":0}},{"line":66,"address":[948965],"length":1,"stats":{"Line":0}},{"line":70,"address":[439168],"length":1,"stats":{"Line":4}},{"line":71,"address":[949000],"length":1,"stats":{"Line":4}},{"line":112,"address":[439184],"length":1,"stats":{"Line":0}},{"line":144,"address":[439232],"length":1,"stats":{"Line":4}},{"line":146,"address":[949069],"length":1,"stats":{"Line":4}},{"line":151,"address":[439296],"length":1,"stats":{"Line":4}},{"line":152,"address":[949125],"length":1,"stats":{"Line":4}},{"line":156,"address":[439328],"length":1,"stats":{"Line":4}},{"line":157,"address":[949157],"length":1,"stats":{"Line":4}},{"line":161,"address":[439344],"length":1,"stats":{"Line":2}},{"line":162,"address":[949173],"length":1,"stats":{"Line":2}},{"line":167,"address":[439360],"length":1,"stats":{"Line":0}},{"line":168,"address":[439365],"length":1,"stats":{"Line":0}},{"line":172,"address":[439376],"length":1,"stats":{"Line":0}},{"line":173,"address":[949218],"length":1,"stats":{"Line":0}},{"line":174,"address":[1043902,1043888],"length":1,"stats":{"Line":0}},{"line":178,"address":[439408],"length":1,"stats":{"Line":0}},{"line":179,"address":[439426],"length":1,"stats":{"Line":0}},{"line":180,"address":[1044062,1044048],"length":1,"stats":{"Line":0}},{"line":185,"address":[439440],"length":1,"stats":{"Line":0}},{"line":186,"address":[439448],"length":1,"stats":{"Line":0}}],"covered":25,"coverable":40},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","planner.rs"],"content":"//! Action planner - Creates action plans based on audit results\n//!\n//! This module provides functionality to generate action plans from audit results.\n//! It analyzes findings and creates appropriate actions to fix issues.\n\nuse std::collections::HashMap;\n\nuse crate::config::Config;\nuse crate::rules::results::AuditResults;\n\nuse super::plan::{\n    Action, ActionOperation, ActionPlan, BranchProtectionSettings, GitHubRepoSettings,\n};\n\n/// Parameters for planning file creation\nstruct FileCreationParams\u003c'a\u003e {\n    rule_id: \u0026'a str,\n    file_path: \u0026'a str,\n    template: \u0026'a str,\n    action_id: \u0026'a str,\n    action_description: \u0026'a str,\n    detail: Option\u003c\u0026'a str\u003e,\n}\n\n/// Creates action plans based on audit results and configuration\n///\n/// The `ActionPlanner` analyzes audit findings and generates a plan of actions\n/// to fix detected issues. Actions can include:\n/// - Creating missing files (LICENSE, CONTRIBUTING.md, etc.)\n/// - Updating .gitignore\n/// - Configuring branch protection\n/// - Updating GitHub repository settings\npub struct ActionPlanner {\n    /// Configuration for action planning\n    config: Config,\n}\n\nimpl ActionPlanner {\n    /// Create a new action planner with the given configuration\n    ///\n    /// # Arguments\n    ///\n    /// * `config` - The configuration that determines which actions to plan\n    ///\n    /// # Returns\n    ///\n    /// A new `ActionPlanner` instance\n    pub fn new(config: Config) -\u003e Self {\n        Self { config }\n    }\n\n    /// Create an action plan based on audit results\n    ///\n    /// Analyzes the audit results and generates actions to fix detected issues.\n    /// Only actions enabled in the configuration will be included.\n    ///\n    /// # Arguments\n    ///\n    /// * `results` - The audit results to analyze\n    ///\n    /// # Returns\n    ///\n    /// An `ActionPlan` containing all planned actions\n    pub fn create_plan(\u0026self, results: \u0026AuditResults) -\u003e ActionPlan {\n        let mut plan = ActionPlan::new();\n\n        // Plan gitignore updates\n        if self.config.actions.gitignore {\n            if let Some(action) = self.plan_gitignore_update(results) {\n                plan.add(action);\n            }\n        }\n\n        // Plan license creation\n        if self.config.actions.license.enabled {\n            if let Some(action) = self.plan_license_creation(results) {\n                plan.add(action);\n            }\n        }\n\n        // Plan CONTRIBUTING creation\n        if self.config.actions.contributing {\n            if let Some(action) = self.plan_contributing_creation(results) {\n                plan.add(action);\n            }\n        }\n\n        // Plan CODE_OF_CONDUCT creation\n        if self.config.actions.code_of_conduct {\n            if let Some(action) = self.plan_code_of_conduct_creation(results) {\n                plan.add(action);\n            }\n        }\n\n        // Plan SECURITY.md creation\n        if self.config.actions.security_policy {\n            if let Some(action) = self.plan_security_creation(results) {\n                plan.add(action);\n            }\n        }\n\n        // Plan branch protection\n        if self.config.actions.branch_protection.enabled {\n            plan.add(self.plan_branch_protection());\n        }\n\n        // Plan GitHub settings\n        plan.add(self.plan_github_settings());\n\n        plan\n    }\n\n    /// Plan .gitignore updates based on findings\n    ///\n    /// Collects entries that should be added to .gitignore from audit findings\n    /// and adds standard entries if they're missing.\n    ///\n    /// # Arguments\n    ///\n    /// * `results` - The audit results\n    ///\n    /// # Returns\n    ///\n    /// An `Action` to update .gitignore, or `None` if no updates are needed\n    fn plan_gitignore_update(\u0026self, results: \u0026AuditResults) -\u003e Option\u003cAction\u003e {\n        // Collect entries that should be added to .gitignore\n        let mut entries = Vec::new();\n\n        // Check findings for missing gitignore entries\n        for finding in results.findings_by_category(\"files\") {\n            if finding.rule_id == \"FILE003\" {\n                // Extract the pattern from the message\n                if let Some(pattern) = finding.message.split(\"entry: \").nth(1) {\n                    entries.push(pattern.to_string());\n                }\n            }\n        }\n\n        // Add standard entries if not present\n        let standard_entries = [\".env\", \"*.key\", \"*.pem\", \".DS_Store\"];\n        for entry in standard_entries {\n            if !entries.contains(\u0026entry.to_string()) {\n                entries.push(entry.to_string());\n            }\n        }\n\n        if entries.is_empty() {\n            return None;\n        }\n\n        Some(\n            Action::new(\n                \"gitignore-update\",\n                \"gitignore\",\n                \"Add entries to .gitignore\",\n                ActionOperation::UpdateGitignore {\n                    entries: entries.clone(),\n                },\n            )\n            .with_details(entries),\n        )\n    }\n\n    /// Plan LICENSE file creation\n    ///\n    /// Creates a LICENSE file if one is missing and license creation is enabled.\n    ///\n    /// # Arguments\n    ///\n    /// * `results` - The audit results\n    ///\n    /// # Returns\n    ///\n    /// An `Action` to create LICENSE, or `None` if not needed\n    fn plan_license_creation(\u0026self, results: \u0026AuditResults) -\u003e Option\u003cAction\u003e {\n        // Check if LICENSE is missing\n        let needs_license = results\n            .findings_by_category(\"docs\")\n            .any(|f| f.rule_id == \"DOC004\");\n\n        if !needs_license {\n            return None;\n        }\n\n        let license_type = \u0026self.config.actions.license.license_type;\n        let mut variables = HashMap::new();\n\n        if let Some(author) = \u0026self.config.actions.license.author {\n            variables.insert(\"author\".to_string(), author.clone());\n        }\n\n        let year = self\n            .config\n            .actions\n            .license\n            .year\n            .clone()\n            .unwrap_or_else(|| chrono::Utc::now().format(\"%Y\").to_string());\n        variables.insert(\"year\".to_string(), year);\n\n        Some(\n            Action::new(\n                \"license-create\",\n                \"file\",\n                \"Create LICENSE file\",\n                ActionOperation::CreateFile {\n                    path: \"LICENSE\".to_string(),\n                    template: format!(\"LICENSE/{}\", license_type),\n                    variables,\n                },\n            )\n            .with_detail(format!(\"License type: {}\", license_type)),\n        )\n    }\n\n    /// Generic helper to plan file creation from template\n    ///\n    /// # Arguments\n    ///\n    /// * `results` - The audit results\n    /// * `params` - Parameters for file creation\n    ///\n    /// # Returns\n    ///\n    /// An `Action` if the file needs to be created, `None` otherwise\n    fn plan_file_creation(\n        \u0026self,\n        results: \u0026AuditResults,\n        params: FileCreationParams\u003c'_\u003e,\n    ) -\u003e Option\u003cAction\u003e {\n        let needs_file = results\n            .findings_by_category(\"docs\")\n            .any(|f| f.rule_id == params.rule_id);\n\n        if !needs_file {\n            return None;\n        }\n\n        let mut action = Action::new(\n            params.action_id,\n            \"file\",\n            params.action_description,\n            ActionOperation::CreateFile {\n                path: params.file_path.to_string(),\n                template: params.template.to_string(),\n                variables: HashMap::new(),\n            },\n        );\n\n        if let Some(detail) = params.detail {\n            action = action.with_detail(detail);\n        }\n\n        Some(action)\n    }\n\n    fn plan_contributing_creation(\u0026self, results: \u0026AuditResults) -\u003e Option\u003cAction\u003e {\n        self.plan_file_creation(\n            results,\n            FileCreationParams {\n                rule_id: \"DOC005\",\n                file_path: \"CONTRIBUTING.md\",\n                template: \"CONTRIBUTING.md\",\n                action_id: \"contributing-create\",\n                action_description: \"Create CONTRIBUTING.md\",\n                detail: None,\n            },\n        )\n    }\n\n    fn plan_code_of_conduct_creation(\u0026self, results: \u0026AuditResults) -\u003e Option\u003cAction\u003e {\n        self.plan_file_creation(\n            results,\n            FileCreationParams {\n                rule_id: \"DOC006\",\n                file_path: \"CODE_OF_CONDUCT.md\",\n                template: \"CODE_OF_CONDUCT.md\",\n                action_id: \"coc-create\",\n                action_description: \"Create CODE_OF_CONDUCT.md\",\n                detail: Some(\"Using Contributor Covenant template\"),\n            },\n        )\n    }\n\n    fn plan_security_creation(\u0026self, results: \u0026AuditResults) -\u003e Option\u003cAction\u003e {\n        self.plan_file_creation(\n            results,\n            FileCreationParams {\n                rule_id: \"DOC007\",\n                file_path: \"SECURITY.md\",\n                template: \"SECURITY.md\",\n                action_id: \"security-create\",\n                action_description: \"Create SECURITY.md\",\n                detail: None,\n            },\n        )\n    }\n\n    /// Plan branch protection configuration\n    ///\n    /// Creates an action to configure branch protection settings based on\n    /// the configuration.\n    ///\n    /// # Returns\n    ///\n    /// An `Action` to configure branch protection\n    fn plan_branch_protection(\u0026self) -\u003e Action {\n        let bp = \u0026self.config.actions.branch_protection;\n\n        let settings = BranchProtectionSettings {\n            required_approvals: bp.required_approvals,\n            require_status_checks: bp.require_status_checks,\n            require_conversation_resolution: true,\n            require_linear_history: true,\n            block_force_push: bp.block_force_push,\n            block_deletions: true,\n            enforce_admins: true,\n            require_signed_commits: bp.require_signed_commits,\n        };\n\n        let mut details = vec![\n            format!(\"Require PR reviews: {}\", bp.required_approvals),\n            format!(\"Require status checks: {}\", bp.require_status_checks),\n            format!(\"Block force push: {}\", bp.block_force_push),\n        ];\n\n        if bp.require_signed_commits {\n            details.push(\"Require signed commits\".to_string());\n        }\n\n        Action::new(\n            \"branch-protection\",\n            \"github\",\n            format!(\"Enable branch protection on '{}'\", bp.branch),\n            ActionOperation::ConfigureBranchProtection {\n                branch: bp.branch.clone(),\n                settings,\n            },\n        )\n        .with_details(details)\n    }\n\n    /// Plan GitHub repository settings updates\n    ///\n    /// Creates an action to update GitHub repository settings like discussions,\n    /// vulnerability alerts, etc.\n    ///\n    /// # Returns\n    ///\n    /// An `Action` to update GitHub settings\n    fn plan_github_settings(\u0026self) -\u003e Action {\n        let gs = \u0026self.config.actions.github_settings;\n\n        let settings = GitHubRepoSettings {\n            enable_discussions: Some(gs.discussions),\n            enable_issues: Some(gs.issues),\n            enable_wiki: Some(gs.wiki),\n            enable_vulnerability_alerts: Some(gs.vulnerability_alerts),\n            enable_automated_security_fixes: Some(gs.automated_security_fixes),\n        };\n\n        let mut details = Vec::new();\n\n        if gs.discussions {\n            details.push(\"Enable discussions\".to_string());\n        }\n        if gs.vulnerability_alerts {\n            details.push(\"Enable vulnerability alerts\".to_string());\n        }\n        if gs.automated_security_fixes {\n            details.push(\"Enable automated security fixes\".to_string());\n        }\n\n        Action::new(\n            \"github-settings\",\n            \"github\",\n            \"Update repository settings\",\n            ActionOperation::UpdateGitHubSettings { settings },\n        )\n        .with_details(details)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::Config;\n    use crate::rules::results::{AuditResults, Finding, Severity};\n\n    #[test]\n    fn test_create_plan_includes_gitignore() {\n        let config = Config::default();\n        let planner = ActionPlanner::new(config);\n\n        let mut results = AuditResults::new(\"test-repo\", \"opensource\");\n        results.add_finding(Finding::new(\n            \"FILE003\",\n            \"files\",\n            Severity::Info,\n            \".gitignore missing recommended entry: .env\",\n        ));\n\n        let plan = planner.create_plan(\u0026results);\n\n        assert!(!plan.is_empty());\n        assert!(plan.actions().iter().any(|a| a.id() == \"gitignore-update\"));\n    }\n\n    #[test]\n    fn test_create_plan_includes_license() {\n        let config = Config::default();\n        let planner = ActionPlanner::new(config);\n\n        let mut results = AuditResults::new(\"test-repo\", \"opensource\");\n        results.add_finding(Finding::new(\n            \"DOC004\",\n            \"docs\",\n            Severity::Critical,\n            \"LICENSE file is missing\",\n        ));\n\n        let plan = planner.create_plan(\u0026results);\n\n        assert!(plan.actions().iter().any(|a| a.id() == \"license-create\"));\n    }\n\n    #[test]\n    fn test_create_plan_includes_contributing() {\n        let config = Config::default();\n        let planner = ActionPlanner::new(config);\n\n        let mut results = AuditResults::new(\"test-repo\", \"opensource\");\n        results.add_finding(Finding::new(\n            \"DOC005\",\n            \"docs\",\n            Severity::Warning,\n            \"CONTRIBUTING file is missing\",\n        ));\n\n        let plan = planner.create_plan(\u0026results);\n\n        assert!(plan\n            .actions()\n            .iter()\n            .any(|a| a.id() == \"contributing-create\"));\n    }\n\n    #[test]\n    fn test_create_plan_filters_by_config() {\n        let mut config = Config::default();\n        config.actions.contributing = false;\n\n        let planner = ActionPlanner::new(config);\n\n        let mut results = AuditResults::new(\"test-repo\", \"opensource\");\n        results.add_finding(Finding::new(\n            \"DOC005\",\n            \"docs\",\n            Severity::Warning,\n            \"CONTRIBUTING file is missing\",\n        ));\n\n        let plan = planner.create_plan(\u0026results);\n\n        // Should not include contributing because it's disabled in config\n        assert!(!plan\n            .actions()\n            .iter()\n            .any(|a| a.id() == \"contributing-create\"));\n    }\n}\n","traces":[{"line":48,"address":[628816],"length":1,"stats":{"Line":8}},{"line":64,"address":[1055632,1057051,1057045],"length":1,"stats":{"Line":8}},{"line":65,"address":[1055675],"length":1,"stats":{"Line":8}},{"line":68,"address":[1055730,1055976],"length":1,"stats":{"Line":13}},{"line":69,"address":[1055821,1055777],"length":1,"stats":{"Line":15}},{"line":70,"address":[1055956,1055913],"length":1,"stats":{"Line":12}},{"line":75,"address":[1056205,1055744],"length":1,"stats":{"Line":11}},{"line":76,"address":[1056034],"length":1,"stats":{"Line":5}},{"line":77,"address":[1056185,1056139],"length":1,"stats":{"Line":4}},{"line":82,"address":[1056437,1055998],"length":1,"stats":{"Line":7}},{"line":83,"address":[629482],"length":1,"stats":{"Line":4}},{"line":84,"address":[1056417,1056371],"length":1,"stats":{"Line":4}},{"line":89,"address":[629446,629885],"length":1,"stats":{"Line":4}},{"line":90,"address":[1056498],"length":1,"stats":{"Line":2}},{"line":91,"address":[1056649,1056603],"length":1,"stats":{"Line":0}},{"line":96,"address":[1056462,1056899],"length":1,"stats":{"Line":5}},{"line":97,"address":[629946],"length":1,"stats":{"Line":3}},{"line":98,"address":[1056879,1056833],"length":1,"stats":{"Line":0}},{"line":103,"address":[1056694],"length":1,"stats":{"Line":2}},{"line":104,"address":[1056952],"length":1,"stats":{"Line":3}},{"line":108,"address":[630148,630210],"length":1,"stats":{"Line":10}},{"line":110,"address":[1057011],"length":1,"stats":{"Line":4}},{"line":125,"address":[1057072,1058731,1058461],"length":1,"stats":{"Line":8}},{"line":127,"address":[1057119],"length":1,"stats":{"Line":8}},{"line":130,"address":[1057244,1057160],"length":1,"stats":{"Line":16}},{"line":131,"address":[1058474,1057409],"length":1,"stats":{"Line":4}},{"line":133,"address":[631707],"length":1,"stats":{"Line":2}},{"line":134,"address":[1058673],"length":1,"stats":{"Line":2}},{"line":140,"address":[630649],"length":1,"stats":{"Line":5}},{"line":141,"address":[1057541,1057729],"length":1,"stats":{"Line":9}},{"line":142,"address":[1058250,1057818],"length":1,"stats":{"Line":10}},{"line":143,"address":[1058403],"length":1,"stats":{"Line":5}},{"line":147,"address":[631081],"length":1,"stats":{"Line":6}},{"line":148,"address":[1057940],"length":1,"stats":{"Line":0}},{"line":152,"address":[1058163,1058030],"length":1,"stats":{"Line":10}},{"line":156,"address":[1057980],"length":1,"stats":{"Line":7}},{"line":157,"address":[1057898],"length":1,"stats":{"Line":7}},{"line":160,"address":[1058099],"length":1,"stats":{"Line":7}},{"line":175,"address":[1059304,1058768,1060249],"length":1,"stats":{"Line":7}},{"line":177,"address":[1058819],"length":1,"stats":{"Line":7}},{"line":179,"address":[914681,914656],"length":1,"stats":{"Line":9}},{"line":181,"address":[1058895],"length":1,"stats":{"Line":2}},{"line":182,"address":[1058904],"length":1,"stats":{"Line":2}},{"line":185,"address":[1058924],"length":1,"stats":{"Line":2}},{"line":186,"address":[1058933],"length":1,"stats":{"Line":2}},{"line":188,"address":[1059028,1058956],"length":1,"stats":{"Line":2}},{"line":189,"address":[1059174,1059036,1059147],"length":1,"stats":{"Line":0}},{"line":192,"address":[1059072,1059310],"length":1,"stats":{"Line":4}},{"line":198,"address":[1134352,1134368],"length":1,"stats":{"Line":6}},{"line":199,"address":[1059420,1059348],"length":1,"stats":{"Line":4}},{"line":202,"address":[1059876,1060118],"length":1,"stats":{"Line":4}},{"line":206,"address":[632980],"length":1,"stats":{"Line":2}},{"line":207,"address":[1059515],"length":1,"stats":{"Line":2}},{"line":208,"address":[1059614,1059546],"length":1,"stats":{"Line":4}},{"line":209,"address":[1059714],"length":1,"stats":{"Line":2}},{"line":212,"address":[1060217,1059953,1059977,1060162],"length":1,"stats":{"Line":4}},{"line":226,"address":[1060288,1061023],"length":1,"stats":{"Line":4}},{"line":231,"address":[633555],"length":1,"stats":{"Line":4}},{"line":233,"address":[914864,914889],"length":1,"stats":{"Line":6}},{"line":235,"address":[633604],"length":1,"stats":{"Line":2}},{"line":236,"address":[1060397],"length":1,"stats":{"Line":2}},{"line":240,"address":[1060417],"length":1,"stats":{"Line":2}},{"line":242,"address":[633651],"length":1,"stats":{"Line":2}},{"line":243,"address":[633842],"length":1,"stats":{"Line":2}},{"line":244,"address":[1060453],"length":1,"stats":{"Line":2}},{"line":245,"address":[1060493],"length":1,"stats":{"Line":2}},{"line":246,"address":[633794],"length":1,"stats":{"Line":2}},{"line":250,"address":[634036],"length":1,"stats":{"Line":2}},{"line":251,"address":[1060886],"length":1,"stats":{"Line":0}},{"line":254,"address":[634185],"length":1,"stats":{"Line":2}},{"line":257,"address":[1061056],"length":1,"stats":{"Line":4}},{"line":258,"address":[1061217],"length":1,"stats":{"Line":4}},{"line":260,"address":[1061092],"length":1,"stats":{"Line":4}},{"line":266,"address":[1061083],"length":1,"stats":{"Line":4}},{"line":271,"address":[1061248],"length":1,"stats":{"Line":2}},{"line":272,"address":[1061421],"length":1,"stats":{"Line":2}},{"line":274,"address":[634512],"length":1,"stats":{"Line":2}},{"line":280,"address":[1061275],"length":1,"stats":{"Line":2}},{"line":285,"address":[1061456],"length":1,"stats":{"Line":3}},{"line":286,"address":[634833],"length":1,"stats":{"Line":3}},{"line":288,"address":[634708],"length":1,"stats":{"Line":3}},{"line":294,"address":[634699],"length":1,"stats":{"Line":3}},{"line":307,"address":[636313,634864,636307],"length":1,"stats":{"Line":3}},{"line":308,"address":[1061676],"length":1,"stats":{"Line":3}},{"line":311,"address":[1061715],"length":1,"stats":{"Line":2}},{"line":312,"address":[634952],"length":1,"stats":{"Line":4}},{"line":315,"address":[634958],"length":1,"stats":{"Line":2}},{"line":318,"address":[634964],"length":1,"stats":{"Line":4}},{"line":321,"address":[635055,635206,635732,635519,635016,636342,635375],"length":1,"stats":{"Line":6}},{"line":322,"address":[1061815,1061871],"length":1,"stats":{"Line":7}},{"line":323,"address":[635247,635183],"length":1,"stats":{"Line":7}},{"line":324,"address":[1062203,1062136],"length":1,"stats":{"Line":6}},{"line":327,"address":[1062508],"length":1,"stats":{"Line":2}},{"line":328,"address":[1062625,1062553],"length":1,"stats":{"Line":0}},{"line":334,"address":[1062534,1062661],"length":1,"stats":{"Line":6}},{"line":335,"address":[1062834],"length":1,"stats":{"Line":3}},{"line":336,"address":[1062774],"length":1,"stats":{"Line":5}},{"line":340,"address":[1062991],"length":1,"stats":{"Line":2}},{"line":351,"address":[1063777,1063806,1063136],"length":1,"stats":{"Line":2}},{"line":352,"address":[1063166],"length":1,"stats":{"Line":7}},{"line":355,"address":[1063198],"length":1,"stats":{"Line":4}},{"line":356,"address":[636426],"length":1,"stats":{"Line":3}},{"line":357,"address":[1063222],"length":1,"stats":{"Line":4}},{"line":358,"address":[1063234],"length":1,"stats":{"Line":4}},{"line":359,"address":[1063246],"length":1,"stats":{"Line":4}},{"line":362,"address":[1063298],"length":1,"stats":{"Line":4}},{"line":364,"address":[1063322],"length":1,"stats":{"Line":4}},{"line":365,"address":[636629,636560],"length":1,"stats":{"Line":8}},{"line":367,"address":[1063336],"length":1,"stats":{"Line":4}},{"line":368,"address":[1063460],"length":1,"stats":{"Line":4}},{"line":370,"address":[1063448],"length":1,"stats":{"Line":4}},{"line":371,"address":[1063627],"length":1,"stats":{"Line":4}},{"line":378,"address":[1063518],"length":1,"stats":{"Line":4}},{"line":380,"address":[1063699],"length":1,"stats":{"Line":4}}],"covered":108,"coverable":114},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","actions","templates.rs"],"content":"//! Template file creation\n\nuse crate::error::{ActionError, RepoLensError};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\n/// Create a file from a template\npub fn create_file_from_template(\n    path: \u0026str,\n    template_name: \u0026str,\n    variables: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003c(), RepoLensError\u003e {\n    let template_content = get_template(template_name)?;\n\n    // Replace variables in template\n    let mut content = template_content;\n    for (key, value) in variables {\n        content = content.replace(\u0026format!(\"{{{{ {} }}}}\", key), value);\n        content = content.replace(\u0026format!(\"{{{{{}}}}}\", key), value);\n    }\n\n    // Write the file\n    let file_path = Path::new(path);\n\n    // Create parent directories if needed\n    if let Some(parent) = file_path.parent() {\n        if !parent.as_os_str().is_empty() {\n            fs::create_dir_all(parent).map_err(|e| {\n                RepoLensError::Action(ActionError::DirectoryCreate {\n                    path: parent.display().to_string(),\n                    source: e,\n                })\n            })?;\n        }\n    }\n\n    fs::write(file_path, content).map_err(|e| {\n        RepoLensError::Action(ActionError::FileWrite {\n            path: path.to_string(),\n            source: e,\n        })\n    })?;\n\n    Ok(())\n}\n\n/// Get template content by name\nfn get_template(name: \u0026str) -\u003e Result\u003cString, RepoLensError\u003e {\n    match name {\n        \"LICENSE/MIT\" =\u003e Ok(MIT_LICENSE.to_string()),\n        \"LICENSE/Apache-2.0\" =\u003e Ok(APACHE_LICENSE.to_string()),\n        \"LICENSE/GPL-3.0\" =\u003e Ok(GPL_LICENSE_HEADER.to_string()),\n        \"CONTRIBUTING.md\" =\u003e Ok(CONTRIBUTING_TEMPLATE.to_string()),\n        \"CODE_OF_CONDUCT.md\" =\u003e Ok(CODE_OF_CONDUCT_TEMPLATE.to_string()),\n        \"SECURITY.md\" =\u003e Ok(SECURITY_TEMPLATE.to_string()),\n        \"ISSUE_TEMPLATE/bug_report.md\" =\u003e Ok(BUG_REPORT_TEMPLATE.to_string()),\n        \"ISSUE_TEMPLATE/feature_request.md\" =\u003e Ok(FEATURE_REQUEST_TEMPLATE.to_string()),\n        \"PULL_REQUEST_TEMPLATE/pull_request_template.md\" =\u003e Ok(PULL_REQUEST_TEMPLATE.to_string()),\n        _ =\u003e Err(RepoLensError::Action(ActionError::UnknownTemplate {\n            name: name.to_string(),\n        })),\n    }\n}\n\nconst MIT_LICENSE: \u0026str = r#\"MIT License\n\nCopyright (c) {{ year }} {{ author }}\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"#;\n\nconst APACHE_LICENSE: \u0026str = r#\"                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   Copyright {{ year }} {{ author }}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\"#;\n\nconst GPL_LICENSE_HEADER: \u0026str = r#\"Copyright (C) {{ year }} {{ author }}\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\"#;\n\nconst CONTRIBUTING_TEMPLATE: \u0026str = r#\"# Contributing\n\nThank you for your interest in contributing to this project!\n\n## How to Contribute\n\n### Reporting Issues\n\n- Check if the issue already exists\n- Use a clear and descriptive title\n- Provide steps to reproduce the issue\n- Include relevant logs or screenshots\n\n### Pull Requests\n\n1. Fork the repository\n2. Create a feature branch (`git checkout -b feature/amazing-feature`)\n3. Make your changes\n4. Run tests to ensure everything works\n5. Commit your changes (`git commit -m 'Add amazing feature'`)\n6. Push to the branch (`git push origin feature/amazing-feature`)\n7. Open a Pull Request\n\n### Code Style\n\n- Follow the existing code style\n- Write meaningful commit messages\n- Add tests for new features\n- Update documentation as needed\n\n### Development Setup\n\n```bash\n# Clone the repository\ngit clone \u003crepository-url\u003e\ncd \u003cproject\u003e\n\n# Install dependencies\n# Add project-specific setup instructions here\n```\n\n## Questions?\n\nFeel free to open an issue for any questions or concerns.\n\"#;\n\nconst CODE_OF_CONDUCT_TEMPLATE: \u0026str = r#\"# Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, caste, color, religion, or sexual\nidentity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior:\n\n* The use of sexualized language or imagery, and sexual attention or advances\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information without explicit permission\n* Other conduct which could reasonably be considered inappropriate\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the project maintainers. All complaints will be reviewed and\ninvestigated promptly and fairly.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org),\nversion 2.1.\n\"#;\n\nconst SECURITY_TEMPLATE: \u0026str = r#\"# Security Policy\n\n## Reporting a Vulnerability\n\nWe take security seriously. If you discover a security vulnerability, please follow these steps:\n\n1. **Do not** open a public issue\n2. Email us at [security@example.com] with details\n3. Include steps to reproduce the vulnerability\n4. Allow time for us to investigate and respond\n\n## What to Include\n\n- Type of vulnerability\n- Steps to reproduce\n- Potential impact\n- Suggested fix (if any)\n\n## Response Timeline\n\n- **Initial Response**: Within 48 hours\n- **Status Update**: Within 7 days\n- **Resolution**: Depends on severity and complexity\n\n## Supported Versions\n\n| Version | Supported          |\n| ------- | ------------------ |\n| latest  | :white_check_mark: |\n| \u003c 1.0   | :x:                |\n\n## Security Best Practices\n\nWhen using this project:\n\n- Keep dependencies up to date\n- Use environment variables for secrets\n- Follow the principle of least privilege\n- Enable security features where available\n\nThank you for helping keep this project secure!\n\"#;\n\nconst BUG_REPORT_TEMPLATE: \u0026str = r#\"---\nname: Bug Report\nabout: Create a report to help us improve\ntitle: ''\nlabels: bug\nassignees: ''\n---\n\n## Description\n\nA clear and concise description of what the bug is.\n\n## Steps to Reproduce\n\n1. Go to '...'\n2. Click on '....'\n3. Scroll down to '....'\n4. See error\n\n## Expected Behavior\n\nA clear and concise description of what you expected to happen.\n\n## Actual Behavior\n\nA clear and concise description of what actually happened.\n\n## Environment\n\n- OS: [e.g. Ubuntu 22.04, macOS 13.0, Windows 11]\n- Version: [e.g. 0.1.0]\n- Rust version: [e.g. 1.70.0]\n\n## Additional Context\n\nAdd any other context about the problem here.\n\n## Screenshots\n\nIf applicable, add screenshots to help explain your problem.\n\"#;\n\nconst FEATURE_REQUEST_TEMPLATE: \u0026str = r#\"---\nname: Feature Request\nabout: Suggest an idea for this project\ntitle: ''\nlabels: enhancement\nassignees: ''\n---\n\n## Problem Statement\n\nA clear and concise description of what the problem is. Ex. I'm always frustrated when [...]\n\n## Proposed Solution\n\nA clear and concise description of what you want to happen.\n\n## Alternatives Considered\n\nA clear and concise description of any alternative solutions or features you've considered.\n\n## Use Cases\n\nDescribe the use cases for this feature:\n\n1. Use case 1\n2. Use case 2\n3. Use case 3\n\n## Additional Context\n\nAdd any other context, mockups, or examples about the feature request here.\n\n## Implementation Notes (Optional)\n\nIf you have ideas about how this could be implemented, please share them here.\n\"#;\n\nconst PULL_REQUEST_TEMPLATE: \u0026str = r#\"## Description\n\nBrief description of changes.\n\n## Type of Change\n\n- [ ] Bug fix\n- [ ] New feature\n- [ ] Documentation update\n- [ ] Refactoring\n\n## Checklist\n\n- [ ] Code compiles without errors\n- [ ] Tests pass\n- [ ] Code follows project style guidelines\n- [ ] Documentation updated if needed\n\"#;\n","traces":[{"line":9,"address":[467969,467997,465584],"length":1,"stats":{"Line":2}},{"line":14,"address":[465709],"length":1,"stats":{"Line":2}},{"line":17,"address":[465926],"length":1,"stats":{"Line":2}},{"line":18,"address":[466030,465982],"length":1,"stats":{"Line":4}},{"line":19,"address":[1393142,1394065,1394323],"length":1,"stats":{"Line":0}},{"line":20,"address":[467529,467824],"length":1,"stats":{"Line":0}},{"line":24,"address":[466240],"length":1,"stats":{"Line":2}},{"line":27,"address":[466321],"length":1,"stats":{"Line":2}},{"line":28,"address":[466453,466571],"length":1,"stats":{"Line":4}},{"line":29,"address":[415100,415106,414880],"length":1,"stats":{"Line":0}},{"line":30,"address":[780180],"length":1,"stats":{"Line":0}},{"line":31,"address":[780063,780141],"length":1,"stats":{"Line":0}},{"line":32,"address":[780175],"length":1,"stats":{"Line":0}},{"line":38,"address":[780436,780442,780272],"length":1,"stats":{"Line":4}},{"line":39,"address":[780367],"length":1,"stats":{"Line":0}},{"line":40,"address":[780300],"length":1,"stats":{"Line":0}},{"line":41,"address":[780362],"length":1,"stats":{"Line":0}},{"line":45,"address":[466971],"length":1,"stats":{"Line":2}},{"line":49,"address":[1394976],"length":1,"stats":{"Line":2}},{"line":51,"address":[468145,468091],"length":1,"stats":{"Line":2}},{"line":52,"address":[1395189,1395066],"length":1,"stats":{"Line":3}},{"line":53,"address":[468345,468222],"length":1,"stats":{"Line":3}},{"line":54,"address":[1395266,1395389],"length":1,"stats":{"Line":4}},{"line":55,"address":[468548,468422],"length":1,"stats":{"Line":2}},{"line":56,"address":[468660,468525],"length":1,"stats":{"Line":2}},{"line":57,"address":[468772,468637],"length":1,"stats":{"Line":2}},{"line":58,"address":[468888,468749],"length":1,"stats":{"Line":2}},{"line":59,"address":[468861,469102],"length":1,"stats":{"Line":2}},{"line":60,"address":[468991],"length":1,"stats":{"Line":2}},{"line":61,"address":[468977],"length":1,"stats":{"Line":2}}],"covered":21,"coverable":30},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","commands","apply.rs"],"content":"//! Apply command - Apply planned changes to the repository\n\nuse colored::Colorize;\nuse dialoguer::Confirm;\nuse std::path::PathBuf;\n\nuse super::ApplyArgs;\nuse crate::actions::executor::ActionExecutor;\nuse crate::actions::planner::ActionPlanner;\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::exit_codes;\nuse crate::rules::engine::RulesEngine;\nuse crate::scanner::Scanner;\n\npub async fn execute(args: ApplyArgs) -\u003e Result\u003ci32, RepoLensError\u003e {\n    // Load configuration\n    let config = Config::load_or_default()?;\n\n    // Initialize scanner\n    let scanner = Scanner::new(PathBuf::from(\".\"));\n\n    // Run the rules engine to get current state\n    let engine = RulesEngine::new(config.clone());\n    let audit_results = engine.run(\u0026scanner).await?;\n\n    // Generate action plan\n    let planner = ActionPlanner::new(config.clone());\n    let mut action_plan = planner.create_plan(\u0026audit_results);\n\n    // Apply filters if specified\n    if let Some(only) = \u0026args.only {\n        action_plan.filter_only(only);\n    }\n    if let Some(skip) = \u0026args.skip {\n        action_plan.filter_skip(skip);\n    }\n\n    // Check if there are any actions to perform\n    if action_plan.is_empty() {\n        println!(\"{}\", \"No actions to perform.\".green());\n        return Ok(exit_codes::SUCCESS);\n    }\n\n    // Display plan summary\n    println!(\"{}\", \"Planned actions:\".bold());\n    println!();\n    for action in action_plan.actions() {\n        println!(\"  {} {}\", \"+\".green(), action.description());\n    }\n    println!();\n\n    // Dry run mode\n    if args.dry_run {\n        println!(\"{}\", \"Dry run mode - no changes made.\".yellow());\n        return Ok(exit_codes::SUCCESS);\n    }\n\n    // Confirm execution\n    if !args.yes {\n        let confirm = Confirm::new()\n            .with_prompt(\"Apply these changes?\")\n            .default(false)\n            .interact()\n            .map_err(|e| {\n                RepoLensError::Action(crate::error::ActionError::ExecutionFailed {\n                    message: format!(\"Failed to get user input: {}\", e),\n                })\n            })?;\n\n        if !confirm {\n            println!(\"{}\", \"Aborted.\".yellow());\n            return Ok(exit_codes::SUCCESS);\n        }\n    }\n\n    // Execute actions\n    let executor = ActionExecutor::new(config);\n    let results = executor.execute(\u0026action_plan).await?;\n\n    // Display results\n    println!();\n    let mut success_count = 0;\n    let mut error_count = 0;\n\n    for result in \u0026results {\n        if result.success {\n            println!(\"  {} {}\", \"‚úì\".green(), result.action_name);\n            success_count += 1;\n        } else {\n            println!(\n                \"  {} {} - {}\",\n                \"‚úó\".red(),\n                result.action_name,\n                result.error.as_deref().unwrap_or(\"Unknown error\")\n            );\n            error_count += 1;\n        }\n    }\n\n    println!();\n    println!(\n        \"{}: {} succeeded, {} failed\",\n        \"Summary\".bold(),\n        success_count.to_string().green(),\n        error_count.to_string().red()\n    );\n\n    if error_count \u003e 0 {\n        Ok(exit_codes::ERROR)\n    } else {\n        Ok(exit_codes::SUCCESS)\n    }\n}\n","traces":[{"line":16,"address":[765041,765024],"length":1,"stats":{"Line":0}},{"line":18,"address":[960149,960295,960910],"length":1,"stats":{"Line":0}},{"line":21,"address":[960527,960606],"length":1,"stats":{"Line":0}},{"line":24,"address":[960707,960636],"length":1,"stats":{"Line":0}},{"line":25,"address":[964186,960975,960737,960186,960840],"length":1,"stats":{"Line":0}},{"line":28,"address":[961542,961616],"length":1,"stats":{"Line":0}},{"line":29,"address":[961646],"length":1,"stats":{"Line":0}},{"line":32,"address":[961735],"length":1,"stats":{"Line":0}},{"line":33,"address":[961807,961992],"length":1,"stats":{"Line":0}},{"line":35,"address":[961856,962012],"length":1,"stats":{"Line":0}},{"line":36,"address":[962122,962020],"length":1,"stats":{"Line":0}},{"line":40,"address":[962138,962069],"length":1,"stats":{"Line":0}},{"line":41,"address":[961807,959983],"length":1,"stats":{"Line":0}},{"line":42,"address":[964158],"length":1,"stats":{"Line":0}},{"line":46,"address":[962144,962209],"length":1,"stats":{"Line":0}},{"line":47,"address":[962368],"length":1,"stats":{"Line":0}},{"line":48,"address":[960221],"length":1,"stats":{"Line":0}},{"line":49,"address":[963743,962616],"length":1,"stats":{"Line":0}},{"line":51,"address":[962650],"length":1,"stats":{"Line":0}},{"line":54,"address":[960503],"length":1,"stats":{"Line":0}},{"line":55,"address":[962725,963556],"length":1,"stats":{"Line":0}},{"line":56,"address":[963715],"length":1,"stats":{"Line":0}},{"line":60,"address":[962709],"length":1,"stats":{"Line":0}},{"line":61,"address":[963077,962759,962868,963381],"length":1,"stats":{"Line":0}},{"line":65,"address":[966832,967081,967087],"length":1,"stats":{"Line":0}},{"line":66,"address":[967003],"length":1,"stats":{"Line":0}},{"line":67,"address":[964674,964722],"length":1,"stats":{"Line":0}},{"line":71,"address":[963129],"length":1,"stats":{"Line":0}},{"line":72,"address":[963137],"length":1,"stats":{"Line":0}},{"line":73,"address":[963327],"length":1,"stats":{"Line":0}},{"line":78,"address":[962778],"length":1,"stats":{"Line":0}},{"line":79,"address":[960207,963383,964213,963486],"length":1,"stats":{"Line":0}},{"line":82,"address":[964694,964628],"length":1,"stats":{"Line":0}},{"line":83,"address":[964713],"length":1,"stats":{"Line":0}},{"line":84,"address":[964724],"length":1,"stats":{"Line":0}},{"line":86,"address":[964743],"length":1,"stats":{"Line":0}},{"line":87,"address":[964190,962679,964441],"length":1,"stats":{"Line":0}},{"line":88,"address":[966407,965978],"length":1,"stats":{"Line":0}},{"line":89,"address":[964414,964446],"length":1,"stats":{"Line":0}},{"line":91,"address":[965947],"length":1,"stats":{"Line":0}},{"line":97,"address":[966387,966353],"length":1,"stats":{"Line":0}},{"line":101,"address":[964886],"length":1,"stats":{"Line":0}},{"line":102,"address":[965318,965235],"length":1,"stats":{"Line":0}},{"line":109,"address":[965601,965634],"length":1,"stats":{"Line":0}},{"line":110,"address":[965636],"length":1,"stats":{"Line":0}},{"line":112,"address":[965611],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","commands","init.rs"],"content":"//! Init command - Initialize a new configuration file\n\nuse colored::Colorize;\nuse dialoguer::{Confirm, Select};\nuse std::fs;\nuse std::path::Path;\n\nuse super::InitArgs;\nuse crate::config::{Config, Preset};\nuse crate::error::{ActionError, RepoLensError};\nuse crate::utils::prerequisites::{\n    display_error_summary, display_report, display_warnings, run_all_checks, CheckOptions,\n};\n\nconst CONFIG_FILENAME: \u0026str = \".repolens.toml\";\n\npub async fn execute(args: InitArgs) -\u003e Result\u003ci32, RepoLensError\u003e {\n    let root = std::env::current_dir().map_err(|e| {\n        RepoLensError::Action(ActionError::ExecutionFailed {\n            message: format!(\"Failed to get current directory: {}\", e),\n        })\n    })?;\n    let config_path = Path::new(CONFIG_FILENAME);\n\n    // Run prerequisite checks unless skipped\n    if !args.skip_checks {\n        let options = CheckOptions::default();\n        let report = run_all_checks(\u0026root, \u0026options);\n        display_report(\u0026report, false);\n\n        if !report.all_required_passed() {\n            display_error_summary(\u0026report);\n\n            if args.non_interactive {\n                return Ok(crate::exit_codes::ERROR);\n            }\n\n            // Ask if user wants to continue anyway\n            let continue_anyway = Confirm::new()\n                .with_prompt(\"Continue anyway?\")\n                .default(false)\n                .interact()\n                .map_err(|e| {\n                    RepoLensError::Action(ActionError::ExecutionFailed {\n                        message: format!(\"Failed to get user input: {}\", e),\n                    })\n                })?;\n\n            if !continue_anyway {\n                return Ok(crate::exit_codes::ERROR);\n            }\n\n            println!();\n        } else if report.has_warnings() {\n            display_warnings(\u0026report);\n        }\n    }\n\n    // Check if config already exists\n    if config_path.exists() \u0026\u0026 !args.force {\n        if args.non_interactive {\n            eprintln!(\n                \"{} Configuration file already exists. Use --force to overwrite.\",\n                \"Error:\".red().bold()\n            );\n            return Ok(1);\n        }\n\n        let overwrite = Confirm::new()\n            .with_prompt(\"Configuration file already exists. Overwrite?\")\n            .default(false)\n            .interact()\n            .map_err(|e| {\n                RepoLensError::Action(ActionError::ExecutionFailed {\n                    message: format!(\"Failed to get user input: {}\", e),\n                })\n            })?;\n\n        if !overwrite {\n            println!(\"{}\", \"Aborted.\".yellow());\n            return Ok(0);\n        }\n    }\n\n    // Determine preset\n    let preset = if let Some(preset_name) = args.preset {\n        Preset::from_name(\u0026preset_name).ok_or(RepoLensError::Config(\n            crate::error::ConfigError::InvalidPreset { name: preset_name },\n        ))?\n    } else if args.non_interactive {\n        Preset::OpenSource\n    } else {\n        select_preset()?\n    };\n\n    // Create configuration\n    let config = Config::from_preset(preset);\n\n    // Write configuration file\n    let config_content = config.to_toml()?;\n    fs::write(config_path, \u0026config_content).map_err(|e| {\n        RepoLensError::Action(ActionError::FileWrite {\n            path: config_path.display().to_string(),\n            source: e,\n        })\n    })?;\n\n    println!(\n        \"{} Created {} with preset '{}'\",\n        \"Success:\".green().bold(),\n        CONFIG_FILENAME.cyan(),\n        preset.name().yellow()\n    );\n\n    println!(\"\\nNext steps:\");\n    println!(\"  1. Review and customize {}\", CONFIG_FILENAME.cyan());\n    println!(\"  2. Run {} to see planned actions\", \"repolens plan\".cyan());\n    println!(\"  3. Run {} to apply changes\", \"repolens apply\".cyan());\n\n    Ok(0)\n}\n\nfn select_preset() -\u003e Result\u003cPreset, RepoLensError\u003e {\n    let presets = [\n        (\n            \"opensource\",\n            \"Open Source - Prepare repository for public release\",\n        ),\n        (\"enterprise\", \"Enterprise - Internal company standards\"),\n        (\"strict\", \"Strict - Maximum security and compliance checks\"),\n    ];\n\n    let selection = Select::new()\n        .with_prompt(\"Select a preset\")\n        .items(\u0026presets.iter().map(|(_, desc)| *desc).collect::\u003cVec\u003c_\u003e\u003e())\n        .default(0)\n        .interact()\n        .map_err(|e| {\n            RepoLensError::Action(ActionError::ExecutionFailed {\n                message: format!(\"Failed to get user input: {}\", e),\n            })\n        })?;\n\n    Ok(match selection {\n        0 =\u003e Preset::OpenSource,\n        1 =\u003e Preset::Enterprise,\n        2 =\u003e Preset::Strict,\n        _ =\u003e Preset::OpenSource,\n    })\n}\n","traces":[{"line":17,"address":[778734,782333,777607,782086,777502,777472],"length":1,"stats":{"Line":0}},{"line":18,"address":[134003,129087,133997,129193,133744,128964,133629],"length":1,"stats":{"Line":0}},{"line":19,"address":[133919],"length":1,"stats":{"Line":0}},{"line":20,"address":[133765,133830],"length":1,"stats":{"Line":0}},{"line":23,"address":[129290,129377],"length":1,"stats":{"Line":0}},{"line":26,"address":[778017],"length":1,"stats":{"Line":0}},{"line":27,"address":[129403,129442],"length":1,"stats":{"Line":0}},{"line":28,"address":[129459],"length":1,"stats":{"Line":0}},{"line":29,"address":[129519],"length":1,"stats":{"Line":0}},{"line":31,"address":[778198],"length":1,"stats":{"Line":0}},{"line":32,"address":[129603],"length":1,"stats":{"Line":0}},{"line":34,"address":[129632],"length":1,"stats":{"Line":0}},{"line":35,"address":[129661],"length":1,"stats":{"Line":0}},{"line":39,"address":[129689,129898,129642,130059],"length":1,"stats":{"Line":0}},{"line":43,"address":[134016,134265,134271],"length":1,"stats":{"Line":0}},{"line":44,"address":[134187],"length":1,"stats":{"Line":0}},{"line":45,"address":[134098,134050],"length":1,"stats":{"Line":0}},{"line":49,"address":[129950],"length":1,"stats":{"Line":0}},{"line":50,"address":[129954],"length":1,"stats":{"Line":0}},{"line":53,"address":[129979,130020],"length":1,"stats":{"Line":0}},{"line":54,"address":[129618,130087],"length":1,"stats":{"Line":0}},{"line":55,"address":[130101],"length":1,"stats":{"Line":0}},{"line":60,"address":[130120,130172,129424],"length":1,"stats":{"Line":0}},{"line":61,"address":[130182],"length":1,"stats":{"Line":0}},{"line":62,"address":[130211,130737],"length":1,"stats":{"Line":0}},{"line":66,"address":[130923],"length":1,"stats":{"Line":0}},{"line":69,"address":[130454,130245,130192,130732],"length":1,"stats":{"Line":0}},{"line":73,"address":[134288,134537,134543],"length":1,"stats":{"Line":0}},{"line":74,"address":[134459],"length":1,"stats":{"Line":0}},{"line":75,"address":[134322,134370],"length":1,"stats":{"Line":0}},{"line":79,"address":[130506],"length":1,"stats":{"Line":0}},{"line":80,"address":[130514],"length":1,"stats":{"Line":0}},{"line":81,"address":[130704],"length":1,"stats":{"Line":0}},{"line":86,"address":[130951,130126],"length":1,"stats":{"Line":0}},{"line":87,"address":[131007,131368,131199,131094],"length":1,"stats":{"Line":0}},{"line":88,"address":[131109],"length":1,"stats":{"Line":0}},{"line":90,"address":[131673,131453,131043,131419,131521,131024],"length":1,"stats":{"Line":0}},{"line":91,"address":[131513],"length":1,"stats":{"Line":0}},{"line":93,"address":[131506,131539,131678],"length":1,"stats":{"Line":0}},{"line":97,"address":[780051],"length":1,"stats":{"Line":0}},{"line":100,"address":[133588,131699,131762],"length":1,"stats":{"Line":0}},{"line":101,"address":[780663,783184,780769,783410,783404,780584],"length":1,"stats":{"Line":0}},{"line":102,"address":[134708],"length":1,"stats":{"Line":0}},{"line":103,"address":[134669,134591],"length":1,"stats":{"Line":0}},{"line":104,"address":[134703],"length":1,"stats":{"Line":0}},{"line":108,"address":[780860,780962,781082],"length":1,"stats":{"Line":0}},{"line":115,"address":[132687],"length":1,"stats":{"Line":0}},{"line":116,"address":[781356],"length":1,"stats":{"Line":0}},{"line":117,"address":[132922],"length":1,"stats":{"Line":0}},{"line":118,"address":[781736],"length":1,"stats":{"Line":0}},{"line":120,"address":[133302],"length":1,"stats":{"Line":0}},{"line":123,"address":[465563,464544,465557],"length":1,"stats":{"Line":0}},{"line":124,"address":[464561,464731],"length":1,"stats":{"Line":0}},{"line":129,"address":[464623],"length":1,"stats":{"Line":0}},{"line":130,"address":[464677],"length":1,"stats":{"Line":0}},{"line":133,"address":[465349,465120,464821,465203,465081],"length":1,"stats":{"Line":0}},{"line":135,"address":[1137787,1138008,1138431,1137929],"length":1,"stats":{"Line":0}},{"line":138,"address":[135087,134832,135081],"length":1,"stats":{"Line":0}},{"line":139,"address":[783627],"length":1,"stats":{"Line":0}},{"line":140,"address":[783490,783538],"length":1,"stats":{"Line":0}},{"line":144,"address":[465489,465415],"length":1,"stats":{"Line":0}},{"line":145,"address":[465456],"length":1,"stats":{"Line":0}},{"line":146,"address":[465466],"length":1,"stats":{"Line":0}},{"line":147,"address":[465476],"length":1,"stats":{"Line":0}},{"line":148,"address":[465446],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":65},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","commands","mod.rs"],"content":"//! CLI commands module\n\npub mod apply;\npub mod init;\npub mod plan;\npub mod report;\n\nuse clap::Args;\nuse std::path::PathBuf;\n\n/// Arguments for the init command\n#[derive(Args, Debug)]\npub struct InitArgs {\n    /// Preset to use (opensource, enterprise, strict)\n    #[arg(short, long, value_name = \"PRESET\")]\n    pub preset: Option\u003cString\u003e,\n\n    /// Force overwrite existing configuration\n    #[arg(short, long)]\n    pub force: bool,\n\n    /// Skip interactive prompts\n    #[arg(long)]\n    pub non_interactive: bool,\n\n    /// Skip prerequisite checks (git, gh, etc.)\n    #[arg(long)]\n    pub skip_checks: bool,\n}\n\n/// Arguments for the plan command\n#[derive(Args, Debug)]\npub struct PlanArgs {\n    /// Output format (terminal, json, sarif)\n    #[arg(short, long, default_value = \"terminal\")]\n    pub format: OutputFormat,\n\n    /// Only check specific rule categories\n    #[arg(long, value_delimiter = ',')]\n    pub only: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// Skip specific rule categories\n    #[arg(long, value_delimiter = ',')]\n    pub skip: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// Output file (defaults to stdout)\n    #[arg(short, long, value_name = \"FILE\")]\n    pub output: Option\u003cPathBuf\u003e,\n}\n\n/// Arguments for the apply command\n#[derive(Args, Debug)]\npub struct ApplyArgs {\n    /// Skip confirmation prompts\n    #[arg(short, long)]\n    pub yes: bool,\n\n    /// Dry run - show what would be done without making changes\n    #[arg(long)]\n    pub dry_run: bool,\n\n    /// Only apply specific actions\n    #[arg(long, value_delimiter = ',')]\n    pub only: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// Skip specific actions\n    #[arg(long, value_delimiter = ',')]\n    pub skip: Option\u003cVec\u003cString\u003e\u003e,\n}\n\n/// Arguments for the report command\n#[derive(Args, Debug)]\npub struct ReportArgs {\n    /// Output format (html, markdown, json)\n    #[arg(short, long, default_value = \"markdown\")]\n    pub format: ReportFormat,\n\n    /// Output file\n    #[arg(short, long, value_name = \"FILE\")]\n    pub output: Option\u003cPathBuf\u003e,\n\n    /// Include full details in report\n    #[arg(long)]\n    pub detailed: bool,\n}\n\n/// Output format for plan command\n#[derive(Debug, Clone, PartialEq, Eq, clap::ValueEnum)]\npub enum OutputFormat {\n    Terminal,\n    Json,\n    Sarif,\n}\n\n/// Output format for report command\n#[derive(Debug, Clone, PartialEq, Eq, clap::ValueEnum)]\npub enum ReportFormat {\n    Html,\n    Markdown,\n    Json,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","commands","plan.rs"],"content":"//! Plan command - Analyze repository and show planned actions\n//!\n//! This module implements the `plan` command which analyzes a repository\n//! and generates an action plan to fix detected issues.\n\nuse std::path::PathBuf;\n\nuse super::{OutputFormat, PlanArgs};\nuse crate::actions::planner::ActionPlanner;\nuse crate::cli::output::{JsonOutput, OutputRenderer, SarifOutput, TerminalOutput};\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::exit_codes;\nuse crate::rules::engine::RulesEngine;\nuse crate::scanner::Scanner;\n\n/// Execute the plan command\n///\n/// Analyzes the repository, runs audit rules, generates an action plan,\n/// and outputs the results in the requested format.\n///\n/// # Arguments\n///\n/// * `args` - Command line arguments for the plan command\n///\n/// # Returns\n///\n/// An exit code: 0 for success, 1 for critical issues, 2 for warnings\n///\n/// # Errors\n///\n/// Returns an error if the audit or plan generation fails\npub async fn execute(args: PlanArgs) -\u003e Result\u003ci32, RepoLensError\u003e {\n    // Load configuration\n    let config = Config::load_or_default()?;\n\n    // Initialize scanner\n    let scanner = Scanner::new(PathBuf::from(\".\"));\n\n    // Run the rules engine\n    let mut engine = RulesEngine::new(config.clone());\n\n    // Apply filters if specified\n    if let Some(only) = \u0026args.only {\n        engine.set_only_categories(only.clone());\n    }\n    if let Some(skip) = \u0026args.skip {\n        engine.set_skip_categories(skip.clone());\n    }\n\n    // Execute audit\n    let audit_results = engine.run(\u0026scanner).await?;\n\n    // Generate action plan\n    let planner = ActionPlanner::new(config);\n    let action_plan = planner.create_plan(\u0026audit_results);\n\n    // Render output\n    let output: Box\u003cdyn OutputRenderer\u003e = match args.format {\n        OutputFormat::Terminal =\u003e Box::new(TerminalOutput::new()),\n        OutputFormat::Json =\u003e Box::new(JsonOutput::new()),\n        OutputFormat::Sarif =\u003e Box::new(SarifOutput::new()),\n    };\n\n    let rendered = output.render_plan(\u0026audit_results, \u0026action_plan)?;\n\n    // Write output\n    if let Some(output_path) = args.output {\n        std::fs::write(\u0026output_path, \u0026rendered).map_err(|e| {\n            RepoLensError::Action(crate::error::ActionError::FileWrite {\n                path: output_path.display().to_string(),\n                source: e,\n            })\n        })?;\n        eprintln!(\"Plan written to: {}\", output_path.display());\n    } else {\n        println!(\"{rendered}\");\n    }\n\n    // Determine exit code based on findings\n    let exit_code = if audit_results.has_critical() {\n        exit_codes::CRITICAL_ISSUES\n    } else if audit_results.has_warnings() {\n        exit_codes::WARNINGS\n    } else {\n        exit_codes::SUCCESS\n    };\n\n    Ok(exit_code)\n}\n","traces":[{"line":33,"address":[591118,591304,594972,594387,591056,592360],"length":1,"stats":{"Line":0}},{"line":35,"address":[592321,591297,591422],"length":1,"stats":{"Line":0}},{"line":38,"address":[591736,591657],"length":1,"stats":{"Line":0}},{"line":41,"address":[641587,641510],"length":1,"stats":{"Line":0}},{"line":44,"address":[591873],"length":1,"stats":{"Line":0}},{"line":45,"address":[641853,641689],"length":1,"stats":{"Line":0}},{"line":47,"address":[592123,591990],"length":1,"stats":{"Line":0}},{"line":48,"address":[592229,592131],"length":1,"stats":{"Line":0}},{"line":52,"address":[592386,591334,592176,592254,595198],"length":1,"stats":{"Line":0}},{"line":55,"address":[592947],"length":1,"stats":{"Line":0}},{"line":56,"address":[593088],"length":1,"stats":{"Line":0}},{"line":59,"address":[593132,593278],"length":1,"stats":{"Line":0}},{"line":60,"address":[642918,642982],"length":1,"stats":{"Line":0}},{"line":61,"address":[593358,593181],"length":1,"stats":{"Line":0}},{"line":62,"address":[593191,593400],"length":1,"stats":{"Line":0}},{"line":65,"address":[593310,595126,593501],"length":1,"stats":{"Line":0}},{"line":68,"address":[593713],"length":1,"stats":{"Line":0}},{"line":69,"address":[593933,595696,593826,594039,595950,595944],"length":1,"stats":{"Line":0}},{"line":70,"address":[595869],"length":1,"stats":{"Line":0}},{"line":71,"address":[595796,595723],"length":1,"stats":{"Line":0}},{"line":72,"address":[645608],"length":1,"stats":{"Line":0}},{"line":75,"address":[594080],"length":1,"stats":{"Line":0}},{"line":77,"address":[643582,644137],"length":1,"stats":{"Line":0}},{"line":81,"address":[594317,594507,594471],"length":1,"stats":{"Line":0}},{"line":82,"address":[594496],"length":1,"stats":{"Line":0}},{"line":83,"address":[594530,594485,594513],"length":1,"stats":{"Line":0}},{"line":84,"address":[594532],"length":1,"stats":{"Line":0}},{"line":86,"address":[594519],"length":1,"stats":{"Line":0}},{"line":89,"address":[594543],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","commands","report.rs"],"content":"//! Report command - Generate an audit report\n\nuse colored::Colorize;\nuse std::path::PathBuf;\n\nuse super::{ReportArgs, ReportFormat};\nuse crate::cli::output::{HtmlReport, JsonOutput, MarkdownReport, ReportRenderer};\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::exit_codes;\nuse crate::rules::engine::RulesEngine;\nuse crate::scanner::Scanner;\n\npub async fn execute(args: ReportArgs) -\u003e Result\u003ci32, RepoLensError\u003e {\n    // Load configuration\n    let config = Config::load_or_default()?;\n\n    // Initialize scanner\n    let scanner = Scanner::new(PathBuf::from(\".\"));\n\n    // Run the rules engine\n    let engine = RulesEngine::new(config);\n    let audit_results = engine.run(\u0026scanner).await?;\n\n    // Generate report\n    let renderer: Box\u003cdyn ReportRenderer\u003e = match args.format {\n        ReportFormat::Html =\u003e Box::new(HtmlReport::new(args.detailed)),\n        ReportFormat::Markdown =\u003e Box::new(MarkdownReport::new(args.detailed)),\n        ReportFormat::Json =\u003e Box::new(JsonOutput::new()),\n    };\n\n    let report = renderer.render_report(\u0026audit_results)?;\n\n    // Write output\n    let output_path = args.output.unwrap_or_else(|| {\n        let extension = match args.format {\n            ReportFormat::Html =\u003e \"html\",\n            ReportFormat::Markdown =\u003e \"md\",\n            ReportFormat::Json =\u003e \"json\",\n        };\n        PathBuf::from(format!(\"repolens-report.{extension}\"))\n    });\n\n    std::fs::write(\u0026output_path, \u0026report).map_err(|e| {\n        RepoLensError::Action(crate::error::ActionError::FileWrite {\n            path: output_path.display().to_string(),\n            source: e,\n        })\n    })?;\n\n    println!(\n        \"{} Report written to: {}\",\n        \"Success:\".green().bold(),\n        output_path.display().to_string().cyan()\n    );\n\n    // Return exit code based on findings\n    let exit_code = if audit_results.has_critical() {\n        exit_codes::CRITICAL_ISSUES\n    } else if audit_results.has_warnings() {\n        exit_codes::WARNINGS\n    } else {\n        exit_codes::SUCCESS\n    };\n\n    Ok(exit_code)\n}\n","traces":[{"line":14,"address":[1319056,1319059],"length":1,"stats":{"Line":0}},{"line":16,"address":[35564,35693,36297],"length":1,"stats":{"Line":0}},{"line":19,"address":[35915,35994],"length":1,"stats":{"Line":0}},{"line":22,"address":[36021],"length":1,"stats":{"Line":0}},{"line":23,"address":[35601,38832,36366,36230,36139],"length":1,"stats":{"Line":0}},{"line":26,"address":[36927,37115],"length":1,"stats":{"Line":0}},{"line":27,"address":[36966,37069],"length":1,"stats":{"Line":0}},{"line":28,"address":[37194,36989],"length":1,"stats":{"Line":0}},{"line":29,"address":[37015,37242],"length":1,"stats":{"Line":0}},{"line":32,"address":[37343,37147,38796],"length":1,"stats":{"Line":0}},{"line":35,"address":[39008,37523],"length":1,"stats":{"Line":0}},{"line":36,"address":[39030],"length":1,"stats":{"Line":0}},{"line":37,"address":[69627],"length":1,"stats":{"Line":0}},{"line":38,"address":[39090],"length":1,"stats":{"Line":0}},{"line":39,"address":[39113],"length":1,"stats":{"Line":0}},{"line":41,"address":[39134],"length":1,"stats":{"Line":0}},{"line":44,"address":[39534,37852,37672,39280,37746,39528],"length":1,"stats":{"Line":0}},{"line":45,"address":[39453],"length":1,"stats":{"Line":0}},{"line":46,"address":[69940,69867],"length":1,"stats":{"Line":0}},{"line":47,"address":[39448],"length":1,"stats":{"Line":0}},{"line":51,"address":[68700,68503,68773],"length":1,"stats":{"Line":0}},{"line":58,"address":[38431,38482],"length":1,"stats":{"Line":0}},{"line":59,"address":[38471],"length":1,"stats":{"Line":0}},{"line":60,"address":[38505,38488,38460],"length":1,"stats":{"Line":0}},{"line":61,"address":[38507],"length":1,"stats":{"Line":0}},{"line":63,"address":[38494],"length":1,"stats":{"Line":0}},{"line":66,"address":[38518],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","mod.rs"],"content":"//! CLI module - Command line interface definition and handlers\n\npub mod commands;\npub mod output;\n\nuse clap::{Parser, Subcommand};\nuse std::path::PathBuf;\n\nuse commands::{ApplyArgs, InitArgs, PlanArgs, ReportArgs};\n\n/// RepoLens - Audit and prepare repositories for open source or enterprise standards\n#[derive(Parser, Debug)]\n#[command(name = \"repolens\")]\n#[command(author, version, about, long_about = None)]\n#[command(propagate_version = true)]\npub struct Cli {\n    /// Increase verbosity level (-v, -vv, -vvv)\n    #[arg(short, long, action = clap::ArgAction::Count, global = true)]\n    pub verbose: u8,\n\n    /// Path to configuration file\n    #[arg(short, long, global = true, value_name = \"FILE\")]\n    pub config: Option\u003cPathBuf\u003e,\n\n    /// Working directory (defaults to current directory)\n    #[arg(short = 'C', long, global = true, value_name = \"DIR\")]\n    pub directory: Option\u003cPathBuf\u003e,\n\n    #[command(subcommand)]\n    pub command: Commands,\n}\n\n#[derive(Subcommand, Debug)]\npub enum Commands {\n    /// Initialize a new configuration file\n    Init(InitArgs),\n\n    /// Analyze repository and show planned actions\n    Plan(PlanArgs),\n\n    /// Apply planned changes to the repository\n    Apply(ApplyArgs),\n\n    /// Generate an audit report\n    Report(ReportArgs),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","html.rs"],"content":"//! HTML report output\n\nuse crate::error::RepoLensError;\nuse chrono::Utc;\n\nuse super::ReportRenderer;\nuse crate::rules::results::{AuditResults, Severity};\n\npub struct HtmlReport {\n    detailed: bool,\n}\n\nimpl HtmlReport {\n    pub fn new(detailed: bool) -\u003e Self {\n        Self { detailed }\n    }\n}\n\nimpl ReportRenderer for HtmlReport {\n    fn render_report(\u0026self, results: \u0026AuditResults) -\u003e Result\u003cString, RepoLensError\u003e {\n        let critical_count = results.count_by_severity(Severity::Critical);\n        let warning_count = results.count_by_severity(Severity::Warning);\n        let info_count = results.count_by_severity(Severity::Info);\n\n        let status_color = if critical_count \u003e 0 {\n            \"#dc3545\"\n        } else if warning_count \u003e 0 {\n            \"#ffc107\"\n        } else {\n            \"#28a745\"\n        };\n\n        let mut findings_html = String::new();\n\n        // Critical findings\n        for finding in results.findings_by_severity(Severity::Critical) {\n            findings_html.push_str(\u0026format!(\n                r#\"\u003cdiv class=\"finding critical\"\u003e\n                    \u003cdiv class=\"finding-header\"\u003e\n                        \u003cspan class=\"badge critical\"\u003eCRITICAL\u003c/span\u003e\n                        \u003cspan class=\"rule-id\"\u003e{}\u003c/span\u003e\n                    \u003c/div\u003e\n                    \u003cdiv class=\"finding-message\"\u003e{}\u003c/div\u003e\n                    {}\n                    {}\n                \u003c/div\u003e\"#,\n                finding.rule_id,\n                finding.message,\n                finding.location.as_ref().map_or(String::new(), |l| {\n                    format!(r#\"\u003cdiv class=\"finding-location\"\u003eLocation: \u003ccode\u003e{}\u003c/code\u003e\u003c/div\u003e\"#, l)\n                }),\n                if self.detailed {\n                    format!(\n                        \"{}{}\",\n                        finding.description.as_ref().map_or(String::new(), |d| {\n                            format!(r#\"\u003cdiv class=\"finding-description\"\u003e{}\u003c/div\u003e\"#, d)\n                        }),\n                        finding.remediation.as_ref().map_or(String::new(), |r| {\n                            format!(r#\"\u003cdiv class=\"finding-remediation\"\u003e\u003cstrong\u003eRemediation:\u003c/strong\u003e {}\u003c/div\u003e\"#, r)\n                        })\n                    )\n                } else {\n                    String::new()\n                }\n            ));\n        }\n\n        // Warning findings\n        for finding in results.findings_by_severity(Severity::Warning) {\n            findings_html.push_str(\u0026format!(\n                r#\"\u003cdiv class=\"finding warning\"\u003e\n                    \u003cdiv class=\"finding-header\"\u003e\n                        \u003cspan class=\"badge warning\"\u003eWARNING\u003c/span\u003e\n                        \u003cspan class=\"rule-id\"\u003e{}\u003c/span\u003e\n                    \u003c/div\u003e\n                    \u003cdiv class=\"finding-message\"\u003e{}\u003c/div\u003e\n                    {}\n                \u003c/div\u003e\"#,\n                finding.rule_id,\n                finding.message,\n                finding.location.as_ref().map_or(String::new(), |l| {\n                    format!(\n                        r#\"\u003cdiv class=\"finding-location\"\u003eLocation: \u003ccode\u003e{}\u003c/code\u003e\u003c/div\u003e\"#,\n                        l\n                    )\n                })\n            ));\n        }\n\n        // Info findings\n        if self.detailed {\n            for finding in results.findings_by_severity(Severity::Info) {\n                findings_html.push_str(\u0026format!(\n                    r#\"\u003cdiv class=\"finding info\"\u003e\n                        \u003cdiv class=\"finding-header\"\u003e\n                            \u003cspan class=\"badge info\"\u003eINFO\u003c/span\u003e\n                            \u003cspan class=\"rule-id\"\u003e{}\u003c/span\u003e\n                        \u003c/div\u003e\n                        \u003cdiv class=\"finding-message\"\u003e{}\u003c/div\u003e\n                    \u003c/div\u003e\"#,\n                    finding.rule_id, finding.message\n                ));\n            }\n        }\n\n        let html = format!(\n            r#\"\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eRepoLens Audit Report - {}\u003c/title\u003e\n    \u003cstyle\u003e\n        :root {{\n            --critical: #dc3545;\n            --warning: #ffc107;\n            --info: #17a2b8;\n            --success: #28a745;\n        }}\n        * {{ box-sizing: border-box; margin: 0; padding: 0; }}\n        body {{\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n            line-height: 1.6;\n            color: #333;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 2rem;\n            background: #f8f9fa;\n        }}\n        header {{\n            background: white;\n            padding: 2rem;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n            margin-bottom: 2rem;\n        }}\n        h1 {{ color: #333; margin-bottom: 1rem; }}\n        .meta {{ color: #666; font-size: 0.9rem; }}\n        .summary {{\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));\n            gap: 1rem;\n            margin: 2rem 0;\n        }}\n        .stat {{\n            background: white;\n            padding: 1.5rem;\n            border-radius: 8px;\n            text-align: center;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }}\n        .stat-value {{ font-size: 2rem; font-weight: bold; }}\n        .stat-label {{ color: #666; font-size: 0.9rem; }}\n        .stat.critical .stat-value {{ color: var(--critical); }}\n        .stat.warning .stat-value {{ color: var(--warning); }}\n        .stat.info .stat-value {{ color: var(--info); }}\n        .status-indicator {{\n            display: inline-block;\n            width: 12px;\n            height: 12px;\n            border-radius: 50%;\n            margin-right: 8px;\n        }}\n        .findings {{ margin-top: 2rem; }}\n        .finding {{\n            background: white;\n            padding: 1.5rem;\n            border-radius: 8px;\n            margin-bottom: 1rem;\n            border-left: 4px solid;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }}\n        .finding.critical {{ border-color: var(--critical); }}\n        .finding.warning {{ border-color: var(--warning); }}\n        .finding.info {{ border-color: var(--info); }}\n        .finding-header {{ display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem; }}\n        .badge {{\n            padding: 0.25rem 0.5rem;\n            border-radius: 4px;\n            font-size: 0.75rem;\n            font-weight: bold;\n            color: white;\n        }}\n        .badge.critical {{ background: var(--critical); }}\n        .badge.warning {{ background: var(--warning); color: #333; }}\n        .badge.info {{ background: var(--info); }}\n        .rule-id {{ color: #666; font-family: monospace; }}\n        .finding-message {{ font-weight: 500; }}\n        .finding-location {{ margin-top: 0.5rem; color: #666; font-size: 0.9rem; }}\n        .finding-location code {{ background: #f1f1f1; padding: 0.2rem 0.4rem; border-radius: 4px; }}\n        .finding-description {{ margin-top: 0.5rem; color: #555; }}\n        .finding-remediation {{ margin-top: 0.5rem; color: #28a745; }}\n        footer {{\n            margin-top: 3rem;\n            text-align: center;\n            color: #666;\n            font-size: 0.9rem;\n        }}\n        footer a {{ color: #007bff; text-decoration: none; }}\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003cheader\u003e\n        \u003ch1\u003e\n            \u003cspan class=\"status-indicator\" style=\"background: {}\"\u003e\u003c/span\u003e\n            RepoLens Audit Report\n        \u003c/h1\u003e\n        \u003cdiv class=\"meta\"\u003e\n            \u003cp\u003e\u003cstrong\u003eRepository:\u003c/strong\u003e {}\u003c/p\u003e\n            \u003cp\u003e\u003cstrong\u003ePreset:\u003c/strong\u003e {}\u003c/p\u003e\n            \u003cp\u003e\u003cstrong\u003eGenerated:\u003c/strong\u003e {}\u003c/p\u003e\n            \u003cp\u003e\u003cstrong\u003eVersion:\u003c/strong\u003e {}\u003c/p\u003e\n        \u003c/div\u003e\n    \u003c/header\u003e\n\n    \u003csection class=\"summary\"\u003e\n        \u003cdiv class=\"stat critical\"\u003e\n            \u003cdiv class=\"stat-value\"\u003e{}\u003c/div\u003e\n            \u003cdiv class=\"stat-label\"\u003eCritical\u003c/div\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"stat warning\"\u003e\n            \u003cdiv class=\"stat-value\"\u003e{}\u003c/div\u003e\n            \u003cdiv class=\"stat-label\"\u003eWarnings\u003c/div\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"stat info\"\u003e\n            \u003cdiv class=\"stat-value\"\u003e{}\u003c/div\u003e\n            \u003cdiv class=\"stat-label\"\u003eInfo\u003c/div\u003e\n        \u003c/div\u003e\n    \u003c/section\u003e\n\n    \u003csection class=\"findings\"\u003e\n        \u003ch2\u003eFindings\u003c/h2\u003e\n        {}\n    \u003c/section\u003e\n\n    \u003cfooter\u003e\n        \u003cp\u003eReport generated by \u003ca href=\"https://github.com/kdelfour/repolens\"\u003eRepoLens\u003c/a\u003e\u003c/p\u003e\n    \u003c/footer\u003e\n\u003c/body\u003e\n\u003c/html\u003e\"#,\n            results.repository_name,\n            status_color,\n            results.repository_name,\n            results.preset,\n            Utc::now().format(\"%Y-%m-%d %H:%M:%S UTC\"),\n            env!(\"CARGO_PKG_VERSION\"),\n            critical_count,\n            warning_count,\n            info_count,\n            findings_html\n        );\n\n        Ok(html)\n    }\n}\n","traces":[{"line":14,"address":[586992],"length":1,"stats":{"Line":0}},{"line":20,"address":[587008,588785,590805],"length":1,"stats":{"Line":0}},{"line":21,"address":[587074],"length":1,"stats":{"Line":0}},{"line":22,"address":[587111],"length":1,"stats":{"Line":0}},{"line":23,"address":[587148],"length":1,"stats":{"Line":0}},{"line":25,"address":[587228,587177],"length":1,"stats":{"Line":0}},{"line":26,"address":[587201],"length":1,"stats":{"Line":0}},{"line":27,"address":[587188,587286,587257],"length":1,"stats":{"Line":0}},{"line":28,"address":[587259],"length":1,"stats":{"Line":0}},{"line":30,"address":[587230],"length":1,"stats":{"Line":0}},{"line":33,"address":[587326],"length":1,"stats":{"Line":0}},{"line":36,"address":[587430,587339],"length":1,"stats":{"Line":0}},{"line":37,"address":[589657,587576,590776,589783,590342,589566],"length":1,"stats":{"Line":0}},{"line":49,"address":[300624],"length":1,"stats":{"Line":0}},{"line":50,"address":[300645],"length":1,"stats":{"Line":0}},{"line":52,"address":[589736],"length":1,"stats":{"Line":0}},{"line":53,"address":[589995,589856],"length":1,"stats":{"Line":0}},{"line":55,"address":[589761,589821],"length":1,"stats":{"Line":0}},{"line":56,"address":[300773],"length":1,"stats":{"Line":0}},{"line":58,"address":[589932],"length":1,"stats":{"Line":0}},{"line":59,"address":[300901],"length":1,"stats":{"Line":0}},{"line":63,"address":[97333,97301],"length":1,"stats":{"Line":0}},{"line":69,"address":[95158],"length":1,"stats":{"Line":0}},{"line":70,"address":[96699,97084,95345,96608],"length":1,"stats":{"Line":0}},{"line":81,"address":[627680],"length":1,"stats":{"Line":0}},{"line":82,"address":[301029],"length":1,"stats":{"Line":0}},{"line":91,"address":[587823],"length":1,"stats":{"Line":0}},{"line":92,"address":[587866],"length":1,"stats":{"Line":0}},{"line":93,"address":[589022,588796,588057],"length":1,"stats":{"Line":0}},{"line":106,"address":[587836,588079,588234],"length":1,"stats":{"Line":0}},{"line":245,"address":[588164],"length":1,"stats":{"Line":0}},{"line":253,"address":[588712],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","json.rs"],"content":"//! JSON output formatting\n\nuse crate::error::RepoLensError;\nuse serde::Serialize;\n\nuse super::{OutputRenderer, ReportRenderer};\nuse crate::actions::plan::ActionPlan;\nuse crate::rules::results::AuditResults;\n\npub struct JsonOutput;\n\nimpl JsonOutput {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\nimpl Default for JsonOutput {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[derive(Serialize)]\nstruct PlanOutput\u003c'a\u003e {\n    version: \u0026'static str,\n    repository: \u0026'a str,\n    preset: \u0026'a str,\n    audit: AuditSummary\u003c'a\u003e,\n    actions: Vec\u003cActionSummary\u003c'a\u003e\u003e,\n}\n\n#[derive(Serialize)]\nstruct AuditSummary\u003c'a\u003e {\n    critical_count: usize,\n    warning_count: usize,\n    info_count: usize,\n    findings: \u0026'a [crate::rules::results::Finding],\n}\n\n#[derive(Serialize)]\nstruct ActionSummary\u003c'a\u003e {\n    category: \u0026'a str,\n    description: \u0026'a str,\n    details: \u0026'a [String],\n}\n\nimpl OutputRenderer for JsonOutput {\n    fn render_plan(\n        \u0026self,\n        results: \u0026AuditResults,\n        plan: \u0026ActionPlan,\n    ) -\u003e Result\u003cString, RepoLensError\u003e {\n        let output = PlanOutput {\n            version: env!(\"CARGO_PKG_VERSION\"),\n            repository: \u0026results.repository_name,\n            preset: \u0026results.preset,\n            audit: AuditSummary {\n                critical_count: results\n                    .count_by_severity(crate::rules::results::Severity::Critical),\n                warning_count: results.count_by_severity(crate::rules::results::Severity::Warning),\n                info_count: results.count_by_severity(crate::rules::results::Severity::Info),\n                findings: results.findings(),\n            },\n            actions: plan\n                .actions()\n                .iter()\n                .map(|a| ActionSummary {\n                    category: a.category(),\n                    description: a.description(),\n                    details: a.details(),\n                })\n                .collect(),\n        };\n\n        Ok(serde_json::to_string_pretty(\u0026output)?)\n    }\n}\n\nimpl ReportRenderer for JsonOutput {\n    fn render_report(\u0026self, results: \u0026AuditResults) -\u003e Result\u003cString, RepoLensError\u003e {\n        Ok(serde_json::to_string_pretty(results)?)\n    }\n}\n","traces":[{"line":19,"address":[893600],"length":1,"stats":{"Line":0}},{"line":20,"address":[893601],"length":1,"stats":{"Line":0}},{"line":49,"address":[894396,894390,893616],"length":1,"stats":{"Line":0}},{"line":56,"address":[893675],"length":1,"stats":{"Line":0}},{"line":57,"address":[893695],"length":1,"stats":{"Line":0}},{"line":58,"address":[893837],"length":1,"stats":{"Line":0}},{"line":65,"address":[893877],"length":1,"stats":{"Line":0}},{"line":76,"address":[894083,894143],"length":1,"stats":{"Line":0}},{"line":81,"address":[894416],"length":1,"stats":{"Line":0}},{"line":82,"address":[894451],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","markdown.rs"],"content":"//! Markdown report output\n\nuse crate::error::RepoLensError;\nuse chrono::Utc;\n\nuse super::ReportRenderer;\nuse crate::rules::results::{AuditResults, Severity};\n\npub struct MarkdownReport {\n    detailed: bool,\n}\n\nimpl MarkdownReport {\n    pub fn new(detailed: bool) -\u003e Self {\n        Self { detailed }\n    }\n}\n\nimpl ReportRenderer for MarkdownReport {\n    fn render_report(\u0026self, results: \u0026AuditResults) -\u003e Result\u003cString, RepoLensError\u003e {\n        let mut output = String::new();\n\n        // Header\n        output.push_str(\u0026format!(\n            \"# RepoLens Audit Report\\n\\n\\\n             **Repository:** {}\\n\\\n             **Preset:** {}\\n\\\n             **Generated:** {}\\n\\\n             **RepoLens Version:** {}\\n\\n\",\n            results.repository_name,\n            results.preset,\n            Utc::now().format(\"%Y-%m-%d %H:%M:%S UTC\"),\n            env!(\"CARGO_PKG_VERSION\")\n        ));\n\n        // Summary\n        output.push_str(\"## Summary\\n\\n\");\n        output.push_str(\"| Severity | Count |\\n\");\n        output.push_str(\"|----------|-------|\\n\");\n        output.push_str(\u0026format!(\n            \"| Critical | {} |\\n\",\n            results.count_by_severity(Severity::Critical)\n        ));\n        output.push_str(\u0026format!(\n            \"| Warning | {} |\\n\",\n            results.count_by_severity(Severity::Warning)\n        ));\n        output.push_str(\u0026format!(\n            \"| Info | {} |\\n\\n\",\n            results.count_by_severity(Severity::Info)\n        ));\n\n        // Critical findings\n        let critical: Vec\u003c_\u003e = results.findings_by_severity(Severity::Critical).collect();\n        if !critical.is_empty() {\n            output.push_str(\"## Critical Issues\\n\\n\");\n            output.push_str(\"These issues must be resolved before proceeding.\\n\\n\");\n            for finding in critical {\n                output.push_str(\u0026format!(\n                    \"### {} - {}\\n\\n\",\n                    finding.rule_id, finding.message\n                ));\n                if let Some(location) = \u0026finding.location {\n                    output.push_str(\u0026format!(\"**Location:** `{}`\\n\\n\", location));\n                }\n                if self.detailed {\n                    if let Some(description) = \u0026finding.description {\n                        output.push_str(\u0026format!(\"{}\\n\\n\", description));\n                    }\n                    if let Some(remediation) = \u0026finding.remediation {\n                        output.push_str(\u0026format!(\"**Remediation:** {}\\n\\n\", remediation));\n                    }\n                }\n            }\n        }\n\n        // Warning findings\n        let warnings: Vec\u003c_\u003e = results.findings_by_severity(Severity::Warning).collect();\n        if !warnings.is_empty() {\n            output.push_str(\"## Warnings\\n\\n\");\n            output.push_str(\"These issues should be addressed.\\n\\n\");\n            for finding in warnings {\n                output.push_str(\u0026format!(\n                    \"### {} - {}\\n\\n\",\n                    finding.rule_id, finding.message\n                ));\n                if let Some(location) = \u0026finding.location {\n                    output.push_str(\u0026format!(\"**Location:** `{}`\\n\\n\", location));\n                }\n                if self.detailed {\n                    if let Some(description) = \u0026finding.description {\n                        output.push_str(\u0026format!(\"{}\\n\\n\", description));\n                    }\n                    if let Some(remediation) = \u0026finding.remediation {\n                        output.push_str(\u0026format!(\"**Remediation:** {}\\n\\n\", remediation));\n                    }\n                }\n            }\n        }\n\n        // Info findings\n        let info: Vec\u003c_\u003e = results.findings_by_severity(Severity::Info).collect();\n        if !info.is_empty() \u0026\u0026 self.detailed {\n            output.push_str(\"## Informational\\n\\n\");\n            output.push_str(\"These are suggestions for improvement.\\n\\n\");\n            for finding in info {\n                output.push_str(\u0026format!(\"- **{}**: {}\\n\", finding.rule_id, finding.message));\n            }\n            output.push('\\n');\n        }\n\n        // Footer\n        output.push_str(\"---\\n\\n\");\n        output.push_str(\"*Report generated by [RepoLens](https://github.com/kdelfour/repolens)*\\n\");\n\n        Ok(output)\n    }\n}\n","traces":[{"line":14,"address":[106336],"length":1,"stats":{"Line":0}},{"line":20,"address":[106352,109187,112657],"length":1,"stats":{"Line":0}},{"line":21,"address":[106407],"length":1,"stats":{"Line":0}},{"line":24,"address":[106468,106629,106998,106536],"length":1,"stats":{"Line":0}},{"line":32,"address":[106559],"length":1,"stats":{"Line":0}},{"line":37,"address":[107024],"length":1,"stats":{"Line":0}},{"line":38,"address":[107051],"length":1,"stats":{"Line":0}},{"line":39,"address":[107078],"length":1,"stats":{"Line":0}},{"line":40,"address":[107160,107386],"length":1,"stats":{"Line":0}},{"line":42,"address":[107113],"length":1,"stats":{"Line":0}},{"line":44,"address":[107693,107467],"length":1,"stats":{"Line":0}},{"line":46,"address":[107420],"length":1,"stats":{"Line":0}},{"line":48,"address":[107774,108000],"length":1,"stats":{"Line":0}},{"line":50,"address":[107727],"length":1,"stats":{"Line":0}},{"line":54,"address":[108034],"length":1,"stats":{"Line":0}},{"line":55,"address":[108166,108104],"length":1,"stats":{"Line":0}},{"line":56,"address":[108172],"length":1,"stats":{"Line":0}},{"line":57,"address":[108241],"length":1,"stats":{"Line":0}},{"line":58,"address":[108268,108466],"length":1,"stats":{"Line":0}},{"line":59,"address":[1449518,1449473,1449756],"length":1,"stats":{"Line":0}},{"line":63,"address":[108846],"length":1,"stats":{"Line":0}},{"line":64,"address":[1449903,1449854],"length":1,"stats":{"Line":0}},{"line":66,"address":[108945],"length":1,"stats":{"Line":0}},{"line":67,"address":[1450145],"length":1,"stats":{"Line":0}},{"line":68,"address":[109265,109357],"length":1,"stats":{"Line":0}},{"line":70,"address":[1450244,1450537],"length":1,"stats":{"Line":0}},{"line":71,"address":[109601],"length":1,"stats":{"Line":0}},{"line":78,"address":[108207,109872],"length":1,"stats":{"Line":0}},{"line":79,"address":[109957,109895],"length":1,"stats":{"Line":0}},{"line":80,"address":[109963],"length":1,"stats":{"Line":0}},{"line":81,"address":[1450976],"length":1,"stats":{"Line":0}},{"line":82,"address":[110257,110059],"length":1,"stats":{"Line":0}},{"line":83,"address":[110365,110320,110591],"length":1,"stats":{"Line":0}},{"line":87,"address":[110625],"length":1,"stats":{"Line":0}},{"line":88,"address":[1451627,1451676],"length":1,"stats":{"Line":0}},{"line":90,"address":[110718],"length":1,"stats":{"Line":0}},{"line":91,"address":[1451900],"length":1,"stats":{"Line":0}},{"line":92,"address":[111103,111014],"length":1,"stats":{"Line":0}},{"line":94,"address":[1451993,1452268],"length":1,"stats":{"Line":0}},{"line":95,"address":[111332],"length":1,"stats":{"Line":0}},{"line":102,"address":[111591,109998],"length":1,"stats":{"Line":0}},{"line":103,"address":[111670,111614],"length":1,"stats":{"Line":0}},{"line":104,"address":[1452663],"length":1,"stats":{"Line":0}},{"line":105,"address":[111746],"length":1,"stats":{"Line":0}},{"line":106,"address":[111965,111773],"length":1,"stats":{"Line":0}},{"line":107,"address":[112025,112089],"length":1,"stats":{"Line":0}},{"line":109,"address":[112072],"length":1,"stats":{"Line":0}},{"line":113,"address":[111689],"length":1,"stats":{"Line":0}},{"line":114,"address":[112342],"length":1,"stats":{"Line":0}},{"line":116,"address":[112377],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":50},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","mod.rs"],"content":"//! Output formatting module for CLI\n\nmod html;\nmod json;\nmod markdown;\nmod sarif;\nmod terminal;\n\npub use html::HtmlReport;\npub use json::JsonOutput;\npub use markdown::MarkdownReport;\npub use sarif::SarifOutput;\npub use terminal::TerminalOutput;\n\nuse crate::actions::plan::ActionPlan;\nuse crate::error::RepoLensError;\nuse crate::rules::results::AuditResults;\n\n/// Trait for rendering plan output\npub trait OutputRenderer {\n    fn render_plan(\n        \u0026self,\n        results: \u0026AuditResults,\n        plan: \u0026ActionPlan,\n    ) -\u003e Result\u003cString, RepoLensError\u003e;\n}\n\n/// Trait for rendering report output\npub trait ReportRenderer {\n    fn render_report(\u0026self, results: \u0026AuditResults) -\u003e Result\u003cString, RepoLensError\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","sarif.rs"],"content":"//! SARIF output formatting for GitHub Code Scanning integration\n\nuse crate::error::RepoLensError;\nuse serde::Serialize;\n\nuse super::OutputRenderer;\nuse crate::actions::plan::ActionPlan;\nuse crate::rules::results::{AuditResults, Finding, Severity};\n\npub struct SarifOutput;\n\nimpl SarifOutput {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\nimpl Default for SarifOutput {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[derive(Serialize)]\nstruct SarifReport {\n    #[serde(rename = \"$schema\")]\n    schema: \u0026'static str,\n    version: \u0026'static str,\n    runs: Vec\u003cSarifRun\u003e,\n}\n\n#[derive(Serialize)]\nstruct SarifRun {\n    tool: SarifTool,\n    results: Vec\u003cSarifResult\u003e,\n}\n\n#[derive(Serialize)]\nstruct SarifTool {\n    driver: SarifDriver,\n}\n\n#[derive(Serialize)]\nstruct SarifDriver {\n    name: \u0026'static str,\n    version: \u0026'static str,\n    #[serde(rename = \"informationUri\")]\n    information_uri: \u0026'static str,\n    rules: Vec\u003cSarifRule\u003e,\n}\n\n#[derive(Serialize)]\nstruct SarifRule {\n    id: String,\n    name: String,\n    #[serde(rename = \"shortDescription\")]\n    short_description: SarifMessage,\n    #[serde(rename = \"defaultConfiguration\")]\n    default_configuration: SarifDefaultConfig,\n}\n\n#[derive(Serialize)]\nstruct SarifDefaultConfig {\n    level: String,\n}\n\n#[derive(Serialize)]\nstruct SarifResult {\n    #[serde(rename = \"ruleId\")]\n    rule_id: String,\n    level: String,\n    message: SarifMessage,\n    locations: Vec\u003cSarifLocation\u003e,\n}\n\n#[derive(Serialize)]\nstruct SarifMessage {\n    text: String,\n}\n\n#[derive(Serialize)]\nstruct SarifLocation {\n    #[serde(rename = \"physicalLocation\")]\n    physical_location: SarifPhysicalLocation,\n}\n\n#[derive(Serialize)]\nstruct SarifPhysicalLocation {\n    #[serde(rename = \"artifactLocation\")]\n    artifact_location: SarifArtifactLocation,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    region: Option\u003cSarifRegion\u003e,\n}\n\n#[derive(Serialize)]\nstruct SarifArtifactLocation {\n    uri: String,\n}\n\n#[derive(Serialize)]\nstruct SarifRegion {\n    #[serde(rename = \"startLine\")]\n    start_line: u32,\n    #[serde(rename = \"startColumn\", skip_serializing_if = \"Option::is_none\")]\n    start_column: Option\u003cu32\u003e,\n}\n\nimpl SarifOutput {\n    fn severity_to_level(severity: Severity) -\u003e \u0026'static str {\n        match severity {\n            Severity::Critical =\u003e \"error\",\n            Severity::Warning =\u003e \"warning\",\n            Severity::Info =\u003e \"note\",\n        }\n    }\n\n    fn finding_to_result(finding: \u0026Finding) -\u003e SarifResult {\n        let (uri, region) = if let Some(location) = \u0026finding.location {\n            // Parse location like \"src/config.ts:42\"\n            let parts: Vec\u003c\u0026str\u003e = location.split(':').collect();\n            let uri = parts.first().unwrap_or(\u0026\"unknown\").to_string();\n            let region = parts.get(1).and_then(|line| {\n                line.parse::\u003cu32\u003e().ok().map(|l| SarifRegion {\n                    start_line: l,\n                    start_column: None,\n                })\n            });\n            (uri, region)\n        } else {\n            (\"unknown\".to_string(), None)\n        };\n\n        SarifResult {\n            rule_id: finding.rule_id.clone(),\n            level: Self::severity_to_level(finding.severity).to_string(),\n            message: SarifMessage {\n                text: finding.message.clone(),\n            },\n            locations: vec![SarifLocation {\n                physical_location: SarifPhysicalLocation {\n                    artifact_location: SarifArtifactLocation { uri },\n                    region,\n                },\n            }],\n        }\n    }\n}\n\nimpl OutputRenderer for SarifOutput {\n    fn render_plan(\n        \u0026self,\n        results: \u0026AuditResults,\n        _plan: \u0026ActionPlan,\n    ) -\u003e Result\u003cString, RepoLensError\u003e {\n        let rules: Vec\u003cSarifRule\u003e = results\n            .findings()\n            .iter()\n            .map(|f| SarifRule {\n                id: f.rule_id.clone(),\n                name: f.rule_id.clone(),\n                short_description: SarifMessage {\n                    text: f.message.clone(),\n                },\n                default_configuration: SarifDefaultConfig {\n                    level: Self::severity_to_level(f.severity).to_string(),\n                },\n            })\n            .collect();\n\n        let results_sarif: Vec\u003cSarifResult\u003e = results\n            .findings()\n            .iter()\n            .map(Self::finding_to_result)\n            .collect();\n\n        let report = SarifReport {\n            schema: \"https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json\",\n            version: \"2.1.0\",\n            runs: vec![SarifRun {\n                tool: SarifTool {\n                    driver: SarifDriver {\n                        name: \"repolens\",\n                        version: env!(\"CARGO_PKG_VERSION\"),\n                        information_uri: \"https://github.com/kdelfour/repolens\",\n                        rules,\n                    },\n                },\n                results: results_sarif,\n            }],\n        };\n\n        Ok(serde_json::to_string_pretty(\u0026report)?)\n    }\n}\n","traces":[{"line":19,"address":[646336],"length":1,"stats":{"Line":0}},{"line":20,"address":[776577],"length":1,"stats":{"Line":0}},{"line":109,"address":[776592],"length":1,"stats":{"Line":0}},{"line":110,"address":[776599],"length":1,"stats":{"Line":0}},{"line":111,"address":[646390],"length":1,"stats":{"Line":0}},{"line":112,"address":[776653],"length":1,"stats":{"Line":0}},{"line":113,"address":[776676],"length":1,"stats":{"Line":0}},{"line":117,"address":[776720,777501,777495],"length":1,"stats":{"Line":0}},{"line":118,"address":[777406,776750,777022],"length":1,"stats":{"Line":0}},{"line":120,"address":[776816],"length":1,"stats":{"Line":0}},{"line":121,"address":[777081,776883],"length":1,"stats":{"Line":0}},{"line":122,"address":[1294352],"length":1,"stats":{"Line":0}},{"line":123,"address":[1294370,1294448,1294463],"length":1,"stats":{"Line":0}},{"line":125,"address":[1294455],"length":1,"stats":{"Line":0}},{"line":128,"address":[777261],"length":1,"stats":{"Line":0}},{"line":130,"address":[776907],"length":1,"stats":{"Line":0}},{"line":134,"address":[647236],"length":1,"stats":{"Line":0}},{"line":135,"address":[777557,777631],"length":1,"stats":{"Line":0}},{"line":136,"address":[647479],"length":1,"stats":{"Line":0}},{"line":139,"address":[647521,647751],"length":1,"stats":{"Line":0}},{"line":150,"address":[779620,779626,778352],"length":1,"stats":{"Line":0}},{"line":155,"address":[648166],"length":1,"stats":{"Line":0}},{"line":158,"address":[1294968,1294974,1294480,1294844],"length":1,"stats":{"Line":0}},{"line":159,"address":[1294526],"length":1,"stats":{"Line":0}},{"line":160,"address":[1294560],"length":1,"stats":{"Line":0}},{"line":161,"address":[1294676],"length":1,"stats":{"Line":0}},{"line":162,"address":[1294610],"length":1,"stats":{"Line":0}},{"line":164,"address":[1294796],"length":1,"stats":{"Line":0}},{"line":165,"address":[1294702,1294767],"length":1,"stats":{"Line":0}},{"line":170,"address":[778475,778543],"length":1,"stats":{"Line":0}},{"line":179,"address":[778627,778928],"length":1,"stats":{"Line":0}},{"line":192,"address":[779332,779269],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","cli","output","terminal.rs"],"content":"//! Terminal output formatting with colors\n\nuse crate::error::RepoLensError;\nuse colored::Colorize;\n\nuse super::{OutputRenderer, ReportRenderer};\nuse crate::actions::plan::ActionPlan;\nuse crate::rules::results::{AuditResults, Finding, Severity};\n\npub struct TerminalOutput;\n\nimpl TerminalOutput {\n    pub fn new() -\u003e Self {\n        Self\n    }\n\n    fn format_header(\u0026self, repo_name: \u0026str, preset: \u0026str) -\u003e String {\n        format!(\n            r#\"\n{} v{}\n\n{} {}\n{} {}\n\"#,\n            \"repolens\".cyan().bold(),\n            env!(\"CARGO_PKG_VERSION\"),\n            \"Repository:\".dimmed(),\n            repo_name.white().bold(),\n            \"Preset:\".dimmed(),\n            preset.yellow()\n        )\n    }\n\n    fn format_findings(\u0026self, results: \u0026AuditResults) -\u003e String {\n        let mut output = String::new();\n\n        output.push_str(\u0026format!(\n            \"\\n{}\\n{}\\n\\n\",\n            \"‚îÅ\".repeat(50).dimmed(),\n            \"  AUDIT RESULTS\".bold()\n        ));\n\n        // Critical findings\n        let critical: Vec\u003c_\u003e = results.findings_by_severity(Severity::Critical).collect();\n        if !critical.is_empty() {\n            output.push_str(\u0026format!(\n                \"{} ({})\\\\n\",\n                \"‚ùå CRITICAL\".red().bold(),\n                critical.len()\n            ));\n            for finding in critical {\n                output.push_str(\u0026self.format_finding(finding));\n            }\n            output.push('\\n');\n        }\n\n        // Warning findings\n        let warnings: Vec\u003c_\u003e = results.findings_by_severity(Severity::Warning).collect();\n        if !warnings.is_empty() {\n            output.push_str(\u0026format!(\n                \"{} ({})\\\\n\",\n                \"‚ö†Ô∏è  WARNING\".yellow().bold(),\n                warnings.len()\n            ));\n            for finding in warnings {\n                output.push_str(\u0026self.format_finding(finding));\n            }\n            output.push('\\n');\n        }\n\n        // Info findings\n        let info: Vec\u003c_\u003e = results.findings_by_severity(Severity::Info).collect();\n        if !info.is_empty() {\n            output.push_str(\u0026format!(\"{} ({})\\\\n\", \"‚ÑπÔ∏è  INFO\".blue().bold(), info.len()));\n            for finding in info {\n                output.push_str(\u0026self.format_finding(finding));\n            }\n            output.push('\\n');\n        }\n\n        output\n    }\n\n    fn format_finding(\u0026self, finding: \u0026Finding) -\u003e String {\n        let mut output = format!(\n            \"  {} [{}] {}\\n\",\n            \"‚Ä¢\".dimmed(),\n            finding.rule_id.cyan(),\n            finding.message\n        );\n\n        if let Some(location) = \u0026finding.location {\n            output.push_str(\u0026format!(\"    {} {}\\n\", \"‚îî‚îÄ\".dimmed(), location.dimmed()));\n        }\n\n        output\n    }\n\n    fn format_actions(\u0026self, plan: \u0026ActionPlan) -\u003e String {\n        let mut output = String::new();\n\n        output.push_str(\u0026format!(\n            \"\\n{}\\n{}\\n\\n\",\n            \"‚îÅ\".repeat(50).dimmed(),\n            \"  PLANNED ACTIONS\".bold()\n        ));\n\n        if plan.is_empty() {\n            output.push_str(\u0026format!(\"  {}\\n\", \"No actions required.\".green()));\n            return output;\n        }\n\n        output.push_str(\"The following changes will be applied:\\n\\n\");\n\n        for action in plan.actions() {\n            output.push_str(\u0026format!(\n                \"  {} [{}] {}\\n\",\n                \"+\".green(),\n                action.category().cyan(),\n                action.description()\n            ));\n\n            for detail in action.details() {\n                output.push_str(\u0026format!(\"      {} {}\\n\", \"‚îî‚îÄ\".dimmed(), detail.dimmed()));\n            }\n        }\n\n        output\n    }\n\n    fn format_summary(\u0026self, results: \u0026AuditResults) -\u003e String {\n        let mut output = String::new();\n\n        output.push_str(\u0026format!(\n            \"\\n{}\\n{}\\n\\n\",\n            \"‚îÅ\".repeat(50).dimmed(),\n            \"  SUMMARY\".bold()\n        ));\n\n        let critical_count = results.count_by_severity(Severity::Critical);\n        let warning_count = results.count_by_severity(Severity::Warning);\n        let info_count = results.count_by_severity(Severity::Info);\n\n        output.push_str(\u0026format!(\n            \"Critical: {} ‚îÇ Warnings: {} ‚îÇ Info: {}\\n\",\n            critical_count.to_string().red().bold(),\n            warning_count.to_string().yellow().bold(),\n            info_count.to_string().blue().bold()\n        ));\n\n        if critical_count \u003e 0 {\n            output.push_str(\u0026format!(\n                \"\\n{} {} critical issue(s) must be fixed manually.\\n\",\n                \"‚ö†Ô∏è \".yellow(),\n                critical_count\n            ));\n        }\n\n        output.push_str(\u0026format!(\n            \"\\nRun '{}' to execute planned actions.\\n\",\n            \"repolens apply\".cyan()\n        ));\n\n        output\n    }\n}\n\nimpl Default for TerminalOutput {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl OutputRenderer for TerminalOutput {\n    fn render_plan(\n        \u0026self,\n        results: \u0026AuditResults,\n        plan: \u0026ActionPlan,\n    ) -\u003e Result\u003cString, RepoLensError\u003e {\n        let mut output = String::new();\n\n        output.push_str(\u0026self.format_header(\u0026results.repository_name, \u0026results.preset));\n        output.push_str(\u0026self.format_findings(results));\n        output.push_str(\u0026self.format_actions(plan));\n        output.push_str(\u0026self.format_summary(results));\n\n        Ok(output)\n    }\n}\n\nimpl ReportRenderer for TerminalOutput {\n    fn render_report(\u0026self, results: \u0026AuditResults) -\u003e Result\u003cString, RepoLensError\u003e {\n        let mut output = String::new();\n\n        output.push_str(\u0026self.format_header(\u0026results.repository_name, \u0026results.preset));\n        output.push_str(\u0026self.format_findings(results));\n        output.push_str(\u0026self.format_summary(results));\n\n        Ok(output)\n    }\n}\n","traces":[{"line":17,"address":[196306,195200,196312],"length":1,"stats":{"Line":0}},{"line":18,"address":[848830,849246,848924,849048,849150],"length":1,"stats":{"Line":0}},{"line":25,"address":[195276],"length":1,"stats":{"Line":0}},{"line":27,"address":[195405],"length":1,"stats":{"Line":0}},{"line":28,"address":[195514],"length":1,"stats":{"Line":0}},{"line":29,"address":[195631],"length":1,"stats":{"Line":0}},{"line":30,"address":[195739],"length":1,"stats":{"Line":0}},{"line":34,"address":[200773,198404,196336],"length":1,"stats":{"Line":0}},{"line":35,"address":[196391],"length":1,"stats":{"Line":0}},{"line":37,"address":[196723,196624,196548,197221],"length":1,"stats":{"Line":0}},{"line":39,"address":[196605,196444,196525],"length":1,"stats":{"Line":0}},{"line":40,"address":[196692],"length":1,"stats":{"Line":0}},{"line":44,"address":[197255],"length":1,"stats":{"Line":0}},{"line":45,"address":[197325,197387],"length":1,"stats":{"Line":0}},{"line":46,"address":[197603,197940,197493],"length":1,"stats":{"Line":0}},{"line":48,"address":[850954,850881],"length":1,"stats":{"Line":0}},{"line":49,"address":[197572],"length":1,"stats":{"Line":0}},{"line":51,"address":[198164,197966],"length":1,"stats":{"Line":0}},{"line":52,"address":[198290,198235],"length":1,"stats":{"Line":0}},{"line":54,"address":[851758],"length":1,"stats":{"Line":0}},{"line":58,"address":[198426,197432],"length":1,"stats":{"Line":0}},{"line":59,"address":[198505,198449],"length":1,"stats":{"Line":0}},{"line":60,"address":[198715,198611,199040],"length":1,"stats":{"Line":0}},{"line":62,"address":[198584,198511],"length":1,"stats":{"Line":0}},{"line":63,"address":[198690],"length":1,"stats":{"Line":0}},{"line":65,"address":[852554,852746],"length":1,"stats":{"Line":0}},{"line":66,"address":[852872,852817],"length":1,"stats":{"Line":0}},{"line":68,"address":[199364],"length":1,"stats":{"Line":0}},{"line":72,"address":[852038,852996],"length":1,"stats":{"Line":0}},{"line":73,"address":[199531,199587],"length":1,"stats":{"Line":0}},{"line":74,"address":[199593,199694],"length":1,"stats":{"Line":0}},{"line":75,"address":[200368,200176],"length":1,"stats":{"Line":0}},{"line":76,"address":[200494,200439],"length":1,"stats":{"Line":0}},{"line":78,"address":[853962],"length":1,"stats":{"Line":0}},{"line":81,"address":[199632],"length":1,"stats":{"Line":0}},{"line":84,"address":[200816,202143,202149],"length":1,"stats":{"Line":0}},{"line":85,"address":[200893,201007],"length":1,"stats":{"Line":0}},{"line":87,"address":[854342],"length":1,"stats":{"Line":0}},{"line":88,"address":[200961],"length":1,"stats":{"Line":0}},{"line":92,"address":[201397],"length":1,"stats":{"Line":0}},{"line":93,"address":[201455,201571],"length":1,"stats":{"Line":0}},{"line":96,"address":[201496],"length":1,"stats":{"Line":0}},{"line":99,"address":[202176,204896,205327],"length":1,"stats":{"Line":0}},{"line":100,"address":[855719],"length":1,"stats":{"Line":0}},{"line":102,"address":[855831,856006,856504,855907],"length":1,"stats":{"Line":0}},{"line":104,"address":[855808,855888,855724],"length":1,"stats":{"Line":0}},{"line":105,"address":[855975],"length":1,"stats":{"Line":0}},{"line":108,"address":[203050],"length":1,"stats":{"Line":0}},{"line":109,"address":[203104,204902],"length":1,"stats":{"Line":0}},{"line":110,"address":[205287],"length":1,"stats":{"Line":0}},{"line":113,"address":[856565],"length":1,"stats":{"Line":0}},{"line":115,"address":[203146],"length":1,"stats":{"Line":0}},{"line":116,"address":[203561,203424,204084,203683],"length":1,"stats":{"Line":0}},{"line":118,"address":[203334],"length":1,"stats":{"Line":0}},{"line":119,"address":[203503],"length":1,"stats":{"Line":0}},{"line":120,"address":[203640],"length":1,"stats":{"Line":0}},{"line":123,"address":[857606],"length":1,"stats":{"Line":0}},{"line":124,"address":[204285],"length":1,"stats":{"Line":0}},{"line":128,"address":[203373],"length":1,"stats":{"Line":0}},{"line":131,"address":[208591,208597,205344],"length":1,"stats":{"Line":0}},{"line":132,"address":[205399],"length":1,"stats":{"Line":0}},{"line":134,"address":[205511,205587,206178,205686],"length":1,"stats":{"Line":0}},{"line":136,"address":[205404,205488,205568],"length":1,"stats":{"Line":0}},{"line":137,"address":[205655],"length":1,"stats":{"Line":0}},{"line":140,"address":[859700],"length":1,"stats":{"Line":0}},{"line":141,"address":[859749],"length":1,"stats":{"Line":0}},{"line":142,"address":[859798],"length":1,"stats":{"Line":0}},{"line":144,"address":[206626,206403,206943,206723,207628,206846,206503],"length":1,"stats":{"Line":0}},{"line":146,"address":[206351,206457],"length":1,"stats":{"Line":0}},{"line":147,"address":[206574,206677],"length":1,"stats":{"Line":0}},{"line":148,"address":[860385,860282],"length":1,"stats":{"Line":0}},{"line":151,"address":[861142],"length":1,"stats":{"Line":0}},{"line":152,"address":[208126,207730],"length":1,"stats":{"Line":0}},{"line":154,"address":[207699],"length":1,"stats":{"Line":0}},{"line":159,"address":[861994,861643],"length":1,"stats":{"Line":0}},{"line":161,"address":[207665],"length":1,"stats":{"Line":0}},{"line":164,"address":[208548],"length":1,"stats":{"Line":0}},{"line":169,"address":[208624],"length":1,"stats":{"Line":0}},{"line":170,"address":[862113],"length":1,"stats":{"Line":0}},{"line":175,"address":[209530,209536,208640],"length":1,"stats":{"Line":0}},{"line":180,"address":[208710],"length":1,"stats":{"Line":0}},{"line":182,"address":[208824,208723],"length":1,"stats":{"Line":0}},{"line":183,"address":[209019],"length":1,"stats":{"Line":0}},{"line":184,"address":[209157],"length":1,"stats":{"Line":0}},{"line":185,"address":[862786],"length":1,"stats":{"Line":0}},{"line":187,"address":[209431],"length":1,"stats":{"Line":0}},{"line":192,"address":[210256,210262,209552],"length":1,"stats":{"Line":0}},{"line":193,"address":[209603],"length":1,"stats":{"Line":0}},{"line":195,"address":[209699,209613],"length":1,"stats":{"Line":0}},{"line":196,"address":[209891],"length":1,"stats":{"Line":0}},{"line":197,"address":[210029],"length":1,"stats":{"Line":0}},{"line":199,"address":[210157],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":92},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","config","loader.rs"],"content":"//! Configuration loader\n\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\nuse crate::error::{ConfigError, RepoLensError};\n\nuse super::presets::Preset;\nuse super::{ActionsConfig, CustomRulesConfig, RuleConfig, SecretsConfig, TemplatesConfig, UrlConfig};\n\nconst CONFIG_FILENAME: \u0026str = \".repolens.toml\";\n\n/// Main configuration structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Config {\n    /// Preset name (opensource, enterprise, strict)\n    #[serde(default = \"default_preset\")]\n    pub preset: String,\n\n    /// Rule overrides\n    #[serde(default)]\n    pub rules: HashMap\u003cString, RuleConfig\u003e,\n\n    /// Secrets detection configuration\n    #[serde(default)]\n    #[serde(rename = \"rules.secrets\")]\n    pub secrets: SecretsConfig,\n\n    /// URL detection configuration\n    #[serde(default)]\n    #[serde(rename = \"rules.urls\")]\n    pub urls: UrlConfig,\n\n    /// Actions configuration\n    #[serde(default)]\n    pub actions: ActionsConfig,\n\n    /// Template configuration\n    #[serde(default)]\n    pub templates: TemplatesConfig,\n\n    /// Custom rules configuration\n    #[serde(default)]\n    #[serde(rename = \"rules.custom\")]\n    pub custom_rules: CustomRulesConfig,\n}\n\nfn default_preset() -\u003e String {\n    \"opensource\".to_string()\n}\n\nimpl Default for Config {\n    fn default() -\u003e Self {\n        Self {\n            preset: \"opensource\".to_string(),\n            rules: HashMap::new(),\n            secrets: SecretsConfig::default(),\n            urls: UrlConfig::default(),\n            actions: ActionsConfig::default(),\n            templates: TemplatesConfig::default(),\n            custom_rules: CustomRulesConfig::default(),\n        }\n    }\n}\n\nimpl Config {\n    /// Load configuration from file or return default\n    pub fn load_or_default() -\u003e Result\u003cSelf, RepoLensError\u003e {\n        let config_path = Path::new(CONFIG_FILENAME);\n\n        if config_path.exists() {\n            Self::load_from_file(config_path)\n        } else {\n            Ok(Self::default())\n        }\n    }\n\n    /// Load configuration from a specific file\n    pub fn load_from_file(path: \u0026Path) -\u003e Result\u003cSelf, RepoLensError\u003e {\n        let content = fs::read_to_string(path).map_err(|e| {\n            RepoLensError::Config(ConfigError::FileRead {\n                path: path.display().to_string(),\n                source: e,\n            })\n        })?;\n\n        toml::from_str(\u0026content).map_err(Into::into)\n    }\n\n    /// Create a new configuration from a preset\n    pub fn from_preset(preset: Preset) -\u003e Self {\n        let mut config = Self {\n            preset: preset.name().to_string(),\n            ..Default::default()\n        };\n\n        // Apply preset-specific defaults\n        match preset {\n            Preset::OpenSource =\u003e {\n                config.actions.license.enabled = true;\n                config.actions.contributing = true;\n                config.actions.code_of_conduct = true;\n                config.actions.security_policy = true;\n                config.actions.github_settings.discussions = true;\n            }\n            Preset::Enterprise =\u003e {\n                config.actions.license.enabled = false;\n                config.actions.contributing = false;\n                config.actions.code_of_conduct = false;\n                config.actions.security_policy = true;\n                config.actions.branch_protection.required_approvals = 2;\n                config.actions.branch_protection.require_signed_commits = true;\n                config.actions.github_settings.discussions = false;\n            }\n            Preset::Strict =\u003e {\n                config.actions.license.enabled = true;\n                config.actions.contributing = true;\n                config.actions.code_of_conduct = true;\n                config.actions.security_policy = true;\n                config.actions.branch_protection.required_approvals = 2;\n                config.actions.branch_protection.require_signed_commits = true;\n                config.actions.github_settings.discussions = true;\n            }\n        }\n\n        config\n    }\n\n    /// Serialize configuration to TOML\n    pub fn to_toml(\u0026self) -\u003e Result\u003cString, RepoLensError\u003e {\n        toml::to_string_pretty(self).map_err(Into::into)\n    }\n\n    /// Check if a rule is enabled\n    pub fn is_rule_enabled(\u0026self, rule_id: \u0026str) -\u003e bool {\n        self.rules.get(rule_id).map(|r| r.enabled).unwrap_or(true)\n    }\n\n    /// Get severity override for a rule\n    #[allow(dead_code)]\n    pub fn get_rule_severity(\u0026self, rule_id: \u0026str) -\u003e Option\u003c\u0026str\u003e {\n        self.rules.get(rule_id).and_then(|r| r.severity.as_deref())\n    }\n\n    /// Check if a file should be ignored for secrets scanning\n    pub fn should_ignore_file(\u0026self, file_path: \u0026str) -\u003e bool {\n        self.secrets\n            .ignore_files\n            .iter()\n            .any(|pattern| glob_match(pattern, file_path))\n    }\n\n    /// Check if a pattern should be ignored for secrets scanning\n    pub fn should_ignore_pattern(\u0026self, path: \u0026str) -\u003e bool {\n        self.secrets\n            .ignore_patterns\n            .iter()\n            .any(|pattern| glob_match(pattern, path))\n    }\n\n    /// Check if a URL is allowed (for enterprise mode)\n    #[allow(dead_code)]\n    pub fn is_url_allowed(\u0026self, url: \u0026str) -\u003e bool {\n        if self.urls.allowed_internal.is_empty() {\n            return false;\n        }\n\n        self.urls\n            .allowed_internal\n            .iter()\n            .any(|pattern| glob_match(pattern, url))\n    }\n}\n\n/// Simple glob matching (supports * and **)\npub fn glob_match(pattern: \u0026str, text: \u0026str) -\u003e bool {\n    if pattern.contains(\"**\") {\n        return glob_match_double_star(pattern, text);\n    }\n\n    if pattern.contains('*') {\n        return glob_match_single_star(pattern, text);\n    }\n\n    text == pattern\n}\n\n/// Match pattern with double star (**)\nfn glob_match_double_star(pattern: \u0026str, text: \u0026str) -\u003e bool {\n    let parts: Vec\u003c\u0026str\u003e = pattern.split(\"**\").collect();\n\n    // Handle patterns like \"**/test/**\" which split into ['', '/test/', '']\n    if parts.len() == 3 \u0026\u0026 parts[0].is_empty() \u0026\u0026 parts[2].is_empty() {\n        // Pattern is **something**, check if text contains something\n        let middle = parts[1].trim_matches('/');\n        return text.contains(\u0026format!(\"/{}\", middle)) || text.starts_with(middle);\n    }\n\n    if parts.len() != 2 {\n        return false;\n    }\n\n    let prefix = parts[0].trim_end_matches('/');\n    let suffix_raw = parts[1];\n    let suffix = suffix_raw.trim_start_matches('/');\n\n    if !prefix.is_empty() \u0026\u0026 !text.starts_with(prefix) {\n        return false;\n    }\n\n    if suffix.is_empty() {\n        // Pattern like \"**\" or \"prefix/**\" matches everything\n        return true;\n    }\n\n    // Handle patterns like *.test.ts\n    if suffix.starts_with('*') {\n        let suffix_pattern = suffix.trim_start_matches('*');\n        return text.ends_with(suffix_pattern);\n    }\n\n    // For patterns like \"**/test/**\" or \"**/test\", check if suffix appears anywhere\n    if prefix.is_empty() {\n        // Pattern starts with **, check if suffix appears anywhere\n        // For \"**/test/**\", suffix_raw is \"/test/\", suffix is \"test/\"\n        // We need to check if the path contains \"/test/\" anywhere\n        // Since suffix_raw had a leading slash, check for \"/suffix\" pattern\n        if suffix_raw.starts_with('/') {\n            // Check for \"/suffix\" in the path (e.g., \"/test/\" in \"src/test/file.ts\")\n            // suffix is \"test/\" so we check for \"/test/\"\n            // Also handle case where path starts with \"test/\"\n            let pattern_to_find = format!(\"/{}\", suffix);\n            if text.contains(\u0026pattern_to_find) {\n                return true;\n            }\n            // Also check if text starts with suffix (for paths like \"test/file.ts\")\n            if text.starts_with(suffix) {\n                return true;\n            }\n            return false;\n        }\n        // No leading slash in original, check for suffix anywhere\n        return text.contains(suffix);\n    }\n\n    // Pattern has both prefix and suffix\n    // Check if text starts with prefix and contains suffix after prefix\n    if let Some(after_prefix) = text.strip_prefix(prefix) {\n        return after_prefix.contains(suffix) || after_prefix.ends_with(suffix);\n    }\n\n    // Fallback: check ends or contains\n    text.ends_with(suffix) || text.contains(suffix)\n}\n\n/// Match pattern with single star (*)\nfn glob_match_single_star(pattern: \u0026str, text: \u0026str) -\u003e bool {\n    let parts: Vec\u003c\u0026str\u003e = pattern.split('*').collect();\n    let mut pos = 0;\n\n    for (i, part) in parts.iter().enumerate() {\n        if part.is_empty() {\n            continue;\n        }\n\n        if let Some(found_pos) = text[pos..].find(part) {\n            if i == 0 \u0026\u0026 found_pos != 0 {\n                return false;\n            }\n            pos += found_pos + part.len();\n        } else {\n            return false;\n        }\n    }\n\n    if let Some(last_part) = parts.last() {\n        if !last_part.is_empty() {\n            return text.ends_with(last_part);\n        }\n    }\n\n    true\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_glob_match() {\n        assert!(glob_match(\"*.ts\", \"file.ts\"));\n        assert!(glob_match(\"*.ts\", \"path/to/file.ts\"));\n        assert!(!glob_match(\"*.ts\", \"file.js\"));\n\n        // For \"**/test/**\", we check if path contains \"/test/\" anywhere\n        // For \"**/test/**\", check if path contains \"/test/\" anywhere\n        // \"src/test/file.ts\" contains \"/test/\" so it should match\n        assert!(\n            glob_match(\"**/test/**\", \"src/test/file.ts\"),\n            \"Pattern **/test/** should match src/test/file.ts\"\n        );\n        assert!(glob_match(\"**/test/**\", \"test/file.ts\"));\n        assert!(glob_match(\"**/*.test.ts\", \"src/file.test.ts\"));\n    }\n\n    #[test]\n    fn test_default_config() {\n        let config = Config::default();\n        assert_eq!(config.preset, \"opensource\");\n        assert!(config.actions.gitignore);\n    }\n\n    #[test]\n    fn test_from_preset() {\n        let config = Config::from_preset(Preset::Enterprise);\n        assert_eq!(config.preset, \"enterprise\");\n        assert!(!config.actions.license.enabled);\n        assert_eq!(config.actions.branch_protection.required_approvals, 2);\n    }\n\n    #[test]\n    fn test_custom_rules_config_parsing() {\n        let toml_content = r#\"\npreset = \"opensource\"\n\n[\"rules.custom\".\"no-todo\"]\npattern = \"TODO\"\nseverity = \"warning\"\nfiles = [\"**/*.rs\"]\nmessage = \"TODO comment found\"\n\"#;\n        let config: Config = toml::from_str(toml_content).unwrap();\n        assert!(config.custom_rules.rules.contains_key(\"no-todo\"));\n        let rule = config.custom_rules.rules.get(\"no-todo\").unwrap();\n        assert_eq!(rule.pattern, \"TODO\");\n        assert_eq!(rule.severity, \"warning\");\n    }\n}\n","traces":[{"line":45,"address":[612736],"length":1,"stats":{"Line":0}},{"line":46,"address":[226824],"length":1,"stats":{"Line":0}},{"line":50,"address":[613241,612768,613247],"length":1,"stats":{"Line":18}},{"line":52,"address":[612784],"length":1,"stats":{"Line":14}},{"line":53,"address":[612815],"length":1,"stats":{"Line":13}},{"line":54,"address":[612868],"length":1,"stats":{"Line":14}},{"line":55,"address":[612917],"length":1,"stats":{"Line":13}},{"line":56,"address":[612966],"length":1,"stats":{"Line":15}},{"line":57,"address":[613018],"length":1,"stats":{"Line":15}},{"line":64,"address":[613264],"length":1,"stats":{"Line":0}},{"line":65,"address":[613280],"length":1,"stats":{"Line":0}},{"line":67,"address":[613330,613368],"length":1,"stats":{"Line":0}},{"line":68,"address":[613384],"length":1,"stats":{"Line":0}},{"line":70,"address":[613339],"length":1,"stats":{"Line":0}},{"line":75,"address":[613408,613770,613764],"length":1,"stats":{"Line":0}},{"line":76,"address":[227640,227531],"length":1,"stats":{"Line":0}},{"line":77,"address":[494379],"length":1,"stats":{"Line":0}},{"line":78,"address":[494256,494334],"length":1,"stats":{"Line":0}},{"line":79,"address":[494374],"length":1,"stats":{"Line":0}},{"line":83,"address":[613642,613713],"length":1,"stats":{"Line":0}},{"line":87,"address":[228669,228663,227872],"length":1,"stats":{"Line":2}},{"line":89,"address":[613821],"length":1,"stats":{"Line":2}},{"line":94,"address":[614356],"length":1,"stats":{"Line":2}},{"line":95,"address":[614428],"length":1,"stats":{"Line":0}},{"line":96,"address":[228468],"length":1,"stats":{"Line":0}},{"line":97,"address":[614396],"length":1,"stats":{"Line":0}},{"line":98,"address":[614404],"length":1,"stats":{"Line":0}},{"line":99,"address":[614412],"length":1,"stats":{"Line":0}},{"line":100,"address":[614420],"length":1,"stats":{"Line":0}},{"line":102,"address":[614489],"length":1,"stats":{"Line":2}},{"line":103,"address":[614430],"length":1,"stats":{"Line":2}},{"line":104,"address":[228518],"length":1,"stats":{"Line":2}},{"line":105,"address":[614446],"length":1,"stats":{"Line":2}},{"line":106,"address":[228534],"length":1,"stats":{"Line":2}},{"line":107,"address":[614462],"length":1,"stats":{"Line":2}},{"line":108,"address":[614473],"length":1,"stats":{"Line":2}},{"line":109,"address":[614481],"length":1,"stats":{"Line":2}},{"line":112,"address":[614491],"length":1,"stats":{"Line":0}},{"line":113,"address":[614499],"length":1,"stats":{"Line":0}},{"line":114,"address":[614507],"length":1,"stats":{"Line":0}},{"line":115,"address":[614515],"length":1,"stats":{"Line":0}},{"line":116,"address":[614523],"length":1,"stats":{"Line":0}},{"line":117,"address":[228614],"length":1,"stats":{"Line":0}},{"line":118,"address":[614542],"length":1,"stats":{"Line":0}},{"line":122,"address":[614555],"length":1,"stats":{"Line":2}},{"line":126,"address":[614608],"length":1,"stats":{"Line":0}},{"line":127,"address":[614626],"length":1,"stats":{"Line":0}},{"line":131,"address":[614672],"length":1,"stats":{"Line":4}},{"line":132,"address":[494496,494501],"length":1,"stats":{"Line":3}},{"line":137,"address":[614736],"length":1,"stats":{"Line":0}},{"line":138,"address":[494521,494512],"length":1,"stats":{"Line":0}},{"line":142,"address":[614784],"length":1,"stats":{"Line":2}},{"line":143,"address":[614812],"length":1,"stats":{"Line":2}},{"line":146,"address":[494544,494576],"length":1,"stats":{"Line":4}},{"line":150,"address":[614880],"length":1,"stats":{"Line":3}},{"line":151,"address":[614908],"length":1,"stats":{"Line":4}},{"line":154,"address":[494624,494656],"length":1,"stats":{"Line":0}},{"line":159,"address":[614976],"length":1,"stats":{"Line":0}},{"line":160,"address":[615009],"length":1,"stats":{"Line":0}},{"line":161,"address":[615093],"length":1,"stats":{"Line":0}},{"line":164,"address":[229107],"length":1,"stats":{"Line":0}},{"line":167,"address":[296224,296256],"length":1,"stats":{"Line":0}},{"line":172,"address":[615120],"length":1,"stats":{"Line":2}},{"line":173,"address":[615143],"length":1,"stats":{"Line":2}},{"line":174,"address":[229280],"length":1,"stats":{"Line":2}},{"line":177,"address":[229254],"length":1,"stats":{"Line":2}},{"line":178,"address":[615254],"length":1,"stats":{"Line":2}},{"line":181,"address":[229312],"length":1,"stats":{"Line":2}},{"line":185,"address":[615296,616171,617633],"length":1,"stats":{"Line":2}},{"line":186,"address":[229440],"length":1,"stats":{"Line":2}},{"line":189,"address":[229668,229515,229586],"length":1,"stats":{"Line":6}},{"line":191,"address":[229786],"length":1,"stats":{"Line":2}},{"line":192,"address":[616161,615816],"length":1,"stats":{"Line":4}},{"line":195,"address":[230269,229630],"length":1,"stats":{"Line":4}},{"line":196,"address":[230313],"length":1,"stats":{"Line":0}},{"line":199,"address":[616247,616191],"length":1,"stats":{"Line":4}},{"line":200,"address":[616334],"length":1,"stats":{"Line":2}},{"line":201,"address":[230503],"length":1,"stats":{"Line":2}},{"line":203,"address":[230556,230649],"length":1,"stats":{"Line":2}},{"line":204,"address":[230655],"length":1,"stats":{"Line":0}},{"line":207,"address":[230672,230618],"length":1,"stats":{"Line":4}},{"line":209,"address":[616630],"length":1,"stats":{"Line":0}},{"line":213,"address":[616647,616594],"length":1,"stats":{"Line":4}},{"line":214,"address":[230758,231668],"length":1,"stats":{"Line":4}},{"line":215,"address":[231684],"length":1,"stats":{"Line":2}},{"line":219,"address":[616663,616719],"length":1,"stats":{"Line":0}},{"line":224,"address":[617179,616782],"length":1,"stats":{"Line":0}},{"line":228,"address":[617232,617277],"length":1,"stats":{"Line":0}},{"line":229,"address":[617401,617460],"length":1,"stats":{"Line":0}},{"line":230,"address":[231597],"length":1,"stats":{"Line":0}},{"line":233,"address":[617482,617527],"length":1,"stats":{"Line":0}},{"line":239,"address":[617263,617201],"length":1,"stats":{"Line":0}},{"line":244,"address":[616751,616815],"length":1,"stats":{"Line":0}},{"line":245,"address":[616904,616986],"length":1,"stats":{"Line":0}},{"line":249,"address":[616951,617068],"length":1,"stats":{"Line":0}},{"line":253,"address":[618765,618771,617648],"length":1,"stats":{"Line":2}},{"line":254,"address":[617712],"length":1,"stats":{"Line":2}},{"line":255,"address":[231879],"length":1,"stats":{"Line":2}},{"line":257,"address":[618742,617882,617795],"length":1,"stats":{"Line":6}},{"line":258,"address":[618159,618434],"length":1,"stats":{"Line":4}},{"line":262,"address":[618460],"length":1,"stats":{"Line":2}},{"line":263,"address":[232690,232716],"length":1,"stats":{"Line":2}},{"line":264,"address":[618650],"length":1,"stats":{"Line":0}},{"line":266,"address":[618673,618631,618747],"length":1,"stats":{"Line":4}},{"line":268,"address":[618602],"length":1,"stats":{"Line":2}},{"line":272,"address":[618183],"length":1,"stats":{"Line":2}},{"line":273,"address":[618345,618299],"length":1,"stats":{"Line":4}},{"line":274,"address":[618372],"length":1,"stats":{"Line":2}},{"line":278,"address":[618317],"length":1,"stats":{"Line":0}}],"covered":58,"coverable":109},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","config","mod.rs"],"content":"//! Configuration module\n\npub mod loader;\npub mod presets;\n\npub use loader::Config;\npub use presets::Preset;\n\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n/// Rule configuration\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct RuleConfig {\n    /// Whether the rule is enabled\n    #[serde(default = \"default_true\")]\n    pub enabled: bool,\n\n    /// Severity override (critical, warning, info)\n    pub severity: Option\u003cString\u003e,\n}\n\nfn default_true() -\u003e bool {\n    true\n}\n\n/// Secrets configuration\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct SecretsConfig {\n    /// Patterns to ignore when scanning for secrets\n    #[serde(default)]\n    pub ignore_patterns: Vec\u003cString\u003e,\n\n    /// Files to ignore when scanning for secrets\n    #[serde(default)]\n    pub ignore_files: Vec\u003cString\u003e,\n\n    /// Custom secret patterns to detect\n    #[serde(default)]\n    pub custom_patterns: Vec\u003cString\u003e,\n}\n\n/// URL configuration\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct UrlConfig {\n    /// Allowed internal URLs (for enterprise mode)\n    #[serde(default)]\n    pub allowed_internal: Vec\u003cString\u003e,\n}\n\n/// Actions configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ActionsConfig {\n    /// Whether to update .gitignore\n    #[serde(default = \"default_true\")]\n    pub gitignore: bool,\n\n    /// License configuration\n    #[serde(default)]\n    pub license: LicenseConfig,\n\n    /// Whether to create CONTRIBUTING.md\n    #[serde(default = \"default_true\")]\n    pub contributing: bool,\n\n    /// Whether to create CODE_OF_CONDUCT.md\n    #[serde(default = \"default_true\")]\n    pub code_of_conduct: bool,\n\n    /// Whether to create SECURITY.md\n    #[serde(default = \"default_true\")]\n    pub security_policy: bool,\n\n    /// Branch protection configuration\n    #[serde(default)]\n    pub branch_protection: BranchProtectionConfig,\n\n    /// GitHub settings configuration\n    #[serde(default)]\n    pub github_settings: GitHubSettingsConfig,\n}\n\nimpl Default for ActionsConfig {\n    fn default() -\u003e Self {\n        Self {\n            gitignore: true,\n            license: LicenseConfig::default(),\n            contributing: true,\n            code_of_conduct: true,\n            security_policy: true,\n            branch_protection: BranchProtectionConfig::default(),\n            github_settings: GitHubSettingsConfig::default(),\n        }\n    }\n}\n\n/// License configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LicenseConfig {\n    /// Whether to create LICENSE file\n    #[serde(default = \"default_true\")]\n    pub enabled: bool,\n\n    /// License type (MIT, Apache-2.0, GPL-3.0, etc.)\n    #[serde(default = \"default_license_type\")]\n    pub license_type: String,\n\n    /// Author name for license\n    #[serde(default)]\n    pub author: Option\u003cString\u003e,\n\n    /// Year for license (defaults to current year)\n    #[serde(default)]\n    pub year: Option\u003cString\u003e,\n}\n\nimpl Default for LicenseConfig {\n    fn default() -\u003e Self {\n        Self {\n            enabled: true,\n            license_type: \"MIT\".to_string(),\n            author: None,\n            year: None,\n        }\n    }\n}\n\nfn default_license_type() -\u003e String {\n    \"MIT\".to_string()\n}\n\n/// Branch protection configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BranchProtectionConfig {\n    /// Whether to enable branch protection\n    #[serde(default = \"default_true\")]\n    pub enabled: bool,\n\n    /// Branch to protect (defaults to main)\n    #[serde(default = \"default_branch\")]\n    pub branch: String,\n\n    /// Number of required approvals\n    #[serde(default = \"default_approvals\")]\n    pub required_approvals: u32,\n\n    /// Whether to require status checks\n    #[serde(default = \"default_true\")]\n    pub require_status_checks: bool,\n\n    /// Whether to block force pushes\n    #[serde(default = \"default_true\")]\n    pub block_force_push: bool,\n\n    /// Whether to require signed commits\n    #[serde(default)]\n    pub require_signed_commits: bool,\n}\n\nimpl Default for BranchProtectionConfig {\n    fn default() -\u003e Self {\n        Self {\n            enabled: true,\n            branch: \"main\".to_string(),\n            required_approvals: 1,\n            require_status_checks: true,\n            block_force_push: true,\n            require_signed_commits: false,\n        }\n    }\n}\n\nfn default_branch() -\u003e String {\n    \"main\".to_string()\n}\n\nfn default_approvals() -\u003e u32 {\n    1\n}\n\n/// GitHub settings configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GitHubSettingsConfig {\n    /// Whether to enable GitHub Discussions\n    #[serde(default = \"default_true\")]\n    pub discussions: bool,\n\n    /// Whether to enable GitHub Issues\n    #[serde(default = \"default_true\")]\n    pub issues: bool,\n\n    /// Whether to enable GitHub Wiki\n    #[serde(default)]\n    pub wiki: bool,\n\n    /// Whether to enable vulnerability alerts\n    #[serde(default = \"default_true\")]\n    pub vulnerability_alerts: bool,\n\n    /// Whether to enable automatic security fixes\n    #[serde(default = \"default_true\")]\n    pub automated_security_fixes: bool,\n}\n\nimpl Default for GitHubSettingsConfig {\n    fn default() -\u003e Self {\n        Self {\n            discussions: true,\n            issues: true,\n            wiki: false,\n            vulnerability_alerts: true,\n            automated_security_fixes: true,\n        }\n    }\n}\n\n/// Template configuration\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct TemplatesConfig {\n    /// Author name for templates\n    pub license_author: Option\u003cString\u003e,\n\n    /// Year for templates\n    pub license_year: Option\u003cString\u003e,\n\n    /// Project name override\n    pub project_name: Option\u003cString\u003e,\n\n    /// Project description\n    pub project_description: Option\u003cString\u003e,\n}\n\n/// Custom rule configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CustomRule {\n    /// Regex pattern to match\n    pub pattern: String,\n\n    /// Severity level (critical, warning, info)\n    #[serde(default = \"default_custom_severity\")]\n    pub severity: String,\n\n    /// File glob patterns to include\n    #[serde(default)]\n    pub files: Vec\u003cString\u003e,\n\n    /// Custom message for the finding\n    pub message: Option\u003cString\u003e,\n\n    /// Detailed description\n    pub description: Option\u003cString\u003e,\n\n    /// Suggested remediation\n    pub remediation: Option\u003cString\u003e,\n\n    /// If true, fail when pattern is NOT found (inverted matching)\n    #[serde(default)]\n    pub invert: bool,\n}\n\nfn default_custom_severity() -\u003e String {\n    \"warning\".to_string()\n}\n\n/// Custom rules configuration container\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct CustomRulesConfig {\n    /// Map of rule ID to rule configuration\n    #[serde(flatten)]\n    pub rules: HashMap\u003cString, CustomRule\u003e,\n}\n","traces":[{"line":83,"address":[544676,544384,544670],"length":1,"stats":{"Line":14}},{"line":86,"address":[1371206],"length":1,"stats":{"Line":15}},{"line":90,"address":[1371216],"length":1,"stats":{"Line":15}},{"line":91,"address":[1371314,1371260],"length":1,"stats":{"Line":30}},{"line":117,"address":[1371504],"length":1,"stats":{"Line":14}},{"line":120,"address":[1371517],"length":1,"stats":{"Line":15}},{"line":127,"address":[1371680],"length":1,"stats":{"Line":0}},{"line":128,"address":[1371688],"length":1,"stats":{"Line":0}},{"line":160,"address":[1371712],"length":1,"stats":{"Line":15}},{"line":163,"address":[1371725],"length":1,"stats":{"Line":15}},{"line":172,"address":[1371824],"length":1,"stats":{"Line":0}},{"line":173,"address":[1371832],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":12},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","config","presets","mod.rs"],"content":"//! Preset configurations for different use cases\n\n/// Available presets\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum Preset {\n    /// Open source project - prepare for public release\n    OpenSource,\n    /// Enterprise project - internal company standards\n    Enterprise,\n    /// Strict mode - maximum security and compliance\n    Strict,\n}\n\nimpl Preset {\n    /// Get preset from name\n    pub fn from_name(name: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match name.to_lowercase().as_str() {\n            \"opensource\" | \"open-source\" | \"oss\" =\u003e Some(Self::OpenSource),\n            \"enterprise\" | \"ent\" | \"internal\" =\u003e Some(Self::Enterprise),\n            \"strict\" | \"secure\" | \"compliance\" =\u003e Some(Self::Strict),\n            _ =\u003e None,\n        }\n    }\n\n    /// Get the name of the preset\n    pub fn name(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::OpenSource =\u003e \"opensource\",\n            Self::Enterprise =\u003e \"enterprise\",\n            Self::Strict =\u003e \"strict\",\n        }\n    }\n\n    /// Get a description of the preset\n    #[allow(dead_code)]\n    pub fn description(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::OpenSource =\u003e \"Prepare repository for public open source release\",\n            Self::Enterprise =\u003e \"Apply internal company standards and policies\",\n            Self::Strict =\u003e \"Maximum security and compliance checks\",\n        }\n    }\n\n    /// Get the rules that should be enabled for this preset\n    #[allow(dead_code)]\n    pub fn enabled_rules(\u0026self) -\u003e Vec\u003c\u0026'static str\u003e {\n        match self {\n            Self::OpenSource =\u003e vec![\n                \"secrets/hardcoded\",\n                \"secrets/files\",\n                \"secrets/env\",\n                \"docs/readme\",\n                \"docs/license\",\n                \"docs/contributing\",\n                \"docs/code-of-conduct\",\n                \"docs/security\",\n                \"files/sensitive\",\n                \"files/large\",\n                \"files/gitignore\",\n                \"security/dependencies\",\n                \"workflows/secrets\",\n                \"workflows/permissions\",\n                \"github/branch-protection\",\n                \"github/settings\",\n            ],\n            Self::Enterprise =\u003e vec![\n                \"secrets/hardcoded\",\n                \"secrets/files\",\n                \"secrets/env\",\n                \"docs/readme\",\n                \"docs/security\",\n                \"files/sensitive\",\n                \"files/large\",\n                \"files/gitignore\",\n                \"security/dependencies\",\n                \"security/codeowners\",\n                \"security/signed-commits\",\n                \"workflows/secrets\",\n                \"workflows/permissions\",\n                \"github/branch-protection\",\n                \"github/settings\",\n            ],\n            Self::Strict =\u003e vec![\n                \"secrets/hardcoded\",\n                \"secrets/files\",\n                \"secrets/env\",\n                \"secrets/history\",\n                \"docs/readme\",\n                \"docs/license\",\n                \"docs/contributing\",\n                \"docs/code-of-conduct\",\n                \"docs/security\",\n                \"docs/changelog\",\n                \"files/sensitive\",\n                \"files/large\",\n                \"files/gitignore\",\n                \"files/editorconfig\",\n                \"security/dependencies\",\n                \"security/codeowners\",\n                \"security/signed-commits\",\n                \"workflows/secrets\",\n                \"workflows/permissions\",\n                \"workflows/pinned-actions\",\n                \"github/branch-protection\",\n                \"github/settings\",\n                \"quality/tests\",\n                \"quality/linting\",\n            ],\n        }\n    }\n\n    /// Get rules with critical severity for this preset\n    #[allow(dead_code)]\n    pub fn critical_rules(\u0026self) -\u003e Vec\u003c\u0026'static str\u003e {\n        match self {\n            Self::OpenSource =\u003e vec![\"secrets/hardcoded\", \"secrets/files\", \"docs/license\"],\n            Self::Enterprise =\u003e vec![\"secrets/hardcoded\", \"secrets/files\", \"security/codeowners\"],\n            Self::Strict =\u003e vec![\n                \"secrets/hardcoded\",\n                \"secrets/files\",\n                \"secrets/history\",\n                \"docs/license\",\n                \"security/codeowners\",\n                \"security/signed-commits\",\n            ],\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_preset_from_name() {\n        assert_eq!(Preset::from_name(\"opensource\").unwrap(), Preset::OpenSource);\n        assert_eq!(Preset::from_name(\"oss\").unwrap(), Preset::OpenSource);\n        assert_eq!(Preset::from_name(\"enterprise\").unwrap(), Preset::Enterprise);\n        assert_eq!(Preset::from_name(\"strict\").unwrap(), Preset::Strict);\n        assert!(Preset::from_name(\"invalid\").is_none());\n    }\n\n    #[test]\n    fn test_preset_name() {\n        assert_eq!(Preset::OpenSource.name(), \"opensource\");\n        assert_eq!(Preset::Enterprise.name(), \"enterprise\");\n        assert_eq!(Preset::Strict.name(), \"strict\");\n    }\n}\n","traces":[{"line":16,"address":[489568,490152,490158],"length":1,"stats":{"Line":2}},{"line":17,"address":[489680,489591],"length":1,"stats":{"Line":4}},{"line":18,"address":[489696],"length":1,"stats":{"Line":2}},{"line":19,"address":[489843],"length":1,"stats":{"Line":2}},{"line":20,"address":[649862],"length":1,"stats":{"Line":2}},{"line":21,"address":[490124],"length":1,"stats":{"Line":2}},{"line":26,"address":[490176],"length":1,"stats":{"Line":2}},{"line":27,"address":[490181],"length":1,"stats":{"Line":2}},{"line":28,"address":[490213],"length":1,"stats":{"Line":2}},{"line":29,"address":[490236],"length":1,"stats":{"Line":2}},{"line":30,"address":[490259],"length":1,"stats":{"Line":2}},{"line":36,"address":[490304],"length":1,"stats":{"Line":0}},{"line":37,"address":[490309],"length":1,"stats":{"Line":0}},{"line":38,"address":[490341],"length":1,"stats":{"Line":0}},{"line":39,"address":[650236],"length":1,"stats":{"Line":0}},{"line":40,"address":[490387],"length":1,"stats":{"Line":0}},{"line":46,"address":[490432],"length":1,"stats":{"Line":0}},{"line":47,"address":[490451],"length":1,"stats":{"Line":0}},{"line":48,"address":[650355,650469],"length":1,"stats":{"Line":0}},{"line":66,"address":[490515,491042],"length":1,"stats":{"Line":0}},{"line":83,"address":[490554,491454],"length":1,"stats":{"Line":0}},{"line":114,"address":[492096],"length":1,"stats":{"Line":0}},{"line":115,"address":[492115],"length":1,"stats":{"Line":0}},{"line":116,"address":[492147,492261],"length":1,"stats":{"Line":0}},{"line":117,"address":[492179,492408],"length":1,"stats":{"Line":0}},{"line":118,"address":[492547,492218],"length":1,"stats":{"Line":0}}],"covered":11,"coverable":26},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","error.rs"],"content":"//! Error types for RepoLens\n//!\n//! This module defines custom error types using `thiserror` for better error handling\n//! and more descriptive error messages throughout the application.\n\nuse thiserror::Error;\n\n/// Main error type for RepoLens\n#[derive(Error, Debug)]\npub enum RepoLensError {\n    /// Scan-related errors\n    #[error(\"Scan error: {0}\")]\n    Scan(#[from] ScanError),\n\n    /// Configuration-related errors\n    #[error(\"Config error: {0}\")]\n    Config(#[from] ConfigError),\n\n    /// Provider-related errors (GitHub API, etc.)\n    #[error(\"Provider error: {0}\")]\n    Provider(#[from] ProviderError),\n\n    /// Action execution errors\n    #[error(\"Action error: {0}\")]\n    Action(#[from] ActionError),\n\n    /// Rule execution errors\n    #[error(\"Rule error: {0}\")]\n    Rule(#[from] RuleError),\n}\n\n/// Errors that occur during repository scanning\n#[derive(Error, Debug)]\npub enum ScanError {\n    /// Failed to read a file\n    #[error(\"Failed to read file '{path}': {source}\")]\n    FileRead {\n        /// Path to the file that failed to read\n        path: String,\n        /// The underlying I/O error\n        source: std::io::Error,\n    },\n}\n\n/// Errors that occur during configuration loading and parsing\n#[derive(Error, Debug)]\npub enum ConfigError {\n    /// Failed to read configuration file\n    #[error(\"Failed to read configuration file '{path}': {source}\")]\n    FileRead {\n        /// Path to the configuration file\n        path: String,\n        /// The underlying I/O error\n        source: std::io::Error,\n    },\n\n    /// Failed to parse configuration file\n    #[error(\"Failed to parse configuration file: {message}\")]\n    Parse {\n        /// Error message describing the parse failure\n        message: String,\n    },\n\n    /// Failed to serialize configuration\n    #[error(\"Failed to serialize configuration: {message}\")]\n    Serialize {\n        /// Error message describing the serialization failure\n        message: String,\n    },\n\n    /// Invalid preset name\n    #[error(\"Invalid preset name: {name}\")]\n    InvalidPreset {\n        /// The invalid preset name\n        name: String,\n    },\n}\n\n/// Errors that occur when interacting with external providers (GitHub API, etc.)\n#[derive(Error, Debug)]\npub enum ProviderError {\n    /// Command execution failed\n    #[error(\"Command execution failed: {command}\")]\n    CommandFailed {\n        /// The command that failed\n        command: String,\n    },\n\n    /// Failed to parse JSON response\n    #[error(\"Failed to parse JSON response: {message}\")]\n    JsonParse {\n        /// Error message describing the parse failure\n        message: String,\n    },\n\n    /// Not in a GitHub repository or not authenticated\n    #[error(\"Not in a GitHub repository or not authenticated\")]\n    NotAuthenticated,\n\n    /// Invalid repository name format\n    #[error(\"Invalid repository name format: {name}\")]\n    InvalidRepoName {\n        /// The invalid repository name\n        name: String,\n    },\n\n    /// GitHub CLI not available\n    #[error(\"GitHub CLI (gh) is not available or not authenticated\")]\n    GitHubCliNotAvailable,\n}\n\n/// Errors that occur during action execution\n#[derive(Error, Debug)]\npub enum ActionError {\n    /// Failed to create file\n    #[error(\"Failed to create file '{path}': {source}\")]\n    #[allow(dead_code)]\n    FileCreate {\n        /// Path to the file that failed to create\n        path: String,\n        /// The underlying I/O error\n        source: std::io::Error,\n    },\n\n    /// Failed to write file\n    #[error(\"Failed to write file '{path}': {source}\")]\n    FileWrite {\n        /// Path to the file that failed to write\n        path: String,\n        /// The underlying I/O error\n        source: std::io::Error,\n    },\n\n    /// Failed to create directory\n    #[error(\"Failed to create directory '{path}': {source}\")]\n    DirectoryCreate {\n        /// Path to the directory that failed to create\n        path: String,\n        /// The underlying I/O error\n        source: std::io::Error,\n    },\n\n    /// Unknown template\n    #[error(\"Unknown template: {name}\")]\n    UnknownTemplate {\n        /// The unknown template name\n        name: String,\n    },\n\n    /// Action execution failed\n    #[error(\"Action execution failed: {message}\")]\n    ExecutionFailed {\n        /// Error message describing the failure\n        message: String,\n    },\n}\n\n/// Errors that occur during rule execution\n#[derive(Error, Debug)]\npub enum RuleError {\n    /// Rule execution failed\n    #[error(\"Rule execution failed: {message}\")]\n    ExecutionFailed {\n        /// Error message describing the failure\n        message: String,\n    },\n}\n\n// Allow conversion from std::io::Error for convenience\nimpl From\u003cstd::io::Error\u003e for RepoLensError {\n    fn from(err: std::io::Error) -\u003e Self {\n        RepoLensError::Scan(ScanError::FileRead {\n            path: \"unknown\".to_string(),\n            source: err,\n        })\n    }\n}\n\n// Conversion from toml::de::Error\nimpl From\u003ctoml::de::Error\u003e for RepoLensError {\n    fn from(err: toml::de::Error) -\u003e Self {\n        RepoLensError::Config(ConfigError::Parse {\n            message: err.to_string(),\n        })\n    }\n}\n\n// Conversion from toml::ser::Error\nimpl From\u003ctoml::ser::Error\u003e for RepoLensError {\n    fn from(err: toml::ser::Error) -\u003e Self {\n        RepoLensError::Config(ConfigError::Serialize {\n            message: err.to_string(),\n        })\n    }\n}\n\n// Conversion from serde_json::Error\nimpl From\u003cserde_json::Error\u003e for RepoLensError {\n    fn from(err: serde_json::Error) -\u003e Self {\n        RepoLensError::Provider(ProviderError::JsonParse {\n            message: err.to_string(),\n        })\n    }\n}\n","traces":[{"line":170,"address":[10822202,10821418],"length":1,"stats":{"Line":0}},{"line":171,"address":[6265401],"length":1,"stats":{"Line":0}},{"line":172,"address":[8448433,8447649],"length":1,"stats":{"Line":0}},{"line":173,"address":[3277710],"length":1,"stats":{"Line":0}},{"line":174,"address":[6265241],"length":1,"stats":{"Line":0}},{"line":180,"address":[6265456],"length":1,"stats":{"Line":0}},{"line":181,"address":[784116,783936],"length":1,"stats":{"Line":0}},{"line":182,"address":[10822688],"length":1,"stats":{"Line":0}},{"line":183,"address":[3277906],"length":1,"stats":{"Line":0}},{"line":189,"address":[6571449],"length":1,"stats":{"Line":0}},{"line":190,"address":[10822743],"length":1,"stats":{"Line":0}},{"line":191,"address":[15650283],"length":1,"stats":{"Line":0}},{"line":192,"address":[6571280],"length":1,"stats":{"Line":0}},{"line":198,"address":[10497760],"length":1,"stats":{"Line":0}},{"line":199,"address":[907801,907795,907616],"length":1,"stats":{"Line":0}},{"line":200,"address":[8449469],"length":1,"stats":{"Line":0}},{"line":201,"address":[8449551,8449612],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","lib.rs"],"content":"//! RepoLens Library\n//!\n//! This crate provides the core functionality for auditing repositories\n//! and preparing them for open source or enterprise standards.\n\npub mod actions;\npub mod cli;\npub mod config;\npub mod error;\npub mod providers;\npub mod rules;\npub mod scanner;\npub mod utils;\n\npub use error::RepoLensError;\n\n/// Exit codes for the CLI\npub mod exit_codes {\n    /// Success - no issues found\n    pub const SUCCESS: i32 = 0;\n    /// Critical issues found that block release\n    pub const CRITICAL_ISSUES: i32 = 1;\n    /// Warnings found but not blocking\n    pub const WARNINGS: i32 = 2;\n    /// Configuration or runtime error\n    pub const ERROR: i32 = 3;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","main.rs"],"content":"//! RepoLens - A CLI tool to audit and prepare repositories for open source or enterprise standards\n//!\n//! This is the main entry point for the CLI application.\n\nuse clap::Parser;\nuse tracing_subscriber::{fmt, prelude::*, EnvFilter};\n\nmod actions;\nmod cli;\nmod config;\nmod error;\nmod providers;\nmod rules;\nmod scanner;\nmod utils;\n\nuse error::RepoLensError;\n\n/// Exit codes for the CLI\npub mod exit_codes {\n    /// Success - no issues found\n    pub const SUCCESS: i32 = 0;\n    /// Critical issues found that block release\n    pub const CRITICAL_ISSUES: i32 = 1;\n    /// Warnings found but not blocking\n    pub const WARNINGS: i32 = 2;\n    /// Configuration or runtime error\n    pub const ERROR: i32 = 3;\n}\n\nuse cli::{Cli, Commands};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), RepoLensError\u003e {\n    // Parse CLI arguments\n    let cli = Cli::parse();\n\n    // Setup logging based on verbosity\n    setup_logging(cli.verbose);\n\n    // Execute the appropriate command\n    let result = match cli.command {\n        Commands::Init(args) =\u003e cli::commands::init::execute(args).await,\n        Commands::Plan(args) =\u003e cli::commands::plan::execute(args).await,\n        Commands::Apply(args) =\u003e cli::commands::apply::execute(args).await,\n        Commands::Report(args) =\u003e cli::commands::report::execute(args).await,\n    };\n\n    // Handle exit codes for CI integration\n    match result {\n        Ok(exit_code) =\u003e std::process::exit(exit_code),\n        Err(e) =\u003e {\n            eprintln!(\"Error: {}\", e);\n            std::process::exit(1);\n        }\n    }\n}\n\nfn setup_logging(verbosity: u8) {\n    let filter = match verbosity {\n        0 =\u003e \"warn\",\n        1 =\u003e \"info\",\n        2 =\u003e \"debug\",\n        _ =\u003e \"trace\",\n    };\n\n    tracing_subscriber::registry()\n        .with(fmt::layer())\n        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(filter)))\n        .init();\n}\n","traces":[{"line":34,"address":[637568,637996,637990],"length":1,"stats":{"Line":0}},{"line":36,"address":[744198],"length":1,"stats":{"Line":0}},{"line":39,"address":[744439],"length":1,"stats":{"Line":0}},{"line":42,"address":[744546],"length":1,"stats":{"Line":0}},{"line":43,"address":[586916],"length":1,"stats":{"Line":0}},{"line":44,"address":[586935],"length":1,"stats":{"Line":0}},{"line":45,"address":[586954],"length":1,"stats":{"Line":0}},{"line":46,"address":[586973],"length":1,"stats":{"Line":0}},{"line":50,"address":[637754,637684,637865,637624],"length":1,"stats":{"Line":0}},{"line":51,"address":[746369],"length":1,"stats":{"Line":0}},{"line":52,"address":[746304],"length":1,"stats":{"Line":0}},{"line":53,"address":[746433,746362],"length":1,"stats":{"Line":0}},{"line":54,"address":[746502],"length":1,"stats":{"Line":0}},{"line":59,"address":[637498,637040,637530],"length":1,"stats":{"Line":0}},{"line":60,"address":[637076],"length":1,"stats":{"Line":0}},{"line":61,"address":[637141],"length":1,"stats":{"Line":0}},{"line":62,"address":[637164],"length":1,"stats":{"Line":0}},{"line":63,"address":[637187],"length":1,"stats":{"Line":0}},{"line":64,"address":[637118],"length":1,"stats":{"Line":0}},{"line":67,"address":[637289,637208,637436,637480],"length":1,"stats":{"Line":0}},{"line":68,"address":[637328,637248,637241,637536],"length":1,"stats":{"Line":0}},{"line":69,"address":[637511,637344,637472,637363],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","providers","github.rs"],"content":"//! GitHub provider - Interactions with GitHub API via gh CLI\n\nuse crate::error::{ProviderError, RepoLensError};\nuse serde::Deserialize;\nuse std::process::Command;\n\n/// GitHub provider for repository operations\n#[allow(dead_code)]\npub struct GitHubProvider {\n    repo_owner: String,\n    repo_name: String,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\nstruct RepoInfo {\n    name: String,\n    owner: RepoOwner,\n    visibility: String,\n    #[serde(rename = \"hasIssuesEnabled\")]\n    has_issues_enabled: bool,\n    #[serde(rename = \"hasDiscussionsEnabled\")]\n    has_discussions_enabled: bool,\n    #[serde(rename = \"hasWikiEnabled\")]\n    has_wiki_enabled: bool,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\nstruct RepoOwner {\n    login: String,\n}\n\nimpl GitHubProvider {\n    /// Create a new GitHub provider for the current repository\n    #[allow(dead_code)]\n    pub fn new() -\u003e Result\u003cSelf, RepoLensError\u003e {\n        let (owner, name) = Self::get_repo_info()?;\n        Ok(Self {\n            repo_owner: owner,\n            repo_name: name,\n        })\n    }\n\n    /// Check if GitHub CLI is available and authenticated\n    #[allow(dead_code)]\n    pub fn is_available() -\u003e bool {\n        Command::new(\"gh\")\n            .args([\"auth\", \"status\"])\n            .output()\n            .map(|o| o.status.success())\n            .unwrap_or(false)\n    }\n\n    /// Get repository owner and name\n    #[allow(dead_code)]\n    fn get_repo_info() -\u003e Result\u003c(String, String), RepoLensError\u003e {\n        let output = Command::new(\"gh\")\n            .args([\n                \"repo\",\n                \"view\",\n                \"--json\",\n                \"owner,name\",\n                \"-q\",\n                \".owner.login + \\\"/\\\" + .name\",\n            ])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: \"gh repo view\".to_string(),\n                })\n            })?;\n\n        if !output.status.success() {\n            return Err(RepoLensError::Provider(ProviderError::NotAuthenticated));\n        }\n\n        let full_name = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n        let parts: Vec\u003c\u0026str\u003e = full_name.split('/').collect();\n\n        if parts.len() != 2 {\n            return Err(RepoLensError::Provider(ProviderError::InvalidRepoName {\n                name: full_name,\n            }));\n        }\n\n        Ok((parts[0].to_string(), parts[1].to_string()))\n    }\n\n    /// Get the full repository name (owner/name)\n    #[allow(dead_code)]\n    pub fn full_name(\u0026self) -\u003e String {\n        format!(\"{}/{}\", self.repo_owner, self.repo_name)\n    }\n\n    /// Get repository visibility\n    #[allow(dead_code)]\n    pub fn get_visibility(\u0026self) -\u003e Result\u003cString, RepoLensError\u003e {\n        let output = Command::new(\"gh\")\n            .args([\"repo\", \"view\", \"--json\", \"visibility\", \"-q\", \".visibility\"])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: \"gh repo view\".to_string(),\n                })\n            })?;\n\n        Ok(String::from_utf8_lossy(\u0026output.stdout)\n            .trim()\n            .to_lowercase())\n    }\n\n    /// Check if the repository is public\n    #[allow(dead_code)]\n    pub fn is_public(\u0026self) -\u003e Result\u003cbool, RepoLensError\u003e {\n        Ok(self.get_visibility()? == \"public\")\n    }\n\n    /// Get list of repository secrets (names only)\n    #[allow(dead_code)]\n    pub fn list_secrets(\u0026self) -\u003e Result\u003cVec\u003cString\u003e, RepoLensError\u003e {\n        let output = Command::new(\"gh\")\n            .args([\"secret\", \"list\", \"--json\", \"name\", \"-q\", \".[].name\"])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: \"gh secret list\".to_string(),\n                })\n            })?;\n\n        if !output.status.success() {\n            return Ok(Vec::new());\n        }\n\n        let output_str = String::from_utf8_lossy(\u0026output.stdout);\n        Ok(output_str.lines().map(|s| s.to_string()).collect())\n    }\n\n    /// Get list of repository variables\n    #[allow(dead_code)]\n    pub fn list_variables(\u0026self) -\u003e Result\u003cVec\u003cString\u003e, RepoLensError\u003e {\n        let output = Command::new(\"gh\")\n            .args([\"variable\", \"list\", \"--json\", \"name\", \"-q\", \".[].name\"])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: \"gh variable list\".to_string(),\n                })\n            })?;\n\n        if !output.status.success() {\n            return Ok(Vec::new());\n        }\n\n        let output_str = String::from_utf8_lossy(\u0026output.stdout);\n        Ok(output_str.lines().map(|s| s.to_string()).collect())\n    }\n\n    /// Get branch protection status\n    #[allow(dead_code)]\n    pub fn get_branch_protection(\n        \u0026self,\n        branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cBranchProtection\u003e, RepoLensError\u003e {\n        let output = Command::new(\"gh\")\n            .args([\n                \"api\",\n                \u0026format!(\"repos/{}/branches/{}/protection\", self.full_name(), branch),\n            ])\n            .output()\n            .map_err(|_| {\n                RepoLensError::Provider(ProviderError::CommandFailed {\n                    command: format!(\n                        \"gh api repos/{}/branches/{}/protection\",\n                        self.full_name(),\n                        branch\n                    ),\n                })\n            })?;\n\n        if !output.status.success() {\n            // 404 means no protection\n            return Ok(None);\n        }\n\n        let protection: BranchProtection = serde_json::from_slice(\u0026output.stdout)?;\n\n        Ok(Some(protection))\n    }\n}\n\n/// Branch protection settings from GitHub API\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct BranchProtection {\n    #[serde(rename = \"required_status_checks\")]\n    pub required_status_checks: Option\u003cStatusChecks\u003e,\n\n    #[serde(rename = \"enforce_admins\")]\n    pub enforce_admins: Option\u003cEnforceAdmins\u003e,\n\n    #[serde(rename = \"required_pull_request_reviews\")]\n    pub required_pull_request_reviews: Option\u003cPullRequestReviews\u003e,\n\n    #[serde(rename = \"required_linear_history\")]\n    pub required_linear_history: Option\u003cRequiredLinearHistory\u003e,\n\n    #[serde(rename = \"allow_force_pushes\")]\n    pub allow_force_pushes: Option\u003cAllowForcePushes\u003e,\n\n    #[serde(rename = \"allow_deletions\")]\n    pub allow_deletions: Option\u003cAllowDeletions\u003e,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct StatusChecks {\n    pub strict: bool,\n    pub contexts: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct EnforceAdmins {\n    pub enabled: bool,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct PullRequestReviews {\n    #[serde(rename = \"required_approving_review_count\")]\n    pub required_approving_review_count: u32,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct RequiredLinearHistory {\n    pub enabled: bool,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct AllowForcePushes {\n    pub enabled: bool,\n}\n\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct AllowDeletions {\n    pub enabled: bool,\n}\n","traces":[{"line":37,"address":[302016],"length":1,"stats":{"Line":0}},{"line":38,"address":[930464],"length":1,"stats":{"Line":0}},{"line":39,"address":[302252],"length":1,"stats":{"Line":0}},{"line":47,"address":[302606,302368,302600],"length":1,"stats":{"Line":0}},{"line":48,"address":[302469,302524,302375],"length":1,"stats":{"Line":0}},{"line":49,"address":[302407],"length":1,"stats":{"Line":0}},{"line":51,"address":[549744,549753],"length":1,"stats":{"Line":0}},{"line":57,"address":[304446,304487,302624],"length":1,"stats":{"Line":0}},{"line":58,"address":[302915,302854,303070,302641],"length":1,"stats":{"Line":0}},{"line":59,"address":[302684],"length":1,"stats":{"Line":0}},{"line":68,"address":[550034,550028,549840],"length":1,"stats":{"Line":0}},{"line":69,"address":[1206277],"length":1,"stats":{"Line":0}},{"line":70,"address":[549858],"length":1,"stats":{"Line":0}},{"line":74,"address":[303282],"length":1,"stats":{"Line":0}},{"line":75,"address":[303320],"length":1,"stats":{"Line":0}},{"line":78,"address":[303450,303507],"length":1,"stats":{"Line":0}},{"line":79,"address":[303731],"length":1,"stats":{"Line":0}},{"line":81,"address":[303882,303809],"length":1,"stats":{"Line":0}},{"line":82,"address":[303971],"length":1,"stats":{"Line":0}},{"line":83,"address":[303931],"length":1,"stats":{"Line":0}},{"line":87,"address":[303888,304135],"length":1,"stats":{"Line":0}},{"line":92,"address":[304528],"length":1,"stats":{"Line":0}},{"line":93,"address":[304557],"length":1,"stats":{"Line":0}},{"line":98,"address":[304720,305654,305660],"length":1,"stats":{"Line":0}},{"line":99,"address":[305166,304745,304950,305011],"length":1,"stats":{"Line":0}},{"line":100,"address":[933212],"length":1,"stats":{"Line":0}},{"line":102,"address":[550048,550242,550236],"length":1,"stats":{"Line":0}},{"line":103,"address":[550133],"length":1,"stats":{"Line":0}},{"line":104,"address":[550066],"length":1,"stats":{"Line":0}},{"line":108,"address":[305366,305494],"length":1,"stats":{"Line":0}},{"line":115,"address":[305696,305983,305989],"length":1,"stats":{"Line":0}},{"line":116,"address":[305946,305721],"length":1,"stats":{"Line":0}},{"line":121,"address":[306016,307050,307056],"length":1,"stats":{"Line":0}},{"line":122,"address":[306041,306307,306246,306462],"length":1,"stats":{"Line":0}},{"line":123,"address":[306076],"length":1,"stats":{"Line":0}},{"line":125,"address":[550256,550450,550444],"length":1,"stats":{"Line":0}},{"line":126,"address":[550341],"length":1,"stats":{"Line":0}},{"line":127,"address":[550274],"length":1,"stats":{"Line":0}},{"line":131,"address":[306662],"length":1,"stats":{"Line":0}},{"line":132,"address":[306741,306691],"length":1,"stats":{"Line":0}},{"line":135,"address":[306710,306817],"length":1,"stats":{"Line":0}},{"line":136,"address":[1206816,1206869],"length":1,"stats":{"Line":0}},{"line":141,"address":[308122,308128,307088],"length":1,"stats":{"Line":0}},{"line":142,"address":[307113,307318,307379,307534],"length":1,"stats":{"Line":0}},{"line":143,"address":[307148],"length":1,"stats":{"Line":0}},{"line":145,"address":[1207084,1206896,1207090],"length":1,"stats":{"Line":0}},{"line":146,"address":[550629],"length":1,"stats":{"Line":0}},{"line":147,"address":[1206914],"length":1,"stats":{"Line":0}},{"line":151,"address":[307734],"length":1,"stats":{"Line":0}},{"line":152,"address":[307763,307813],"length":1,"stats":{"Line":0}},{"line":155,"address":[307782,307889],"length":1,"stats":{"Line":0}},{"line":156,"address":[1207104,1207157],"length":1,"stats":{"Line":0}},{"line":161,"address":[308160,309511,309517],"length":1,"stats":{"Line":0}},{"line":165,"address":[308730,308912,308200],"length":1,"stats":{"Line":0}},{"line":166,"address":[308671],"length":1,"stats":{"Line":0}},{"line":168,"address":[308289,308238],"length":1,"stats":{"Line":0}},{"line":171,"address":[1207668,1207184,1207674],"length":1,"stats":{"Line":0}},{"line":172,"address":[551210],"length":1,"stats":{"Line":0}},{"line":173,"address":[550924],"length":1,"stats":{"Line":0}},{"line":175,"address":[550863],"length":1,"stats":{"Line":0}},{"line":181,"address":[309175],"length":1,"stats":{"Line":0}},{"line":183,"address":[309209],"length":1,"stats":{"Line":0}},{"line":186,"address":[309306,309506,309247],"length":1,"stats":{"Line":0}},{"line":188,"address":[309434],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":64},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","providers","mod.rs"],"content":"//! Provider module - External service integrations\n\npub mod github;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","custom.rs"],"content":"//! Custom rules category\n//!\n//! Allows users to define custom audit rules via regex patterns in configuration.\n\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::{Finding, Severity};\nuse crate::scanner::Scanner;\nuse regex::Regex;\nuse tracing::debug;\n\n/// Custom rules implementation\npub struct CustomRules;\n\n/// Simple glob matching (supports * and **)\nfn glob_match(pattern: \u0026str, text: \u0026str) -\u003e bool {\n    if pattern.contains(\"**\") {\n        return glob_match_double_star(pattern, text);\n    }\n\n    if pattern.contains('*') {\n        return glob_match_single_star(pattern, text);\n    }\n\n    text == pattern\n}\n\n/// Match pattern with double star (**)\nfn glob_match_double_star(pattern: \u0026str, text: \u0026str) -\u003e bool {\n    let parts: Vec\u003c\u0026str\u003e = pattern.split(\"**\").collect();\n\n    if parts.len() == 3 \u0026\u0026 parts[0].is_empty() \u0026\u0026 parts[2].is_empty() {\n        let middle = parts[1].trim_matches('/');\n        return text.contains(\u0026format!(\"/{}\", middle)) || text.starts_with(middle);\n    }\n\n    if parts.len() != 2 {\n        return false;\n    }\n\n    let prefix = parts[0].trim_end_matches('/');\n    let suffix_raw = parts[1];\n    let suffix = suffix_raw.trim_start_matches('/');\n\n    if !prefix.is_empty() \u0026\u0026 !text.starts_with(prefix) {\n        return false;\n    }\n\n    if suffix.is_empty() {\n        return true;\n    }\n\n    if suffix.starts_with('*') {\n        let suffix_pattern = suffix.trim_start_matches('*');\n        return text.ends_with(suffix_pattern);\n    }\n\n    if prefix.is_empty() {\n        if suffix_raw.starts_with('/') {\n            let pattern_to_find = format!(\"/{}\", suffix);\n            if text.contains(\u0026pattern_to_find) {\n                return true;\n            }\n            if text.starts_with(suffix) {\n                return true;\n            }\n            return false;\n        }\n        return text.contains(suffix);\n    }\n\n    if let Some(after_prefix) = text.strip_prefix(prefix) {\n        return after_prefix.contains(suffix) || after_prefix.ends_with(suffix);\n    }\n\n    text.ends_with(suffix) || text.contains(suffix)\n}\n\n/// Match pattern with single star (*)\nfn glob_match_single_star(pattern: \u0026str, text: \u0026str) -\u003e bool {\n    let parts: Vec\u003c\u0026str\u003e = pattern.split('*').collect();\n    let mut pos = 0;\n\n    for (i, part) in parts.iter().enumerate() {\n        if part.is_empty() {\n            continue;\n        }\n\n        if let Some(found_pos) = text[pos..].find(part) {\n            if i == 0 \u0026\u0026 found_pos != 0 {\n                return false;\n            }\n            pos += found_pos + part.len();\n        } else {\n            return false;\n        }\n    }\n\n    if let Some(last_part) = parts.last() {\n        if !last_part.is_empty() {\n            return text.ends_with(last_part);\n        }\n    }\n\n    true\n}\n\n#[async_trait::async_trait]\nimpl RuleCategory for CustomRules {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"custom\"\n    }\n\n    async fn run(\n        \u0026self,\n        scanner: \u0026Scanner,\n        config: \u0026Config,\n    ) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n        let mut findings = Vec::new();\n\n        // Skip if no custom rules defined\n        if config.custom_rules.rules.is_empty() {\n            debug!(\"No custom rules defined\");\n            return Ok(findings);\n        }\n\n        // Get all files from the scanner\n        let all_files = scanner.all_files();\n\n        for (rule_id, rule) in \u0026config.custom_rules.rules {\n            debug!(rule_id = %rule_id, pattern = %rule.pattern, \"Processing custom rule\");\n\n            // Compile the regex pattern\n            let regex = match Regex::new(\u0026rule.pattern) {\n                Ok(r) =\u003e r,\n                Err(e) =\u003e {\n                    debug!(\n                        rule_id = %rule_id,\n                        error = %e,\n                        \"Invalid regex pattern in custom rule\"\n                    );\n                    continue;\n                }\n            };\n\n            // Determine severity\n            let severity = match rule.severity.to_lowercase().as_str() {\n                \"critical\" =\u003e Severity::Critical,\n                \"warning\" =\u003e Severity::Warning,\n                \"info\" =\u003e Severity::Info,\n                _ =\u003e Severity::Warning,\n            };\n\n            // Filter files based on glob patterns\n            let files_to_check: Vec\u003c_\u003e = if rule.files.is_empty() {\n                all_files.iter().collect()\n            } else {\n                all_files\n                    .iter()\n                    .filter(|file| {\n                        rule.files\n                            .iter()\n                            .any(|pattern| glob_match(pattern, \u0026file.path))\n                    })\n                    .collect()\n            };\n\n            // Check each file\n            for file_info in files_to_check {\n                let file_path = \u0026file_info.path;\n\n                // Read file content\n                let content = match scanner.read_file(file_path) {\n                    Ok(c) =\u003e c,\n                    Err(_) =\u003e continue, // Skip files that can't be read\n                };\n\n                let pattern_found = regex.is_match(\u0026content);\n\n                // Handle inverted matching\n                let should_report = if rule.invert {\n                    !pattern_found // Report if pattern NOT found\n                } else {\n                    pattern_found // Report if pattern found\n                };\n\n                if should_report {\n                    // Find line numbers for matches (only for non-inverted)\n                    let locations: Vec\u003c(usize, String)\u003e = if !rule.invert {\n                        content\n                            .lines()\n                            .enumerate()\n                            .filter(|(_, line)| regex.is_match(line))\n                            .map(|(i, line)| (i + 1, line.to_string()))\n                            .take(5) // Limit to first 5 matches\n                            .collect()\n                    } else {\n                        vec![]\n                    };\n\n                    let message = rule.message.clone().unwrap_or_else(|| {\n                        if rule.invert {\n                            format!(\"Required pattern '{}' not found\", rule.pattern)\n                        } else {\n                            format!(\"Pattern '{}' matched\", rule.pattern)\n                        }\n                    });\n\n                    let description = rule.description.clone().unwrap_or_else(|| {\n                        if locations.is_empty() {\n                            format!(\"Custom rule '{}' triggered in {}\", rule_id, file_path)\n                        } else {\n                            let lines: Vec\u003cString\u003e = locations\n                                .iter()\n                                .map(|(line_num, _)| format!(\"line {}\", line_num))\n                                .collect();\n                            format!(\n                                \"Custom rule '{}' triggered in {} at {}\",\n                                rule_id,\n                                file_path,\n                                lines.join(\", \")\n                            )\n                        }\n                    });\n\n                    let location = if let Some((line_num, _)) = locations.first() {\n                        Some(format!(\"{}:{}\", file_path, line_num))\n                    } else {\n                        Some(file_path.to_string())\n                    };\n\n                    findings.push(Finding {\n                        rule_id: format!(\"custom/{}\", rule_id),\n                        category: \"custom\".to_string(),\n                        severity,\n                        message,\n                        location,\n                        description: Some(description),\n                        remediation: rule.remediation.clone(),\n                    });\n                }\n            }\n        }\n\n        Ok(findings)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::{CustomRule, CustomRulesConfig};\n    use std::collections::HashMap;\n    use std::fs;\n    use tempfile::TempDir;\n\n    fn create_test_config_with_rule(rule_id: \u0026str, rule: CustomRule) -\u003e Config {\n        let mut rules = HashMap::new();\n        rules.insert(rule_id.to_string(), rule);\n        let mut config = Config::default();\n        config.custom_rules = CustomRulesConfig { rules };\n        config\n    }\n\n    #[tokio::test]\n    async fn test_custom_rule_pattern_match() {\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"test.rs\");\n        fs::write(\u0026test_file, \"// TODO: fix this later\\nfn main() {}\").unwrap();\n\n        let rule = CustomRule {\n            pattern: \"TODO\".to_string(),\n            severity: \"warning\".to_string(),\n            files: vec![\"**/*.rs\".to_string()],\n            message: Some(\"TODO comment found\".to_string()),\n            description: None,\n            remediation: Some(\"Address or remove the TODO\".to_string()),\n            invert: false,\n        };\n\n        let config = create_test_config_with_rule(\"no-todo\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(\u0026scanner, \u0026config).await.unwrap();\n\n        assert_eq!(findings.len(), 1);\n        assert_eq!(findings[0].rule_id, \"custom/no-todo\");\n        assert_eq!(findings[0].severity, Severity::Warning);\n        assert!(findings[0].message.contains(\"TODO\"));\n    }\n\n    #[tokio::test]\n    async fn test_custom_rule_no_match() {\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"test.rs\");\n        fs::write(\u0026test_file, \"fn main() { println!(\\\"Hello\\\"); }\").unwrap();\n\n        let rule = CustomRule {\n            pattern: \"TODO\".to_string(),\n            severity: \"warning\".to_string(),\n            files: vec![\"**/*.rs\".to_string()],\n            message: None,\n            description: None,\n            remediation: None,\n            invert: false,\n        };\n\n        let config = create_test_config_with_rule(\"no-todo\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(findings.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_custom_rule_inverted_match() {\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"lib.rs\");\n        fs::write(\u0026test_file, \"fn helper() {}\").unwrap();\n\n        let rule = CustomRule {\n            pattern: r\"^//!\".to_string(), // Module doc comment\n            severity: \"info\".to_string(),\n            files: vec![\"**/lib.rs\".to_string()],\n            message: Some(\"Missing module documentation\".to_string()),\n            description: None,\n            remediation: Some(\"Add module-level documentation\".to_string()),\n            invert: true, // Fail when NOT found\n        };\n\n        let config = create_test_config_with_rule(\"require-doc\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(\u0026scanner, \u0026config).await.unwrap();\n\n        assert_eq!(findings.len(), 1);\n        assert_eq!(findings[0].rule_id, \"custom/require-doc\");\n        assert!(findings[0].message.contains(\"Missing module documentation\"));\n    }\n\n    #[tokio::test]\n    async fn test_custom_rule_file_filter() {\n        let temp_dir = TempDir::new().unwrap();\n        fs::write(temp_dir.path().join(\"test.rs\"), \"TODO: fix\").unwrap();\n        fs::write(temp_dir.path().join(\"test.js\"), \"// TODO: fix\").unwrap();\n\n        let rule = CustomRule {\n            pattern: \"TODO\".to_string(),\n            severity: \"warning\".to_string(),\n            files: vec![\"**/*.rs\".to_string()], // Only Rust files\n            message: None,\n            description: None,\n            remediation: None,\n            invert: false,\n        };\n\n        let config = create_test_config_with_rule(\"no-todo\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(\u0026scanner, \u0026config).await.unwrap();\n\n        // Should only find in .rs file, not .js\n        assert_eq!(findings.len(), 1);\n        assert!(findings[0].location.as_ref().unwrap().ends_with(\".rs\") \n            || findings[0].location.as_ref().unwrap().contains(\".rs:\"));\n    }\n\n    #[tokio::test]\n    async fn test_custom_rule_severity_levels() {\n        let temp_dir = TempDir::new().unwrap();\n        fs::write(temp_dir.path().join(\"test.rs\"), \"FIXME: urgent\").unwrap();\n\n        let rule = CustomRule {\n            pattern: \"FIXME\".to_string(),\n            severity: \"critical\".to_string(),\n            files: vec![],\n            message: None,\n            description: None,\n            remediation: None,\n            invert: false,\n        };\n\n        let config = create_test_config_with_rule(\"no-fixme\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(\u0026scanner, \u0026config).await.unwrap();\n\n        assert_eq!(findings.len(), 1);\n        assert_eq!(findings[0].severity, Severity::Critical);\n    }\n\n    #[tokio::test]\n    async fn test_no_custom_rules_returns_empty() {\n        let temp_dir = TempDir::new().unwrap();\n        fs::write(temp_dir.path().join(\"test.rs\"), \"fn main() {}\").unwrap();\n\n        let config = Config::default(); // No custom rules\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        let findings = custom_rules.run(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(findings.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_invalid_regex_is_skipped() {\n        let temp_dir = TempDir::new().unwrap();\n        fs::write(temp_dir.path().join(\"test.rs\"), \"test content\").unwrap();\n\n        let rule = CustomRule {\n            pattern: \"[invalid regex\".to_string(), // Invalid regex\n            severity: \"warning\".to_string(),\n            files: vec![],\n            message: None,\n            description: None,\n            remediation: None,\n            invert: false,\n        };\n\n        let config = create_test_config_with_rule(\"bad-rule\", rule);\n        let scanner = Scanner::new(temp_dir.path().to_path_buf());\n        let custom_rules = CustomRules;\n\n        // Should not panic, just skip the invalid rule\n        let findings = custom_rules.run(\u0026scanner, \u0026config).await.unwrap();\n        assert!(findings.is_empty());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","docs.rs"],"content":"//! Documentation rules\n//!\n//! This module provides rules for checking repository documentation, including:\n//! - README files and their quality\n//! - LICENSE files\n//! - CONTRIBUTING guidelines\n//! - CODE_OF_CONDUCT files\n//! - SECURITY policy files\n\nuse crate::error::RepoLensError;\n\nuse crate::config::Config;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for checking repository documentation\npub struct DocsRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for DocsRules {\n    /// Get the category name\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"docs\"\n    }\n\n    /// Run all documentation-related rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for documentation issues\n    async fn run(\u0026self, scanner: \u0026Scanner, config: \u0026Config) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n        let mut findings = Vec::new();\n\n        // Check README\n        if config.is_rule_enabled(\"docs/readme\") {\n            findings.extend(check_readme(scanner).await?);\n        }\n\n        // Check LICENSE\n        if config.is_rule_enabled(\"docs/license\") {\n            findings.extend(check_license(scanner, config).await?);\n        }\n\n        // Check CONTRIBUTING\n        if config.is_rule_enabled(\"docs/contributing\") {\n            findings.extend(check_contributing(scanner).await?);\n        }\n\n        // Check CODE_OF_CONDUCT\n        if config.is_rule_enabled(\"docs/code-of-conduct\") {\n            findings.extend(check_code_of_conduct(scanner).await?);\n        }\n\n        // Check SECURITY\n        if config.is_rule_enabled(\"docs/security\") {\n            findings.extend(check_security(scanner).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for README file and assess its quality\n///\n/// Verifies README existence and checks for recommended sections like\n/// installation, usage, and license information.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for README issues\nasync fn check_readme(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    let readme_files = [\"README.md\", \"README\", \"README.txt\", \"README.rst\"];\n    let has_readme = readme_files.iter().any(|f| scanner.file_exists(f));\n\n    if !has_readme {\n        findings.push(\n            Finding::new(\n                \"DOC001\",\n                \"docs\",\n                Severity::Warning,\n                \"README file is missing\",\n            )\n            .with_description(\n                \"A README file is essential for explaining what the project does and how to use it.\"\n            )\n            .with_remediation(\n                \"Create a README.md file with project description, installation instructions, and usage examples.\"\n            )\n        );\n        return Ok(findings);\n    }\n\n    // Check README quality\n    if let Ok(content) = scanner.read_file(\"README.md\") {\n        let line_count = content.lines().count();\n\n        if line_count \u003c 10 {\n            findings.push(\n                Finding::new(\n                    \"DOC002\",\n                    \"docs\",\n                    Severity::Warning,\n                    format!(\"README is too short ({} lines)\", line_count),\n                )\n                .with_description(\n                    \"A comprehensive README should include sections for description, installation, usage, and contribution guidelines.\"\n                )\n            );\n        }\n\n        // Check for recommended sections\n        let sections = [\n            (\"installation\", \"Installation instructions\"),\n            (\"usage\", \"Usage examples\"),\n            (\"license\", \"License information\"),\n        ];\n\n        for (keyword, description) in sections {\n            if !content.to_lowercase().contains(keyword) {\n                findings.push(Finding::new(\n                    \"DOC003\",\n                    \"docs\",\n                    Severity::Info,\n                    format!(\"README missing section: {}\", description),\n                ));\n            }\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for LICENSE file\n///\n/// Verifies that a LICENSE file exists. For enterprise preset, LICENSE is optional.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `config` - The configuration (used to check preset)\n///\n/// # Returns\n///\n/// A vector of findings for LICENSE issues\nasync fn check_license(scanner: \u0026Scanner, config: \u0026Config) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    let license_files = [\"LICENSE\", \"LICENSE.md\", \"LICENSE.txt\", \"COPYING\"];\n    let has_license = license_files.iter().any(|f| scanner.file_exists(f));\n\n    // For enterprise preset, LICENSE is optional\n    if config.preset == \"enterprise\" \u0026\u0026 !has_license {\n        return Ok(findings);\n    }\n\n    if !has_license {\n        findings.push(\n            Finding::new(\n                \"DOC004\",\n                \"docs\",\n                Severity::Critical,\n                \"LICENSE file is missing\",\n            )\n            .with_description(\n                \"A LICENSE file is required for open source projects to define how others can use your code.\"\n            )\n            .with_remediation(\n                \"Add a LICENSE file with an appropriate open source license (MIT, Apache-2.0, GPL-3.0, etc.).\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check for CONTRIBUTING file\n///\n/// Verifies that a CONTRIBUTING file exists to guide contributors.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for CONTRIBUTING issues\nasync fn check_contributing(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    let contributing_files = [\"CONTRIBUTING.md\", \"CONTRIBUTING\", \".github/CONTRIBUTING.md\"];\n    let has_contributing = contributing_files.iter().any(|f| scanner.file_exists(f));\n\n    if !has_contributing {\n        findings.push(\n            Finding::new(\n                \"DOC005\",\n                \"docs\",\n                Severity::Warning,\n                \"CONTRIBUTING file is missing\",\n            )\n            .with_description(\n                \"A CONTRIBUTING file helps potential contributors understand how to participate in your project.\"\n            )\n            .with_remediation(\n                \"Create a CONTRIBUTING.md file with contribution guidelines, code style, and pull request process.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check for CODE_OF_CONDUCT file\n///\n/// Verifies that a CODE_OF_CONDUCT file exists to establish community standards.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for CODE_OF_CONDUCT issues\nasync fn check_code_of_conduct(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    let coc_files = [\n        \"CODE_OF_CONDUCT.md\",\n        \"CODE_OF_CONDUCT\",\n        \".github/CODE_OF_CONDUCT.md\",\n    ];\n    let has_coc = coc_files.iter().any(|f| scanner.file_exists(f));\n\n    if !has_coc {\n        findings.push(\n            Finding::new(\n                \"DOC006\",\n                \"docs\",\n                Severity::Warning,\n                \"CODE_OF_CONDUCT file is missing\",\n            )\n            .with_description(\n                \"A Code of Conduct establishes expectations for behavior and helps create a welcoming community.\"\n            )\n            .with_remediation(\n                \"Add a CODE_OF_CONDUCT.md file. Consider using the Contributor Covenant as a starting point.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check for SECURITY policy file\n///\n/// Verifies that a SECURITY.md file exists for reporting vulnerabilities.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for SECURITY policy issues\nasync fn check_security(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    let security_files = [\"SECURITY.md\", \".github/SECURITY.md\"];\n    let has_security = security_files.iter().any(|f| scanner.file_exists(f));\n\n    if !has_security {\n        findings.push(\n            Finding::new(\n                \"DOC007\",\n                \"docs\",\n                Severity::Warning,\n                \"SECURITY policy file is missing\",\n            )\n            .with_description(\n                \"A SECURITY.md file tells users how to report security vulnerabilities responsibly.\"\n            )\n            .with_remediation(\n                \"Create a SECURITY.md file with instructions for reporting security issues.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::Config;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_readme_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_readme(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC001\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_readme_too_short() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let readme = root.join(\"README.md\");\n\n        fs::write(\u0026readme, \"# Test\\n\\nShort.\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_readme(\u0026scanner).await.unwrap();\n\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC002\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_readme_missing_sections() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let readme = root.join(\"README.md\");\n\n        fs::write(\u0026readme, \"# Project\\n\\nDescription here.\\n\\nMore content.\\n\\nEven more.\\n\\nAnd more.\\n\\nAnd more.\\n\\nAnd more.\\n\\nAnd more.\\n\\nAnd more.\\n\\nAnd more.\\n\\nAnd more.\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_readme(\u0026scanner).await.unwrap();\n\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC003\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_license_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config::default();\n        let findings = check_license(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC004\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_license_enterprise_optional() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config {\n            preset: \"enterprise\".to_string(),\n            ..Default::default()\n        };\n        let findings = check_license(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(findings.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_check_contributing_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_contributing(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC005\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_code_of_conduct_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_code_of_conduct(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC006\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_security_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_security(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"DOC007\"));\n    }\n}\n","traces":[{"line":23,"address":[278160],"length":1,"stats":{"Line":2}},{"line":37,"address":[356739],"length":1,"stats":{"Line":30}},{"line":38,"address":[480644],"length":1,"stats":{"Line":6}},{"line":41,"address":[480734,480660],"length":1,"stats":{"Line":12}},{"line":42,"address":[264927,265010],"length":1,"stats":{"Line":6}},{"line":46,"address":[481313,480740],"length":1,"stats":{"Line":12}},{"line":47,"address":[574444,574302],"length":1,"stats":{"Line":4}},{"line":51,"address":[481319,481909],"length":1,"stats":{"Line":8}},{"line":52,"address":[574320,574484],"length":1,"stats":{"Line":4}},{"line":56,"address":[481915,482467],"length":1,"stats":{"Line":8}},{"line":57,"address":[482626,482508,483280,480445],"length":1,"stats":{"Line":4}},{"line":61,"address":[482473,483025],"length":1,"stats":{"Line":5}},{"line":62,"address":[32287,32405,29583],"length":1,"stats":{"Line":5}},{"line":65,"address":[483035],"length":1,"stats":{"Line":4}},{"line":81,"address":[356592,356600],"length":1,"stats":{"Line":9}},{"line":82,"address":[474221],"length":1,"stats":{"Line":2}},{"line":84,"address":[474297],"length":1,"stats":{"Line":2}},{"line":85,"address":[476881,476864,474405,474497],"length":1,"stats":{"Line":10}},{"line":87,"address":[474548],"length":1,"stats":{"Line":3}},{"line":88,"address":[474738],"length":1,"stats":{"Line":2}},{"line":89,"address":[474560,474668],"length":1,"stats":{"Line":4}},{"line":92,"address":[474552],"length":1,"stats":{"Line":2}},{"line":102,"address":[474768],"length":1,"stats":{"Line":2}},{"line":106,"address":[474638,475056,474965],"length":1,"stats":{"Line":6}},{"line":107,"address":[475104,475183],"length":1,"stats":{"Line":4}},{"line":109,"address":[475227],"length":1,"stats":{"Line":2}},{"line":110,"address":[475855],"length":1,"stats":{"Line":2}},{"line":111,"address":[475757],"length":1,"stats":{"Line":2}},{"line":114,"address":[475622],"length":1,"stats":{"Line":2}},{"line":115,"address":[475630],"length":1,"stats":{"Line":2}},{"line":124,"address":[475404],"length":1,"stats":{"Line":2}},{"line":125,"address":[475242],"length":1,"stats":{"Line":2}},{"line":126,"address":[475296],"length":1,"stats":{"Line":2}},{"line":127,"address":[475350],"length":1,"stats":{"Line":2}},{"line":130,"address":[475500,475890,475979],"length":1,"stats":{"Line":6}},{"line":131,"address":[476222,476092],"length":1,"stats":{"Line":5}},{"line":132,"address":[25651],"length":1,"stats":{"Line":4}},{"line":135,"address":[25516],"length":1,"stats":{"Line":3}},{"line":136,"address":[25524],"length":1,"stats":{"Line":4}},{"line":142,"address":[25814],"length":1,"stats":{"Line":4}},{"line":157,"address":[356621,356608],"length":1,"stats":{"Line":8}},{"line":158,"address":[477024],"length":1,"stats":{"Line":2}},{"line":160,"address":[26217],"length":1,"stats":{"Line":2}},{"line":161,"address":[477282,477873,477199,477856],"length":1,"stats":{"Line":10}},{"line":164,"address":[26455,26504],"length":1,"stats":{"Line":5}},{"line":165,"address":[477390],"length":1,"stats":{"Line":2}},{"line":168,"address":[477367],"length":1,"stats":{"Line":2}},{"line":169,"address":[477786],"length":1,"stats":{"Line":2}},{"line":170,"address":[26662,26836],"length":1,"stats":{"Line":4}},{"line":173,"address":[477534],"length":1,"stats":{"Line":2}},{"line":185,"address":[477612],"length":1,"stats":{"Line":2}},{"line":199,"address":[278112,278120],"length":1,"stats":{"Line":8}},{"line":200,"address":[477994],"length":1,"stats":{"Line":2}},{"line":202,"address":[478067],"length":1,"stats":{"Line":2}},{"line":203,"address":[478142,478225,478657,478640],"length":1,"stats":{"Line":8}},{"line":205,"address":[27396],"length":1,"stats":{"Line":2}},{"line":206,"address":[478575],"length":1,"stats":{"Line":2}},{"line":207,"address":[27408,27625],"length":1,"stats":{"Line":4}},{"line":210,"address":[478280],"length":1,"stats":{"Line":2}},{"line":222,"address":[27486],"length":1,"stats":{"Line":2}},{"line":236,"address":[478807,478718,478785,478688,479391],"length":1,"stats":{"Line":8}},{"line":237,"address":[478778],"length":1,"stats":{"Line":2}},{"line":239,"address":[27971],"length":1,"stats":{"Line":2}},{"line":244,"address":[479441,478926,479009,479424],"length":1,"stats":{"Line":8}},{"line":246,"address":[28180],"length":1,"stats":{"Line":2}},{"line":247,"address":[479359],"length":1,"stats":{"Line":2}},{"line":248,"address":[479072,479289],"length":1,"stats":{"Line":4}},{"line":251,"address":[479064],"length":1,"stats":{"Line":2}},{"line":263,"address":[479150],"length":1,"stats":{"Line":2}},{"line":277,"address":[28689,28592,28711,28622,29268],"length":1,"stats":{"Line":8}},{"line":278,"address":[479562],"length":1,"stats":{"Line":2}},{"line":280,"address":[479635],"length":1,"stats":{"Line":2}},{"line":281,"address":[479683,480192,480209,479766],"length":1,"stats":{"Line":8}},{"line":283,"address":[479817],"length":1,"stats":{"Line":2}},{"line":284,"address":[480116],"length":1,"stats":{"Line":2}},{"line":285,"address":[480046,479829],"length":1,"stats":{"Line":4}},{"line":288,"address":[479821],"length":1,"stats":{"Line":2}},{"line":300,"address":[479907],"length":1,"stats":{"Line":2}}],"covered":78,"coverable":78},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","files.rs"],"content":"//! File-related rules\n//!\n//! This module provides rules for checking repository files, including:\n//! - Large files that should use Git LFS\n//! - .gitignore configuration and recommended entries\n//! - Temporary files that shouldn't be committed\n\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for checking repository files\npub struct FilesRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for FilesRules {\n    /// Get the category name\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"files\"\n    }\n\n    /// Run all file-related rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for file-related issues\n    async fn run(\u0026self, scanner: \u0026Scanner, config: \u0026Config) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n        let mut findings = Vec::new();\n\n        // Check for large files\n        if config.is_rule_enabled(\"files/large\") {\n            findings.extend(check_large_files(scanner).await?);\n        }\n\n        // Check .gitignore\n        if config.is_rule_enabled(\"files/gitignore\") {\n            findings.extend(check_gitignore(scanner).await?);\n        }\n\n        // Check for temporary files\n        if config.is_rule_enabled(\"files/temp\") {\n            findings.extend(check_temp_files(scanner).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for files larger than the recommended threshold\n///\n/// Large files can slow down repository operations and should use Git LFS.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for large files\nasync fn check_large_files(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // 10MB threshold\n    const LARGE_FILE_THRESHOLD: u64 = 10 * 1024 * 1024;\n\n    for file in scanner.files_larger_than(LARGE_FILE_THRESHOLD) {\n        let size_mb = file.size as f64 / 1024.0 / 1024.0;\n\n        findings.push(\n            Finding::new(\n                \"FILE001\",\n                \"files\",\n                Severity::Warning,\n                format!(\"Large file detected ({:.1} MB)\", size_mb),\n            )\n            .with_location(\u0026file.path)\n            .with_description(\n                \"Large files can slow down repository operations and increase clone times.\",\n            )\n            .with_remediation(\n                \"Consider using Git LFS (Large File Storage) for binary or large files.\",\n            ),\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check .gitignore file existence and recommended entries\n///\n/// Verifies that .gitignore exists and contains recommended patterns\n/// to prevent committing unwanted files.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for .gitignore issues\nasync fn check_gitignore(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // Check if .gitignore exists\n    if !scanner.file_exists(\".gitignore\") {\n        findings.push(\n            Finding::new(\n                \"FILE002\",\n                \"files\",\n                Severity::Warning,\n                \".gitignore file is missing\",\n            )\n            .with_description(\n                \"A .gitignore file helps prevent accidentally committing unwanted files.\",\n            )\n            .with_remediation(\n                \"Create a .gitignore file with appropriate patterns for your project type.\",\n            ),\n        );\n        return Ok(findings);\n    }\n\n    // Check for recommended entries\n    let gitignore_content = scanner.read_file(\".gitignore\").unwrap_or_else(|e| {\n        tracing::warn!(\"Failed to read .gitignore: {}\", e);\n        String::new()\n    });\n    let recommended_entries = [\n        (\".env\", \"Environment files\"),\n        (\"*.key\", \"Private keys\"),\n        (\"*.pem\", \"Certificates\"),\n        (\"node_modules\", \"Node.js dependencies\"),\n        (\".DS_Store\", \"macOS metadata\"),\n    ];\n\n    for (pattern, description) in recommended_entries {\n        if !gitignore_content.contains(pattern) {\n            findings.push(\n                Finding::new(\n                    \"FILE003\",\n                    \"files\",\n                    Severity::Info,\n                    format!(\".gitignore missing recommended entry: {}\", pattern),\n                )\n                .with_description(format!(\n                    \"Adding '{}' to .gitignore helps prevent committing {}.\",\n                    pattern,\n                    description.to_lowercase()\n                )),\n            );\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for temporary files that shouldn't be committed\n///\n/// Detects common temporary file patterns like .log, .tmp, .swp, etc.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for temporary files\nasync fn check_temp_files(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    let temp_patterns = [\"*.log\", \"*.tmp\", \"*.temp\", \"*~\", \"*.swp\", \"*.swo\", \"*.bak\"];\n\n    for pattern in temp_patterns {\n        for file in scanner.files_matching_pattern(pattern) {\n            findings.push(\n                Finding::new(\n                    \"FILE004\",\n                    \"files\",\n                    Severity::Warning,\n                    \"Temporary file found in repository\",\n                )\n                .with_location(\u0026file.path)\n                .with_description(\"Temporary files should not be committed to version control.\")\n                .with_remediation(\"Remove the file and add the pattern to .gitignore.\"),\n            );\n        }\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_large_files_detects_large_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let large_file = root.join(\"large.bin\");\n\n        let large_content = vec![0u8; 11 * 1024 * 1024];\n        fs::write(\u0026large_file, large_content).unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_large_files(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"FILE001\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_gitignore_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_gitignore(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"FILE002\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_gitignore_missing_recommended_entries() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let gitignore = root.join(\".gitignore\");\n\n        fs::write(\u0026gitignore, \"node_modules/\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_gitignore(\u0026scanner).await.unwrap();\n\n        assert!(findings.iter().any(|f| f.rule_id == \"FILE003\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_temp_files_detects_tmp() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let tmp_file = root.join(\"temp.tmp\");\n\n        fs::write(\u0026tmp_file, \"temporary content\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_temp_files(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"FILE004\"));\n    }\n}\n","traces":[{"line":20,"address":[264800],"length":1,"stats":{"Line":2}},{"line":34,"address":[773337,773421,773072,773681,773193,774823,774281,773107],"length":1,"stats":{"Line":17}},{"line":35,"address":[773437],"length":1,"stats":{"Line":2}},{"line":38,"address":[773453,773527],"length":1,"stats":{"Line":4}},{"line":39,"address":[773220,773568,773707,774260],"length":1,"stats":{"Line":2}},{"line":43,"address":[774106,773533],"length":1,"stats":{"Line":4}},{"line":44,"address":[332173,331379,330470,331519],"length":1,"stats":{"Line":2}},{"line":48,"address":[774112,774686],"length":1,"stats":{"Line":4}},{"line":49,"address":[332060,330488,332178],"length":1,"stats":{"Line":2}},{"line":52,"address":[774696],"length":1,"stats":{"Line":3}},{"line":67,"address":[324830,324800,324897,325923,324919],"length":1,"stats":{"Line":8}},{"line":68,"address":[767658],"length":1,"stats":{"Line":2}},{"line":73,"address":[767927,767803,767749],"length":1,"stats":{"Line":6}},{"line":74,"address":[767987],"length":1,"stats":{"Line":2}},{"line":76,"address":[768659],"length":1,"stats":{"Line":2}},{"line":77,"address":[768498],"length":1,"stats":{"Line":2}},{"line":80,"address":[768051],"length":1,"stats":{"Line":2}},{"line":81,"address":[768248,768059],"length":1,"stats":{"Line":4}},{"line":93,"address":[325341],"length":1,"stats":{"Line":2}},{"line":108,"address":[765104,765112],"length":1,"stats":{"Line":8}},{"line":109,"address":[768842],"length":1,"stats":{"Line":2}},{"line":112,"address":[769001,768928],"length":1,"stats":{"Line":6}},{"line":113,"address":[769190],"length":1,"stats":{"Line":2}},{"line":114,"address":[769015,769120],"length":1,"stats":{"Line":4}},{"line":117,"address":[769007],"length":1,"stats":{"Line":2}},{"line":127,"address":[769217],"length":1,"stats":{"Line":2}},{"line":131,"address":[771694,769380,771104,769090,771688],"length":1,"stats":{"Line":4}},{"line":132,"address":[771196,771403,771126],"length":1,"stats":{"Line":0}},{"line":133,"address":[771393],"length":1,"stats":{"Line":0}},{"line":135,"address":[769680],"length":1,"stats":{"Line":2}},{"line":136,"address":[326642],"length":1,"stats":{"Line":2}},{"line":137,"address":[769464],"length":1,"stats":{"Line":2}},{"line":138,"address":[769518],"length":1,"stats":{"Line":2}},{"line":139,"address":[769572],"length":1,"stats":{"Line":2}},{"line":140,"address":[326858],"length":1,"stats":{"Line":2}},{"line":143,"address":[770025,769939,769873],"length":1,"stats":{"Line":6}},{"line":144,"address":[327528,327370],"length":1,"stats":{"Line":4}},{"line":145,"address":[771005],"length":1,"stats":{"Line":2}},{"line":146,"address":[328190,327743],"length":1,"stats":{"Line":4}},{"line":149,"address":[770341],"length":1,"stats":{"Line":2}},{"line":150,"address":[770349,770411],"length":1,"stats":{"Line":4}},{"line":152,"address":[770582,770679],"length":1,"stats":{"Line":4}},{"line":155,"address":[327892],"length":1,"stats":{"Line":2}},{"line":161,"address":[770173],"length":1,"stats":{"Line":2}},{"line":175,"address":[264784,264792],"length":1,"stats":{"Line":8}},{"line":176,"address":[329034],"length":1,"stats":{"Line":2}},{"line":178,"address":[771875],"length":1,"stats":{"Line":2}},{"line":180,"address":[772328,772230,772061],"length":1,"stats":{"Line":6}},{"line":181,"address":[772741,772605,772420],"length":1,"stats":{"Line":6}},{"line":182,"address":[772995],"length":1,"stats":{"Line":2}},{"line":183,"address":[772809,772918],"length":1,"stats":{"Line":4}},{"line":186,"address":[772801],"length":1,"stats":{"Line":2}},{"line":196,"address":[772450],"length":1,"stats":{"Line":2}}],"covered":51,"coverable":53},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","mod.rs"],"content":"//! Rule categories\n\npub mod custom;\npub mod docs;\npub mod files;\npub mod quality;\npub mod secrets;\npub mod security;\npub mod workflows;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","quality.rs"],"content":"//! Code quality rules\n//!\n//! This module provides rules for checking code quality aspects, including:\n//! - Test files and directories\n//! - Linting configuration\n//! - Editor configuration files\n\nuse crate::error::RepoLensError;\n\nuse crate::config::Config;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for checking code quality\npub struct QualityRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for QualityRules {\n    /// Get the category name\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"quality\"\n    }\n\n    /// Run all quality-related rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for quality issues\n    async fn run(\u0026self, scanner: \u0026Scanner, config: \u0026Config) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n        let mut findings = Vec::new();\n\n        // Check for tests\n        if config.is_rule_enabled(\"quality/tests\") {\n            findings.extend(check_tests(scanner).await?);\n        }\n\n        // Check for linting configuration\n        if config.is_rule_enabled(\"quality/linting\") {\n            findings.extend(check_linting(scanner).await?);\n        }\n\n        // Check for editor configuration\n        if config.is_rule_enabled(\"files/editorconfig\") {\n            findings.extend(check_editorconfig(scanner).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for test files and test configuration\n///\n/// Verifies that the repository has tests and appropriate test configuration.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for test-related issues\nasync fn check_tests(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // Check for test directories\n    let test_dirs = [\"test\", \"tests\", \"__tests__\", \"spec\", \"specs\"];\n    let has_test_dir = test_dirs.iter().any(|d| scanner.directory_exists(d));\n\n    // Check for test files\n    let test_file_patterns = [\"*.test.*\", \"*.spec.*\", \"*_test.*\", \"*Test.*\"];\n    let has_test_files = test_file_patterns\n        .iter()\n        .any(|p| !scanner.files_matching_pattern(p).is_empty());\n\n    if !has_test_dir \u0026\u0026 !has_test_files {\n        findings.push(\n            Finding::new(\n                \"QUALITY001\",\n                \"quality\",\n                Severity::Info,\n                \"No tests detected\",\n            )\n            .with_description(\n                \"Tests are important for ensuring code quality and catching regressions.\"\n            )\n            .with_remediation(\n                \"Add tests to your project. Consider using a testing framework appropriate for your language.\"\n            )\n        );\n    }\n\n    // Check if package.json has test script\n    if scanner.file_exists(\"package.json\") {\n        if let Ok(content) = scanner.read_file(\"package.json\") {\n            if !content.contains(r#\"\"test\"\"#) || content.contains(r#\"\"test\": \"echo\"#) {\n                findings.push(\n                    Finding::new(\n                        \"QUALITY002\",\n                        \"quality\",\n                        Severity::Info,\n                        \"No test script defined in package.json\",\n                    )\n                    .with_description(\n                        \"A 'test' script in package.json enables running tests with 'npm test'.\",\n                    ),\n                );\n            }\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for linting configuration files\n///\n/// Verifies that appropriate linting tools are configured based on\n/// the project type (JavaScript, Python, Ruby, Go, Rust, etc.).\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for missing linting configuration\nasync fn check_linting(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // Linting config files by language/tool\n    let linting_configs = [\n        // JavaScript/TypeScript\n        (\".eslintrc\", \"ESLint\"),\n        (\".eslintrc.js\", \"ESLint\"),\n        (\".eslintrc.json\", \"ESLint\"),\n        (\".eslintrc.yml\", \"ESLint\"),\n        (\"eslint.config.js\", \"ESLint\"),\n        (\"biome.json\", \"Biome\"),\n        // Formatting\n        (\".prettierrc\", \"Prettier\"),\n        (\".prettierrc.js\", \"Prettier\"),\n        (\".prettierrc.json\", \"Prettier\"),\n        // Python\n        (\"pyproject.toml\", \"Python tooling\"),\n        (\".flake8\", \"Flake8\"),\n        (\"setup.cfg\", \"Python tooling\"),\n        (\".pylintrc\", \"Pylint\"),\n        (\"ruff.toml\", \"Ruff\"),\n        // Ruby\n        (\".rubocop.yml\", \"RuboCop\"),\n        // Go\n        (\".golangci.yml\", \"golangci-lint\"),\n        (\".golangci.yaml\", \"golangci-lint\"),\n        // Rust\n        (\"rustfmt.toml\", \"rustfmt\"),\n        (\".rustfmt.toml\", \"rustfmt\"),\n        (\"clippy.toml\", \"Clippy\"),\n    ];\n\n    // Detect project type\n    let is_js_project = scanner.file_exists(\"package.json\");\n    let is_python_project =\n        scanner.file_exists(\"pyproject.toml\") || scanner.file_exists(\"requirements.txt\");\n    let is_ruby_project = scanner.file_exists(\"Gemfile\");\n    let is_go_project = scanner.file_exists(\"go.mod\");\n    let is_rust_project = scanner.file_exists(\"Cargo.toml\");\n\n    let has_linting = linting_configs.iter().any(|(f, _)| scanner.file_exists(f));\n\n    if !has_linting\n        \u0026\u0026 (is_js_project\n            || is_python_project\n            || is_ruby_project\n            || is_go_project\n            || is_rust_project)\n    {\n        let suggestion = if is_js_project {\n            \"ESLint for linting and Prettier for formatting\"\n        } else if is_python_project {\n            \"Ruff or Flake8 for linting\"\n        } else if is_ruby_project {\n            \"RuboCop for linting\"\n        } else if is_go_project {\n            \"golangci-lint for linting\"\n        } else {\n            \"Clippy for linting and rustfmt for formatting\"\n        };\n\n        findings.push(\n            Finding::new(\n                \"QUALITY003\",\n                \"quality\",\n                Severity::Info,\n                \"No linting configuration detected\",\n            )\n            .with_description(\n                \"Linting tools help maintain consistent code style and catch potential issues.\",\n            )\n            .with_remediation(format!(\"Consider adding {} to your project.\", suggestion)),\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check for .editorconfig file\n///\n/// Verifies that an .editorconfig file exists to maintain consistent\n/// coding styles across editors and IDEs.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for missing .editorconfig\nasync fn check_editorconfig(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    if !scanner.file_exists(\".editorconfig\") {\n        findings.push(\n            Finding::new(\n                \"QUALITY004\",\n                \"quality\",\n                Severity::Info,\n                \".editorconfig file is missing\",\n            )\n            .with_description(\n                \"EditorConfig helps maintain consistent coding styles across different editors and IDEs.\"\n            )\n            .with_remediation(\n                \"Create a .editorconfig file to define coding style preferences.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_tests_no_tests_detected() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_tests(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"QUALITY001\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_tests_package_json_no_test_script() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let package_json = root.join(\"package.json\");\n\n        // Create package.json without test script or with echo test\n        fs::write(\n            \u0026package_json,\n            r#\"{\"name\": \"test\", \"version\": \"1.0.0\", \"scripts\": {\"test\": \"echo \\\"No tests\\\"\"}}\"#,\n        )\n        .unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_tests(\u0026scanner).await.unwrap();\n\n        // Should find QUALITY002 because test script is just \"echo\"\n        assert!(findings.iter().any(|f| f.rule_id == \"QUALITY002\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_linting_no_config() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let package_json = root.join(\"package.json\");\n\n        fs::write(\u0026package_json, r#\"{\"name\": \"test\"}\"#).unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_linting(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"QUALITY003\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_editorconfig_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_editorconfig(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"QUALITY004\"));\n    }\n}\n","traces":[{"line":21,"address":[866384],"length":1,"stats":{"Line":2}},{"line":35,"address":[429827],"length":1,"stats":{"Line":17}},{"line":36,"address":[104429],"length":1,"stats":{"Line":3}},{"line":39,"address":[104519,104445],"length":1,"stats":{"Line":6}},{"line":40,"address":[104560,104212,105252,104699],"length":1,"stats":{"Line":4}},{"line":44,"address":[104525,105098],"length":1,"stats":{"Line":5}},{"line":45,"address":[104230,105139,105933,105279],"length":1,"stats":{"Line":3}},{"line":49,"address":[105678,105104],"length":1,"stats":{"Line":5}},{"line":50,"address":[104248,105938,105820],"length":1,"stats":{"Line":2}},{"line":53,"address":[105688],"length":1,"stats":{"Line":3}},{"line":68,"address":[866336,866344],"length":1,"stats":{"Line":11}},{"line":69,"address":[98362],"length":1,"stats":{"Line":3}},{"line":72,"address":[98438],"length":1,"stats":{"Line":3}},{"line":73,"address":[98573,100064,98662,100081],"length":1,"stats":{"Line":14}},{"line":76,"address":[922822],"length":1,"stats":{"Line":4}},{"line":77,"address":[98818],"length":1,"stats":{"Line":4}},{"line":79,"address":[100112,100129],"length":1,"stats":{"Line":5}},{"line":81,"address":[923032],"length":1,"stats":{"Line":2}},{"line":82,"address":[99113],"length":1,"stats":{"Line":3}},{"line":83,"address":[98973],"length":1,"stats":{"Line":3}},{"line":86,"address":[98965],"length":1,"stats":{"Line":2}},{"line":99,"address":[99152,100009,98939],"length":1,"stats":{"Line":6}},{"line":100,"address":[99329,99391,99482],"length":1,"stats":{"Line":6}},{"line":101,"address":[99530,99601,99724],"length":1,"stats":{"Line":6}},{"line":102,"address":[99849],"length":1,"stats":{"Line":2}},{"line":103,"address":[99814,99646],"length":1,"stats":{"Line":4}},{"line":106,"address":[99638],"length":1,"stats":{"Line":2}},{"line":117,"address":[99170],"length":1,"stats":{"Line":2}},{"line":132,"address":[866360,866352],"length":1,"stats":{"Line":8}},{"line":133,"address":[100354],"length":1,"stats":{"Line":2}},{"line":136,"address":[101449],"length":1,"stats":{"Line":2}},{"line":138,"address":[100432],"length":1,"stats":{"Line":2}},{"line":139,"address":[100486],"length":1,"stats":{"Line":2}},{"line":140,"address":[100533],"length":1,"stats":{"Line":2}},{"line":141,"address":[100580],"length":1,"stats":{"Line":2}},{"line":142,"address":[100627],"length":1,"stats":{"Line":2}},{"line":143,"address":[100674],"length":1,"stats":{"Line":2}},{"line":145,"address":[924840],"length":1,"stats":{"Line":2}},{"line":146,"address":[924894],"length":1,"stats":{"Line":2}},{"line":147,"address":[924941],"length":1,"stats":{"Line":2}},{"line":149,"address":[924988],"length":1,"stats":{"Line":2}},{"line":150,"address":[100930],"length":1,"stats":{"Line":2}},{"line":151,"address":[925096],"length":1,"stats":{"Line":2}},{"line":152,"address":[101031],"length":1,"stats":{"Line":2}},{"line":153,"address":[925197],"length":1,"stats":{"Line":2}},{"line":155,"address":[101139],"length":1,"stats":{"Line":2}},{"line":157,"address":[101193],"length":1,"stats":{"Line":2}},{"line":158,"address":[101247],"length":1,"stats":{"Line":2}},{"line":160,"address":[101294],"length":1,"stats":{"Line":2}},{"line":161,"address":[101348],"length":1,"stats":{"Line":2}},{"line":162,"address":[925507],"length":1,"stats":{"Line":2}},{"line":166,"address":[102155,102086],"length":1,"stats":{"Line":4}},{"line":167,"address":[926276],"length":1,"stats":{"Line":2}},{"line":169,"address":[102253],"length":1,"stats":{"Line":2}},{"line":170,"address":[926406],"length":1,"stats":{"Line":2}},{"line":171,"address":[926447],"length":1,"stats":{"Line":2}},{"line":173,"address":[103424,103440,102381],"length":1,"stats":{"Line":6}},{"line":175,"address":[102464],"length":1,"stats":{"Line":2}},{"line":176,"address":[926584],"length":1,"stats":{"Line":2}},{"line":177,"address":[102629],"length":1,"stats":{"Line":3}},{"line":178,"address":[926765],"length":1,"stats":{"Line":2}},{"line":179,"address":[102663],"length":1,"stats":{"Line":4}},{"line":180,"address":[102673],"length":1,"stats":{"Line":3}},{"line":182,"address":[102721,102643],"length":1,"stats":{"Line":4}},{"line":183,"address":[926806],"length":1,"stats":{"Line":2}},{"line":184,"address":[926794,927039,926875],"length":1,"stats":{"Line":0}},{"line":185,"address":[926848],"length":1,"stats":{"Line":0}},{"line":186,"address":[102730,102895,102805],"length":1,"stats":{"Line":0}},{"line":187,"address":[926890],"length":1,"stats":{"Line":0}},{"line":188,"address":[102772,102863,102834],"length":1,"stats":{"Line":0}},{"line":189,"address":[102836],"length":1,"stats":{"Line":0}},{"line":191,"address":[102807],"length":1,"stats":{"Line":0}},{"line":194,"address":[103327],"length":1,"stats":{"Line":2}},{"line":195,"address":[103280,102967,103072],"length":1,"stats":{"Line":6}},{"line":198,"address":[927071],"length":1,"stats":{"Line":2}},{"line":204,"address":[103142,103115,103319,103367,103037],"length":1,"stats":{"Line":4}},{"line":208,"address":[102490],"length":1,"stats":{"Line":2}},{"line":223,"address":[927614,928140,927584,927703,927681],"length":1,"stats":{"Line":8}},{"line":224,"address":[103562],"length":1,"stats":{"Line":2}},{"line":226,"address":[103701,103640],"length":1,"stats":{"Line":4}},{"line":227,"address":[103999],"length":1,"stats":{"Line":2}},{"line":228,"address":[103715,103932],"length":1,"stats":{"Line":4}},{"line":231,"address":[103707],"length":1,"stats":{"Line":2}},{"line":243,"address":[103793],"length":1,"stats":{"Line":2}}],"covered":77,"coverable":84},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","secrets.rs"],"content":"//! Secrets detection rules\n//!\n//! This module provides rules for detecting exposed secrets and credentials\n//! in repository files. It checks for:\n//! - Hardcoded secrets in source files (API keys, tokens, passwords)\n//! - Sensitive files (private keys, certificates, credentials)\n//! - Environment files (.env) that should not be committed\n\nuse rayon::prelude::*;\n\nuse crate::config::Config;\nuse crate::error::RepoLensError;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::patterns::SECRET_PATTERNS;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for detecting secrets and credentials\npub struct SecretsRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for SecretsRules {\n    /// Get the category name\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"secrets\"\n    }\n\n    /// Run all secrets detection rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for detected secrets\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the scan fails\n    async fn run(\u0026self, scanner: \u0026Scanner, config: \u0026Config) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n        let mut findings = Vec::new();\n\n        // Check for hardcoded secrets in source files\n        if config.is_rule_enabled(\"secrets/hardcoded\") {\n            findings.extend(check_hardcoded_secrets(scanner, config).await?);\n        }\n\n        // Check for sensitive files\n        if config.is_rule_enabled(\"secrets/files\") {\n            findings.extend(check_sensitive_files(scanner, config).await?);\n        }\n\n        // Check for .env files\n        if config.is_rule_enabled(\"secrets/env\") {\n            findings.extend(check_env_files(scanner, config).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for hardcoded secrets in source files\n///\n/// Scans files with common source code extensions for patterns that indicate\n/// hardcoded secrets like API keys, tokens, and passwords.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `config` - The configuration with ignore patterns\n///\n/// # Returns\n///\n/// A vector of findings for detected secrets\nasync fn check_hardcoded_secrets(\n    scanner: \u0026Scanner,\n    config: \u0026Config,\n) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // File extensions to scan\n    let extensions = [\n        \"js\", \"ts\", \"jsx\", \"tsx\", \"py\", \"rb\", \"php\", \"java\", \"go\", \"rs\", \"cpp\", \"c\", \"yml\", \"yaml\",\n        \"json\", \"toml\", \"env\", \"config\", \"conf\", \"sql\", \"sh\", \"bash\",\n    ];\n\n    let files: Vec\u003c_\u003e = scanner\n        .files_with_extensions(\u0026extensions)\n        .into_iter()\n        .filter(|file| !config.should_ignore_file(\u0026file.path))\n        .map(|file| file.path.clone())\n        .collect();\n\n    // Process files in parallel\n    let file_findings: Vec\u003cVec\u003cFinding\u003e\u003e = files\n        .par_iter()\n        .filter_map(|file_path| {\n            let content = match scanner.read_file(file_path) {\n                Ok(c) =\u003e c,\n                Err(e) =\u003e {\n                    tracing::warn!(\"Failed to read file {}: {}\", file_path, e);\n                    return None;\n                }\n            };\n\n            match check_file_for_secrets(file_path, \u0026content, config) {\n                Ok(f) =\u003e Some(f),\n                Err(e) =\u003e {\n                    tracing::warn!(\"Error checking file {}: {}\", file_path, e);\n                    None\n                }\n            }\n        })\n        .collect();\n\n    // Flatten results\n    for file_finding in file_findings {\n        findings.extend(file_finding);\n    }\n\n    Ok(findings)\n}\n\n/// Check a single file for secrets\n///\n/// # Arguments\n///\n/// * `file_path` - Path to the file\n/// * `content` - File content\n/// * `config` - Configuration with ignore patterns\n///\n/// # Returns\n///\n/// A vector of findings for secrets found in this file\nfn check_file_for_secrets(\n    file_path: \u0026str,\n    content: \u0026str,\n    config: \u0026Config,\n) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    for pattern in SECRET_PATTERNS.iter() {\n        if let Some(captures) = pattern.regex.captures(content) {\n            if config.should_ignore_pattern(file_path) {\n                continue;\n            }\n\n            let line_num = find_line_number(content, \u0026captures)?;\n\n            findings.push(\n                Finding::new(\n                    \"SEC001\",\n                    \"secrets\",\n                    Severity::Critical,\n                    format!(\"{} detected\", pattern.name),\n                )\n                .with_location(format!(\"{}:{}\", file_path, line_num))\n                .with_description(pattern.description.to_string())\n                .with_remediation(\n                    \"Remove the secret and use environment variables or a secrets manager instead.\",\n                ),\n            );\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Find the line number where a regex match occurs\n///\n/// # Arguments\n///\n/// * `content` - File content\n/// * `captures` - Regex captures from the match\n///\n/// # Returns\n///\n/// The line number (1-indexed)\nfn find_line_number(content: \u0026str, captures: \u0026regex::Captures) -\u003e Result\u003cusize, RepoLensError\u003e {\n    let match_start = captures\n        .get(0)\n        .ok_or_else(|| {\n            RepoLensError::Rule(crate::error::RuleError::ExecutionFailed {\n                message: \"No match found in pattern capture\".to_string(),\n            })\n        })?\n        .start();\n\n    Ok(content[..match_start].matches('\\n').count() + 1)\n}\n\n/// Check for sensitive files that should not be in version control\n///\n/// Detects files like private keys, certificates, and credential files\n/// that pose a security risk if committed to the repository.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `_config` - The configuration (currently unused)\n///\n/// # Returns\n///\n/// A vector of findings for detected sensitive files\nasync fn check_sensitive_files(\n    scanner: \u0026Scanner,\n    _config: \u0026Config,\n) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // List of sensitive file patterns\n    let sensitive_patterns = [\n        (\"*.pem\", \"Private key file\"),\n        (\"*.key\", \"Private key file\"),\n        (\"*.p12\", \"PKCS#12 certificate bundle\"),\n        (\"*.pfx\", \"PKCS#12 certificate bundle\"),\n        (\"*.jks\", \"Java keystore\"),\n        (\"id_rsa\", \"SSH private key\"),\n        (\"id_dsa\", \"SSH private key\"),\n        (\"id_ecdsa\", \"SSH private key\"),\n        (\"id_ed25519\", \"SSH private key\"),\n        (\".htpasswd\", \"Apache password file\"),\n        (\"credentials.json\", \"Credentials file\"),\n        (\"service-account.json\", \"Service account credentials\"),\n        (\"secrets.yml\", \"Secrets configuration\"),\n        (\"secrets.yaml\", \"Secrets configuration\"),\n        (\"secrets.json\", \"Secrets configuration\"),\n    ];\n\n    for (pattern, description) in sensitive_patterns {\n        for file in scanner.files_matching_pattern(pattern) {\n            findings.push(\n                Finding::new(\n                    \"SEC002\",\n                    \"secrets\",\n                    Severity::Critical,\n                    format!(\"{} found in repository\", description),\n                )\n                .with_location(\u0026file.path)\n                .with_description(format!(\n                    \"The file '{}' appears to contain sensitive data and should not be committed to version control.\",\n                    file.path\n                ))\n                .with_remediation(\n                    \"Remove the file from the repository and add it to .gitignore. If the file was previously committed, consider rotating any contained credentials.\"\n                )\n            );\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for .env files that should not be committed\n///\n/// Detects environment files that may contain secrets. Example files\n/// (.env.example, .env.template) are allowed.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `_config` - The configuration (currently unused)\n///\n/// # Returns\n///\n/// A vector of findings for detected .env files\nasync fn check_env_files(\n    scanner: \u0026Scanner,\n    _config: \u0026Config,\n) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // Check for .env files (but allow .env.example)\n    let env_patterns = [\n        \".env\",\n        \".env.local\",\n        \".env.production\",\n        \".env.development\",\n        \".env.test\",\n    ];\n\n    for pattern in env_patterns {\n        for file in scanner.files_matching_pattern(pattern) {\n            // Allow example/template files\n            if file.path.contains(\".example\")\n                || file.path.contains(\".template\")\n                || file.path.contains(\".sample\")\n            {\n                continue;\n            }\n\n            findings.push(\n                Finding::new(\n                    \"SEC003\",\n                    \"secrets\",\n                    Severity::Critical,\n                    \"Environment file found in repository\",\n                )\n                .with_location(\u0026file.path)\n                .with_description(\n                    \"Environment files often contain sensitive configuration and secrets that should not be committed.\"\n                )\n                .with_remediation(\n                    \"Add the file to .gitignore and create a .env.example file as a template.\"\n                )\n            );\n        }\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_hardcoded_secrets_detects_api_key() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let config_file = root.join(\"config.js\");\n\n        fs::write(\u0026config_file, \"const apiKey = 'sk_test_1234567890abcdef';\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config::default();\n\n        let findings = check_hardcoded_secrets(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SEC001\"));\n        assert!(findings.iter().any(|f| f.message.contains(\"detected\")));\n    }\n\n    #[tokio::test]\n    async fn test_check_hardcoded_secrets_ignores_ignored_files() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let config_file = root.join(\"config.js\");\n\n        fs::write(\u0026config_file, \"const apiKey = 'sk_test_1234567890abcdef';\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let mut config = Config::default();\n        config.secrets.ignore_files.push(\"config.js\".to_string());\n\n        let findings = check_hardcoded_secrets(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(findings.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_check_sensitive_files_detects_pem() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let key_file = root.join(\"private.pem\");\n\n        fs::write(\u0026key_file, \"-----BEGIN PRIVATE KEY-----\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config::default();\n\n        let findings = check_sensitive_files(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SEC002\"));\n        assert!(findings\n            .iter()\n            .any(|f| f.message.contains(\"Private key file\")));\n    }\n\n    #[tokio::test]\n    async fn test_check_env_files_detects_env() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let env_file = root.join(\".env\");\n\n        fs::write(\u0026env_file, \"API_KEY=secret123\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config::default();\n\n        let findings = check_env_files(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SEC003\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_env_files_allows_example() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let env_example = root.join(\".env.example\");\n\n        fs::write(\u0026env_example, \"API_KEY=your_key_here\").unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config::default();\n\n        let findings = check_env_files(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(findings.is_empty());\n    }\n}\n","traces":[{"line":24,"address":[76544],"length":1,"stats":{"Line":3}},{"line":42,"address":[862819],"length":1,"stats":{"Line":22}},{"line":43,"address":[889709],"length":1,"stats":{"Line":4}},{"line":46,"address":[889799,889725],"length":1,"stats":{"Line":8}},{"line":47,"address":[266095,266049],"length":1,"stats":{"Line":3}},{"line":51,"address":[889805,890394],"length":1,"stats":{"Line":5}},{"line":52,"address":[890435,890591,891261,889510],"length":1,"stats":{"Line":3}},{"line":56,"address":[890400,890990],"length":1,"stats":{"Line":6}},{"line":57,"address":[891132,889528,891266],"length":1,"stats":{"Line":2}},{"line":60,"address":[891000],"length":1,"stats":{"Line":3}},{"line":77,"address":[74208],"length":1,"stats":{"Line":3}},{"line":81,"address":[881416],"length":1,"stats":{"Line":2}},{"line":84,"address":[881502],"length":1,"stats":{"Line":3}},{"line":89,"address":[882174,882110],"length":1,"stats":{"Line":5}},{"line":92,"address":[882848,882862],"length":1,"stats":{"Line":4}},{"line":93,"address":[882947,882912],"length":1,"stats":{"Line":4}},{"line":97,"address":[747879,747968],"length":1,"stats":{"Line":4}},{"line":99,"address":[884300,884306,882976],"length":1,"stats":{"Line":2}},{"line":100,"address":[883023],"length":1,"stats":{"Line":2}},{"line":101,"address":[883171],"length":1,"stats":{"Line":2}},{"line":102,"address":[883124],"length":1,"stats":{"Line":0}},{"line":103,"address":[884630,883140,884367],"length":1,"stats":{"Line":0}},{"line":104,"address":[884598],"length":1,"stats":{"Line":0}},{"line":108,"address":[883344,883235],"length":1,"stats":{"Line":4}},{"line":109,"address":[883526],"length":1,"stats":{"Line":2}},{"line":110,"address":[883442],"length":1,"stats":{"Line":0}},{"line":111,"address":[883672,883490,883934],"length":1,"stats":{"Line":0}},{"line":112,"address":[883913],"length":1,"stats":{"Line":0}},{"line":119,"address":[882532,882398],"length":1,"stats":{"Line":4}},{"line":120,"address":[882796,882601],"length":1,"stats":{"Line":4}},{"line":123,"address":[882646],"length":1,"stats":{"Line":2}},{"line":137,"address":[862236,860464,862112],"length":1,"stats":{"Line":2}},{"line":142,"address":[860536],"length":1,"stats":{"Line":2}},{"line":144,"address":[860573,860643,862212],"length":1,"stats":{"Line":9}},{"line":145,"address":[860963,860835],"length":1,"stats":{"Line":6}},{"line":146,"address":[861204,861092],"length":1,"stats":{"Line":7}},{"line":150,"address":[861281,861236],"length":1,"stats":{"Line":7}},{"line":152,"address":[862042],"length":1,"stats":{"Line":3}},{"line":153,"address":[862007,861960,861550,861832],"length":1,"stats":{"Line":12}},{"line":156,"address":[75199],"length":1,"stats":{"Line":4}},{"line":157,"address":[75207],"length":1,"stats":{"Line":3}},{"line":159,"address":[75902,75652,75397,75424],"length":1,"stats":{"Line":6}},{"line":160,"address":[75695,75775,75878,75668],"length":1,"stats":{"Line":6}},{"line":168,"address":[860859],"length":1,"stats":{"Line":3}},{"line":181,"address":[76032],"length":1,"stats":{"Line":4}},{"line":182,"address":[862320,862423],"length":1,"stats":{"Line":4}},{"line":184,"address":[750560],"length":1,"stats":{"Line":0}},{"line":185,"address":[884989],"length":1,"stats":{"Line":0}},{"line":186,"address":[884957],"length":1,"stats":{"Line":0}},{"line":191,"address":[862583,862665],"length":1,"stats":{"Line":4}},{"line":207,"address":[862704],"length":1,"stats":{"Line":2}},{"line":211,"address":[885187],"length":1,"stats":{"Line":2}},{"line":214,"address":[751637],"length":1,"stats":{"Line":2}},{"line":215,"address":[885260],"length":1,"stats":{"Line":2}},{"line":216,"address":[885314],"length":1,"stats":{"Line":2}},{"line":217,"address":[885361],"length":1,"stats":{"Line":2}},{"line":218,"address":[751031],"length":1,"stats":{"Line":2}},{"line":219,"address":[751078],"length":1,"stats":{"Line":2}},{"line":220,"address":[885516],"length":1,"stats":{"Line":2}},{"line":221,"address":[751186],"length":1,"stats":{"Line":2}},{"line":222,"address":[751233],"length":1,"stats":{"Line":2}},{"line":223,"address":[885664],"length":1,"stats":{"Line":2}},{"line":224,"address":[751327],"length":1,"stats":{"Line":2}},{"line":225,"address":[751381],"length":1,"stats":{"Line":2}},{"line":226,"address":[885819],"length":1,"stats":{"Line":2}},{"line":227,"address":[885873],"length":1,"stats":{"Line":2}},{"line":228,"address":[751543],"length":1,"stats":{"Line":2}},{"line":229,"address":[751590],"length":1,"stats":{"Line":2}},{"line":232,"address":[752141,752286,752200],"length":1,"stats":{"Line":6}},{"line":233,"address":[752394,752715,752579],"length":1,"stats":{"Line":6}},{"line":234,"address":[887693],"length":1,"stats":{"Line":2}},{"line":235,"address":[887347,887611,887658],"length":1,"stats":{"Line":6}},{"line":238,"address":[887159],"length":1,"stats":{"Line":2}},{"line":239,"address":[887167,887247],"length":1,"stats":{"Line":4}},{"line":241,"address":[887443],"length":1,"stats":{"Line":2}},{"line":242,"address":[887451,887511],"length":1,"stats":{"Line":4}},{"line":253,"address":[886808],"length":1,"stats":{"Line":2}},{"line":269,"address":[862736],"length":1,"stats":{"Line":3}},{"line":273,"address":[753529],"length":1,"stats":{"Line":3}},{"line":276,"address":[887989],"length":1,"stats":{"Line":3}},{"line":284,"address":[888365,888267,888124],"length":1,"stats":{"Line":8}},{"line":285,"address":[888460,888799,888663],"length":1,"stats":{"Line":8}},{"line":287,"address":[754475,754520],"length":1,"stats":{"Line":4}},{"line":288,"address":[888950],"length":1,"stats":{"Line":2}},{"line":289,"address":[889023],"length":1,"stats":{"Line":2}},{"line":294,"address":[889267],"length":1,"stats":{"Line":2}},{"line":295,"address":[889099],"length":1,"stats":{"Line":2}},{"line":298,"address":[889091],"length":1,"stats":{"Line":2}},{"line":312,"address":[888493],"length":1,"stats":{"Line":2}}],"covered":80,"coverable":89},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","security.rs"],"content":"//! Security rules\n//!\n//! This module provides rules for checking security-related aspects, including:\n//! - CODEOWNERS file for code review requirements\n//! - Dependency lock files for reproducible builds\n//! - Runtime version files for consistent environments\n\nuse crate::error::RepoLensError;\n\nuse crate::config::Config;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for checking security-related aspects\npub struct SecurityRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for SecurityRules {\n    /// Get the category name\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"security\"\n    }\n\n    /// Run all security-related rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for security issues\n    async fn run(\u0026self, scanner: \u0026Scanner, config: \u0026Config) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n        let mut findings = Vec::new();\n\n        // Check CODEOWNERS\n        if config.is_rule_enabled(\"security/codeowners\") {\n            findings.extend(check_codeowners(scanner, config).await?);\n        }\n\n        // Check for dependency files\n        if config.is_rule_enabled(\"security/dependencies\") {\n            findings.extend(check_dependencies(scanner).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for CODEOWNERS file\n///\n/// Verifies that a CODEOWNERS file exists. Required for enterprise preset,\n/// recommended for strict preset.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `config` - The configuration (used to determine severity)\n///\n/// # Returns\n///\n/// A vector of findings for CODEOWNERS issues\nasync fn check_codeowners(\n    scanner: \u0026Scanner,\n    config: \u0026Config,\n) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    let codeowners_files = [\"CODEOWNERS\", \".github/CODEOWNERS\", \"docs/CODEOWNERS\"];\n    let has_codeowners = codeowners_files.iter().any(|f| scanner.file_exists(f));\n\n    // CODEOWNERS is required for enterprise, recommended for strict\n    let severity = if config.preset == \"enterprise\" {\n        Severity::Critical\n    } else {\n        Severity::Info\n    };\n\n    if !has_codeowners {\n        findings.push(\n            Finding::new(\n                \"SECURITY001\",\n                \"security\",\n                severity,\n                \"CODEOWNERS file is missing\",\n            )\n            .with_description(\n                \"A CODEOWNERS file automatically assigns reviewers to pull requests based on file paths.\"\n            )\n            .with_remediation(\n                \"Create a CODEOWNERS file in .github/ to define code ownership and review requirements.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n/// Check for dependency lock files and version files\n///\n/// Verifies that lock files exist for reproducible builds and that\n/// runtime version files are specified for consistent environments.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for dependency-related issues\nasync fn check_dependencies(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // Check for lock files (indicates dependency management)\n    let _lock_files = [\n        (\"package-lock.json\", \"npm\"),\n        (\"yarn.lock\", \"Yarn\"),\n        (\"pnpm-lock.yaml\", \"pnpm\"),\n        (\"Cargo.lock\", \"Cargo\"),\n        (\"Gemfile.lock\", \"Bundler\"),\n        (\"poetry.lock\", \"Poetry\"),\n        (\"Pipfile.lock\", \"Pipenv\"),\n        (\"composer.lock\", \"Composer\"),\n        (\"go.sum\", \"Go modules\"),\n    ];\n\n    let package_files = [\n        (\"package.json\", \"package-lock.json\"),\n        (\"Cargo.toml\", \"Cargo.lock\"),\n        (\"Gemfile\", \"Gemfile.lock\"),\n        (\"pyproject.toml\", \"poetry.lock\"),\n        (\"Pipfile\", \"Pipfile.lock\"),\n        (\"composer.json\", \"composer.lock\"),\n        (\"go.mod\", \"go.sum\"),\n    ];\n\n    for (package_file, lock_file) in package_files {\n        if scanner.file_exists(package_file) \u0026\u0026 !scanner.file_exists(lock_file) {\n            findings.push(\n                Finding::new(\n                    \"SECURITY002\",\n                    \"security\",\n                    Severity::Warning,\n                    format!(\"Lock file {} is missing\", lock_file),\n                )\n                .with_description(\n                    \"Lock files ensure reproducible builds and protect against supply chain attacks.\"\n                )\n                .with_remediation(\n                    \"Generate the lock file by running your package manager's install command.\"\n                )\n            );\n        }\n    }\n\n    // Check for .nvmrc or similar version files\n    let version_managers = [\n        (\".nvmrc\", \"Node.js version\"),\n        (\".node-version\", \"Node.js version\"),\n        (\".python-version\", \"Python version\"),\n        (\".ruby-version\", \"Ruby version\"),\n        (\"rust-toolchain.toml\", \"Rust toolchain\"),\n    ];\n\n    let has_any_version_file = version_managers.iter().any(|(f, _)| scanner.file_exists(f));\n\n    // Detect project type\n    let is_node = scanner.file_exists(\"package.json\");\n    let is_python =\n        scanner.file_exists(\"pyproject.toml\") || scanner.file_exists(\"requirements.txt\");\n    let is_ruby = scanner.file_exists(\"Gemfile\");\n    let is_rust = scanner.file_exists(\"Cargo.toml\");\n\n    if !has_any_version_file \u0026\u0026 (is_node || is_python || is_ruby || is_rust) {\n        findings.push(\n            Finding::new(\n                \"SECURITY003\",\n                \"security\",\n                Severity::Info,\n                \"No runtime version file found\",\n            )\n            .with_description(\n                \"Specifying runtime versions (e.g., .nvmrc, .python-version) ensures consistent development environments.\"\n            )\n        );\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::Config;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_codeowners_missing_enterprise() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config {\n            preset: \"enterprise\".to_string(),\n            ..Default::default()\n        };\n        let findings = check_codeowners(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SECURITY001\"));\n        assert!(findings\n            .iter()\n            .any(|f| f.severity == crate::rules::results::Severity::Critical));\n    }\n\n    #[tokio::test]\n    async fn test_check_codeowners_missing_strict() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config {\n            preset: \"strict\".to_string(),\n            ..Default::default()\n        };\n        let findings = check_codeowners(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SECURITY001\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_dependencies_missing_lock_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let package_json = root.join(\"package.json\");\n\n        fs::write(\u0026package_json, r#\"{\"name\": \"test\"}\"#).unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_dependencies(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"SECURITY002\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_dependencies_no_version_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let package_json = root.join(\"package.json\");\n\n        fs::write(\u0026package_json, r#\"{\"name\": \"test\"}\"#).unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_dependencies(\u0026scanner).await.unwrap();\n\n        assert!(findings.iter().any(|f| f.rule_id == \"SECURITY003\"));\n    }\n}\n","traces":[{"line":21,"address":[514768],"length":1,"stats":{"Line":2}},{"line":35,"address":[1311542,1310361,1311403,1310481,1310275,1310565,1310841,1310240],"length":1,"stats":{"Line":24}},{"line":36,"address":[1310581],"length":1,"stats":{"Line":4}},{"line":39,"address":[1310597,1310671],"length":1,"stats":{"Line":9}},{"line":40,"address":[1310867,1310388,1311521,1310712],"length":1,"stats":{"Line":3}},{"line":44,"address":[1311266,1310677],"length":1,"stats":{"Line":6}},{"line":45,"address":[266414,266493],"length":1,"stats":{"Line":2}},{"line":48,"address":[872508],"length":1,"stats":{"Line":4}},{"line":65,"address":[621024],"length":1,"stats":{"Line":2}},{"line":69,"address":[1306176],"length":1,"stats":{"Line":2}},{"line":71,"address":[1306249],"length":1,"stats":{"Line":2}},{"line":72,"address":[1306327,1306410,1306897,1306880],"length":1,"stats":{"Line":8}},{"line":75,"address":[1306463,1306499],"length":1,"stats":{"Line":4}},{"line":76,"address":[1306501],"length":1,"stats":{"Line":2}},{"line":78,"address":[1306491],"length":1,"stats":{"Line":2}},{"line":81,"address":[1306513],"length":1,"stats":{"Line":2}},{"line":82,"address":[1306806],"length":1,"stats":{"Line":2}},{"line":83,"address":[1306519,1306736],"length":1,"stats":{"Line":4}},{"line":98,"address":[1306597],"length":1,"stats":{"Line":2}},{"line":113,"address":[621064,621056],"length":1,"stats":{"Line":9}},{"line":114,"address":[1307018],"length":1,"stats":{"Line":2}},{"line":117,"address":[1307577],"length":1,"stats":{"Line":2}},{"line":118,"address":[1307091],"length":1,"stats":{"Line":2}},{"line":119,"address":[1307145],"length":1,"stats":{"Line":2}},{"line":120,"address":[1307199],"length":1,"stats":{"Line":2}},{"line":121,"address":[1307253],"length":1,"stats":{"Line":2}},{"line":122,"address":[1307307],"length":1,"stats":{"Line":2}},{"line":123,"address":[1307361],"length":1,"stats":{"Line":3}},{"line":124,"address":[1307415],"length":1,"stats":{"Line":3}},{"line":125,"address":[1307469],"length":1,"stats":{"Line":3}},{"line":126,"address":[1307523],"length":1,"stats":{"Line":2}},{"line":129,"address":[1308194],"length":1,"stats":{"Line":2}},{"line":130,"address":[1307865],"length":1,"stats":{"Line":2}},{"line":131,"address":[1307912],"length":1,"stats":{"Line":2}},{"line":132,"address":[1307959],"length":1,"stats":{"Line":2}},{"line":133,"address":[1308006],"length":1,"stats":{"Line":2}},{"line":134,"address":[869285],"length":1,"stats":{"Line":2}},{"line":135,"address":[1308100],"length":1,"stats":{"Line":2}},{"line":136,"address":[869379],"length":1,"stats":{"Line":2}},{"line":139,"address":[1308510,1308451,1308596],"length":1,"stats":{"Line":6}},{"line":140,"address":[1309805,1308696],"length":1,"stats":{"Line":4}},{"line":141,"address":[1310128],"length":1,"stats":{"Line":3}},{"line":142,"address":[871227],"length":1,"stats":{"Line":3}},{"line":145,"address":[1309860],"length":1,"stats":{"Line":2}},{"line":146,"address":[871100],"length":1,"stats":{"Line":2}},{"line":159,"address":[1308988],"length":1,"stats":{"Line":3}},{"line":160,"address":[869957],"length":1,"stats":{"Line":4}},{"line":161,"address":[1308779],"length":1,"stats":{"Line":4}},{"line":162,"address":[1308826],"length":1,"stats":{"Line":4}},{"line":163,"address":[1308880],"length":1,"stats":{"Line":3}},{"line":164,"address":[1308934],"length":1,"stats":{"Line":3}},{"line":167,"address":[1309161,1310192,1310208],"length":1,"stats":{"Line":9}},{"line":170,"address":[870478],"length":1,"stats":{"Line":3}},{"line":171,"address":[1309287],"length":1,"stats":{"Line":3}},{"line":173,"address":[870608],"length":1,"stats":{"Line":3}},{"line":174,"address":[1309417],"length":1,"stats":{"Line":3}},{"line":176,"address":[1309623,1309458,1309715],"length":1,"stats":{"Line":9}},{"line":177,"address":[1309769],"length":1,"stats":{"Line":3}},{"line":178,"address":[1309641,1309734],"length":1,"stats":{"Line":6}},{"line":181,"address":[1309633],"length":1,"stats":{"Line":3}},{"line":190,"address":[1309484],"length":1,"stats":{"Line":3}}],"covered":61,"coverable":61},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","categories","workflows.rs"],"content":"//! GitHub Actions workflow rules\n//!\n//! This module provides rules for checking GitHub Actions workflows, including:\n//! - Hardcoded secrets in workflow files\n//! - Explicit permissions configuration\n//! - Pinned action versions for security\n\nuse crate::error::RepoLensError;\nuse regex::Regex;\n\nuse crate::config::Config;\nuse crate::rules::engine::RuleCategory;\nuse crate::rules::results::{Finding, Severity};\nuse crate::scanner::Scanner;\n\n/// Rules for checking GitHub Actions workflows\npub struct WorkflowsRules;\n\n#[async_trait::async_trait]\nimpl RuleCategory for WorkflowsRules {\n    /// Get the category name\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"workflows\"\n    }\n\n    /// Run all workflow-related rules\n    ///\n    /// # Arguments\n    ///\n    /// * `scanner` - The scanner to access repository files\n    /// * `config` - The configuration with enabled rules\n    ///\n    /// # Returns\n    ///\n    /// A vector of findings for workflow issues\n    async fn run(\u0026self, scanner: \u0026Scanner, config: \u0026Config) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n        let mut findings = Vec::new();\n\n        // Check for workflows directory\n        if !scanner.directory_exists(\".github/workflows\") {\n            return Ok(findings);\n        }\n\n        // Check workflow security\n        if config.is_rule_enabled(\"workflows/secrets\") {\n            findings.extend(check_workflow_secrets(scanner).await?);\n        }\n\n        // Check permissions\n        if config.is_rule_enabled(\"workflows/permissions\") {\n            findings.extend(check_workflow_permissions(scanner).await?);\n        }\n\n        // Check pinned actions\n        if config.is_rule_enabled(\"workflows/pinned-actions\") {\n            findings.extend(check_pinned_actions(scanner, config).await?);\n        }\n\n        Ok(findings)\n    }\n}\n\n/// Check for hardcoded secrets in workflow files\n///\n/// Detects patterns that suggest hardcoded passwords, tokens, API keys,\n/// or secrets in GitHub Actions workflow files.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for hardcoded secrets in workflows\nasync fn check_workflow_secrets(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // Patterns that suggest hardcoded secrets in workflows\n    let secret_patterns = [\n        (r#\"password\\s*:\\s*['\"][^'\"]+['\"]\"#, \"hardcoded password\"),\n        (r#\"token\\s*:\\s*['\"][^'\"]+['\"]\"#, \"hardcoded token\"),\n        (r#\"api[_-]?key\\s*:\\s*['\"][^'\"]+['\"]\"#, \"hardcoded API key\"),\n        (r#\"secret\\s*:\\s*['\"][^'\"]+['\"]\"#, \"hardcoded secret\"),\n    ];\n\n    for file in scanner.files_in_directory(\".github/workflows\") {\n        if !file.path.ends_with(\".yml\") \u0026\u0026 !file.path.ends_with(\".yaml\") {\n            continue;\n        }\n\n        if let Ok(content) = scanner.read_file(\u0026file.path) {\n            for (pattern, description) in \u0026secret_patterns {\n                let regex = match Regex::new(pattern) {\n                    Ok(r) =\u003e r,\n                    Err(e) =\u003e {\n                        tracing::warn!(\"Invalid regex pattern '{}': {}\", pattern, e);\n                        continue;\n                    }\n                };\n                if regex.is_match(\u0026content) {\n                    // Find line number\n                    let line_num = content\n                        .lines()\n                        .enumerate()\n                        .find(|(_, line)| regex.is_match(line))\n                        .map(|(i, _)| i + 1)\n                        .unwrap_or(0);\n\n                    findings.push(\n                        Finding::new(\n                            \"WF001\",\n                            \"workflows\",\n                            Severity::Critical,\n                            format!(\"Potential {} in workflow\", description),\n                        )\n                        .with_location(format!(\"{}:{}\", file.path, line_num))\n                        .with_description(\"Secrets should never be hardcoded in workflow files.\")\n                        .with_remediation(\n                            \"Use GitHub Secrets (secrets.SECRET_NAME) instead of hardcoded values.\",\n                        ),\n                    );\n                }\n            }\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for explicit permissions in workflow files\n///\n/// Verifies that workflows define explicit permissions to follow\n/// the principle of least privilege.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n///\n/// # Returns\n///\n/// A vector of findings for missing permissions\nasync fn check_workflow_permissions(scanner: \u0026Scanner) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    for file in scanner.files_in_directory(\".github/workflows\") {\n        if !file.path.ends_with(\".yml\") \u0026\u0026 !file.path.ends_with(\".yaml\") {\n            continue;\n        }\n\n        if let Ok(content) = scanner.read_file(\u0026file.path) {\n            // Check if permissions are defined\n            if !content.contains(\"permissions:\") {\n                findings.push(\n                    Finding::new(\n                        \"WF002\",\n                        \"workflows\",\n                        Severity::Warning,\n                        \"Workflow missing explicit permissions\",\n                    )\n                    .with_location(\u0026file.path)\n                    .with_description(\n                        \"Workflows without explicit permissions use the default permissions, which may be more permissive than necessary.\"\n                    )\n                    .with_remediation(\n                        \"Add a 'permissions:' block to explicitly define the minimum required permissions.\"\n                    )\n                );\n            }\n        }\n    }\n\n    Ok(findings)\n}\n\n/// Check for pinned action versions\n///\n/// In strict mode, verifies that actions are pinned to specific versions\n/// instead of using @main, @master, or @latest.\n///\n/// # Arguments\n///\n/// * `scanner` - The scanner to access repository files\n/// * `config` - The configuration (used to check preset)\n///\n/// # Returns\n///\n/// A vector of findings for unpinned actions\nasync fn check_pinned_actions(\n    scanner: \u0026Scanner,\n    config: \u0026Config,\n) -\u003e Result\u003cVec\u003cFinding\u003e, RepoLensError\u003e {\n    let mut findings = Vec::new();\n\n    // Only check in strict mode\n    if config.preset != \"strict\" {\n        return Ok(findings);\n    }\n\n    let unpinned_patterns = [\n        r\"uses:\\s+\\S+@main\\b\",\n        r\"uses:\\s+\\S+@master\\b\",\n        r\"uses:\\s+\\S+@latest\\b\",\n    ];\n\n    for file in scanner.files_in_directory(\".github/workflows\") {\n        if !file.path.ends_with(\".yml\") \u0026\u0026 !file.path.ends_with(\".yaml\") {\n            continue;\n        }\n\n        if let Ok(content) = scanner.read_file(\u0026file.path) {\n            for pattern in \u0026unpinned_patterns {\n                let regex = match Regex::new(pattern) {\n                    Ok(r) =\u003e r,\n                    Err(e) =\u003e {\n                        tracing::warn!(\"Invalid regex pattern '{}': {}\", pattern, e);\n                        continue;\n                    }\n                };\n                for (line_num, line) in content.lines().enumerate() {\n                    if regex.is_match(line) {\n                        findings.push(\n                            Finding::new(\n                                \"WF003\",\n                                \"workflows\",\n                                Severity::Warning,\n                                \"Workflow uses unpinned action reference\",\n                            )\n                            .with_location(format!(\"{}:{}\", file.path, line_num + 1))\n                            .with_description(\n                                \"Using @main, @master, or @latest for actions can introduce breaking changes or security vulnerabilities.\"\n                            )\n                            .with_remediation(\n                                \"Pin actions to a specific version tag (e.g., @v4) or commit SHA for maximum security.\"\n                            )\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    Ok(findings)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::Config;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_check_workflow_secrets_detects_hardcoded_password() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let workflows_dir = root.join(\".github\").join(\"workflows\");\n        fs::create_dir_all(\u0026workflows_dir).unwrap();\n\n        let workflow_file = workflows_dir.join(\"ci.yml\");\n        fs::write(\n            \u0026workflow_file,\n            \"name: CI\\non: push\\njobs:\\n  test:\\n    password: 'secret123'\",\n        )\n        .unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_workflow_secrets(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"WF001\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_workflow_permissions_missing() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let workflows_dir = root.join(\".github\").join(\"workflows\");\n        fs::create_dir_all(\u0026workflows_dir).unwrap();\n\n        let workflow_file = workflows_dir.join(\"ci.yml\");\n        fs::write(\n            \u0026workflow_file,\n            \"name: CI\\non: push\\njobs:\\n  test:\\n    runs-on: ubuntu-latest\",\n        )\n        .unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let findings = check_workflow_permissions(\u0026scanner).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"WF002\"));\n    }\n\n    #[tokio::test]\n    async fn test_check_pinned_actions_detects_unpinned() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n        let workflows_dir = root.join(\".github\").join(\"workflows\");\n        fs::create_dir_all(\u0026workflows_dir).unwrap();\n\n        let workflow_file = workflows_dir.join(\"ci.yml\");\n        fs::write(\n            \u0026workflow_file,\n            \"name: CI\\njobs:\\n  test:\\n    uses: actions/checkout@main\",\n        )\n        .unwrap();\n\n        let scanner = Scanner::new(root.to_path_buf());\n        let config = Config {\n            preset: \"strict\".to_string(),\n            ..Default::default()\n        };\n        let findings = check_pinned_actions(\u0026scanner, \u0026config).await.unwrap();\n\n        assert!(!findings.is_empty());\n        assert!(findings.iter().any(|f| f.rule_id == \"WF003\"));\n    }\n}\n","traces":[{"line":22,"address":[942928],"length":1,"stats":{"Line":2}},{"line":36,"address":[526403],"length":1,"stats":{"Line":15}},{"line":37,"address":[1053361],"length":1,"stats":{"Line":2}},{"line":40,"address":[1053406,1053485],"length":1,"stats":{"Line":8}},{"line":41,"address":[1053491],"length":1,"stats":{"Line":5}},{"line":45,"address":[453482,453426],"length":1,"stats":{"Line":0}},{"line":46,"address":[1053699,1054377,1053831,1053149],"length":1,"stats":{"Line":0}},{"line":50,"address":[1053664,1054230],"length":1,"stats":{"Line":0}},{"line":51,"address":[266957,266865],"length":1,"stats":{"Line":0}},{"line":55,"address":[1054787,1054236],"length":1,"stats":{"Line":0}},{"line":56,"address":[266997,266881],"length":1,"stats":{"Line":0}},{"line":59,"address":[1054797],"length":1,"stats":{"Line":0}},{"line":75,"address":[444167,447683,444290,446989,444268,444128],"length":1,"stats":{"Line":8}},{"line":76,"address":[1044437],"length":1,"stats":{"Line":2}},{"line":79,"address":[1044737],"length":1,"stats":{"Line":2}},{"line":80,"address":[1044521],"length":1,"stats":{"Line":2}},{"line":81,"address":[1044575],"length":1,"stats":{"Line":2}},{"line":82,"address":[1044629],"length":1,"stats":{"Line":2}},{"line":83,"address":[1044683],"length":1,"stats":{"Line":2}},{"line":86,"address":[1044948,1045090,1044865,1047835],"length":1,"stats":{"Line":8}},{"line":87,"address":[1045372,1045493,1045153],"length":1,"stats":{"Line":6}},{"line":91,"address":[1045704,1045606,1045454],"length":1,"stats":{"Line":6}},{"line":92,"address":[1045752,1045835],"length":1,"stats":{"Line":4}},{"line":93,"address":[1045957,1046079],"length":1,"stats":{"Line":4}},{"line":94,"address":[1046173],"length":1,"stats":{"Line":2}},{"line":95,"address":[1046110],"length":1,"stats":{"Line":0}},{"line":96,"address":[1047467,1047222,1046142],"length":1,"stats":{"Line":0}},{"line":100,"address":[1046324,1046245],"length":1,"stats":{"Line":4}},{"line":102,"address":[1046375],"length":1,"stats":{"Line":2}},{"line":105,"address":[1047888,1047904],"length":1,"stats":{"Line":4}},{"line":106,"address":[1047956,1047952],"length":1,"stats":{"Line":4}},{"line":109,"address":[1047112],"length":1,"stats":{"Line":2}},{"line":110,"address":[1046713,1046995,1047042],"length":1,"stats":{"Line":6}},{"line":113,"address":[1046543],"length":1,"stats":{"Line":2}},{"line":114,"address":[1046613,1046551],"length":1,"stats":{"Line":4}},{"line":116,"address":[1046811,1047034,1047155,1046792,1046578],"length":1,"stats":{"Line":4}},{"line":127,"address":[1045202],"length":1,"stats":{"Line":2}},{"line":142,"address":[449249,447863,447953,449338,447975,447824],"length":1,"stats":{"Line":8}},{"line":143,"address":[1048122],"length":1,"stats":{"Line":2}},{"line":145,"address":[449314,448027,448243,448107],"length":1,"stats":{"Line":8}},{"line":146,"address":[1048686,1048479,1048777],"length":1,"stats":{"Line":6}},{"line":150,"address":[448699,448797,448574],"length":1,"stats":{"Line":6}},{"line":152,"address":[1049021,1049092],"length":1,"stats":{"Line":4}},{"line":153,"address":[1049327],"length":1,"stats":{"Line":2}},{"line":154,"address":[1049250,1049137],"length":1,"stats":{"Line":4}},{"line":157,"address":[1049129],"length":1,"stats":{"Line":2}},{"line":172,"address":[448346],"length":1,"stats":{"Line":2}},{"line":188,"address":[526320],"length":1,"stats":{"Line":2}},{"line":192,"address":[449537],"length":1,"stats":{"Line":2}},{"line":195,"address":[1049862,1049797],"length":1,"stats":{"Line":4}},{"line":196,"address":[449808],"length":1,"stats":{"Line":0}},{"line":199,"address":[1049876],"length":1,"stats":{"Line":2}},{"line":205,"address":[449937,450079,449781,452758],"length":1,"stats":{"Line":8}},{"line":206,"address":[1050658,1050537,1050318],"length":1,"stats":{"Line":6}},{"line":210,"address":[1050619,1050869,1050771],"length":1,"stats":{"Line":6}},{"line":211,"address":[1051000,1050917],"length":1,"stats":{"Line":4}},{"line":212,"address":[1051100,1051222],"length":1,"stats":{"Line":4}},{"line":213,"address":[1051313],"length":1,"stats":{"Line":2}},{"line":214,"address":[451077],"length":1,"stats":{"Line":0}},{"line":215,"address":[1051285,1052566,1052321],"length":1,"stats":{"Line":0}},{"line":219,"address":[451209,451288],"length":1,"stats":{"Line":4}},{"line":220,"address":[1051670,1051707],"length":1,"stats":{"Line":4}},{"line":221,"address":[1052214],"length":1,"stats":{"Line":2}},{"line":222,"address":[1052097,1052144,1051724],"length":1,"stats":{"Line":6}},{"line":225,"address":[1051716],"length":1,"stats":{"Line":2}},{"line":228,"address":[1052257,1051794,1051864,1051845,1052136],"length":1,"stats":{"Line":4}},{"line":242,"address":[1050359],"length":1,"stats":{"Line":2}}],"covered":55,"coverable":67},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","engine.rs"],"content":"//! Rules evaluation engine\n\nuse crate::error::RepoLensError;\nuse tracing::{debug, info, span, Level};\n\nuse super::categories::{\n    custom::CustomRules, docs::DocsRules, files::FilesRules, quality::QualityRules,\n    secrets::SecretsRules, security::SecurityRules, workflows::WorkflowsRules,\n};\nuse super::results::AuditResults;\nuse crate::config::Config;\nuse crate::scanner::Scanner;\n\n/// Trait for rule categories\n#[async_trait::async_trait]\npub trait RuleCategory: Send + Sync {\n    /// Get the category name\n    fn name(\u0026self) -\u003e \u0026'static str;\n\n    /// Run the rules in this category\n    async fn run(\n        \u0026self,\n        scanner: \u0026Scanner,\n        config: \u0026Config,\n    ) -\u003e Result\u003cVec\u003csuper::Finding\u003e, RepoLensError\u003e;\n}\n\n/// Main rules evaluation engine\npub struct RulesEngine {\n    config: Config,\n    only_categories: Option\u003cVec\u003cString\u003e\u003e,\n    skip_categories: Option\u003cVec\u003cString\u003e\u003e,\n}\n\nimpl RulesEngine {\n    /// Create a new rules engine with the given configuration\n    pub fn new(config: Config) -\u003e Self {\n        Self {\n            config,\n            only_categories: None,\n            skip_categories: None,\n        }\n    }\n\n    /// Set categories to exclusively run\n    pub fn set_only_categories(\u0026mut self, categories: Vec\u003cString\u003e) {\n        self.only_categories = Some(categories);\n    }\n\n    /// Set categories to skip\n    pub fn set_skip_categories(\u0026mut self, categories: Vec\u003cString\u003e) {\n        self.skip_categories = Some(categories);\n    }\n\n    /// Check if a category should be run\n    fn should_run_category(\u0026self, category: \u0026str) -\u003e bool {\n        if let Some(only) = \u0026self.only_categories {\n            return only.iter().any(|c| c == category);\n        }\n\n        if let Some(skip) = \u0026self.skip_categories {\n            return !skip.iter().any(|c| c == category);\n        }\n\n        true\n    }\n\n    /// Run all enabled rules and return results\n    pub async fn run(\u0026self, scanner: \u0026Scanner) -\u003e Result\u003cAuditResults, RepoLensError\u003e {\n        info!(\"Starting audit with preset: {}\", self.config.preset);\n\n        let repo_name = scanner.repository_name();\n        let repo_name_ref = \u0026repo_name;\n        let mut results = AuditResults::new(repo_name.clone(), \u0026self.config.preset);\n\n        // Get all rule categories\n        let categories: Vec\u003cBox\u003cdyn RuleCategory\u003e\u003e = vec![\n            Box::new(SecretsRules),\n            Box::new(FilesRules),\n            Box::new(DocsRules),\n            Box::new(SecurityRules),\n            Box::new(WorkflowsRules),\n            Box::new(QualityRules),\n            Box::new(CustomRules),\n        ];\n\n        // Run each category\n        for category in categories {\n            let category_name = category.name();\n\n            if !self.should_run_category(category_name) {\n                debug!(category = category_name, \"Skipping category\");\n                continue;\n            }\n\n            let span = span!(Level::INFO, \"category\", category = category_name, repository = %repo_name_ref);\n            let _guard = span.enter();\n\n            debug!(category = category_name, \"Running category\");\n\n            match category.run(scanner, \u0026self.config).await {\n                Ok(findings) =\u003e {\n                    let count = findings.len();\n                    debug!(\n                        category = category_name,\n                        findings_count = count,\n                        \"Category completed\"\n                    );\n                    results.add_findings(findings);\n                }\n                Err(e) =\u003e {\n                    tracing::warn!(\n                        category = category_name,\n                        error = %e,\n                        \"Error running category\"\n                    );\n                }\n            }\n        }\n\n        info!(\n            \"Audit complete: {} critical, {} warnings, {} info\",\n            results.count_by_severity(super::Severity::Critical),\n            results.count_by_severity(super::Severity::Warning),\n            results.count_by_severity(super::Severity::Info),\n        );\n\n        Ok(results)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::scanner::Scanner;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_rules_engine_runs_all_categories() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Create a basic file structure\n        fs::write(root.join(\"README.md\"), \"# Test Project\").unwrap();\n\n        let config = Config::default();\n        let scanner = Scanner::new(root.to_path_buf());\n        let engine = RulesEngine::new(config);\n\n        let results = engine.run(\u0026scanner).await.unwrap();\n\n        // Verify that results are returned (may be empty if no issues found)\n        let _ = results.findings().len();\n        assert_eq!(results.preset, \"opensource\");\n    }\n\n    #[tokio::test]\n    async fn test_rules_engine_filters_with_only() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        fs::write(root.join(\"README.md\"), \"# Test\").unwrap();\n\n        let config = Config::default();\n        let scanner = Scanner::new(root.to_path_buf());\n        let mut engine = RulesEngine::new(config);\n        engine.set_only_categories(vec![\"secrets\".to_string()]);\n\n        let results = engine.run(\u0026scanner).await.unwrap();\n\n        // Verify that only secrets category was run\n        // All findings should be from secrets category\n        for finding in results.findings() {\n            assert_eq!(finding.category, \"secrets\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_rules_engine_filters_with_skip() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        fs::write(root.join(\"README.md\"), \"# Test\").unwrap();\n\n        let config = Config::default();\n        let scanner = Scanner::new(root.to_path_buf());\n        let mut engine = RulesEngine::new(config);\n        engine.set_skip_categories(vec![\"secrets\".to_string()]);\n\n        let results = engine.run(\u0026scanner).await.unwrap();\n\n        // Verify that secrets category was skipped\n        for finding in results.findings() {\n            assert_ne!(finding.category, \"secrets\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_rules_engine_handles_category_errors_gracefully() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Create a file that might cause issues\n        fs::write(root.join(\"test.txt\"), \"test\").unwrap();\n\n        let config = Config::default();\n        let scanner = Scanner::new(root.to_path_buf());\n        let engine = RulesEngine::new(config);\n\n        // Should not panic even if a category fails\n        let results = engine.run(\u0026scanner).await;\n        assert!(results.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_rules_engine_collects_all_findings() {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Create files that should trigger findings\n        fs::write(\n            root.join(\"test.js\"),\n            \"const apiKey = 'sk_test_1234567890abcdef';\",\n        )\n        .unwrap();\n\n        let config = Config::default();\n        let scanner = Scanner::new(root.to_path_buf());\n        let engine = RulesEngine::new(config);\n\n        let results = engine.run(\u0026scanner).await.unwrap();\n\n        // Should have collected findings from multiple categories\n        // (at least secrets should find something)\n        let _ = results.findings().len();\n    }\n\n    #[test]\n    fn test_should_run_category_with_only() {\n        let config = Config::default();\n        let mut engine = RulesEngine::new(config);\n        engine.set_only_categories(vec![\"secrets\".to_string(), \"files\".to_string()]);\n\n        assert!(engine.should_run_category(\"secrets\"));\n        assert!(engine.should_run_category(\"files\"));\n        assert!(!engine.should_run_category(\"docs\"));\n    }\n\n    #[test]\n    fn test_should_run_category_with_skip() {\n        let config = Config::default();\n        let mut engine = RulesEngine::new(config);\n        engine.set_skip_categories(vec![\"secrets\".to_string()]);\n\n        assert!(!engine.should_run_category(\"secrets\"));\n        assert!(engine.should_run_category(\"files\"));\n        assert!(engine.should_run_category(\"docs\"));\n    }\n\n    #[test]\n    fn test_should_run_category_default() {\n        let config = Config::default();\n        let engine = RulesEngine::new(config);\n\n        // By default, all categories should run\n        assert!(engine.should_run_category(\"secrets\"));\n        assert!(engine.should_run_category(\"files\"));\n        assert!(engine.should_run_category(\"docs\"));\n    }\n}\n","traces":[{"line":37,"address":[1201328],"length":1,"stats":{"Line":7}},{"line":46,"address":[1102400,1102486],"length":1,"stats":{"Line":2}},{"line":47,"address":[1102517,1102414],"length":1,"stats":{"Line":4}},{"line":51,"address":[1102560,1102646],"length":1,"stats":{"Line":2}},{"line":52,"address":[1102574,1102677],"length":1,"stats":{"Line":4}},{"line":56,"address":[1102720],"length":1,"stats":{"Line":3}},{"line":57,"address":[1201816],"length":1,"stats":{"Line":3}},{"line":58,"address":[1102804],"length":1,"stats":{"Line":6}},{"line":61,"address":[1102926,1102860],"length":1,"stats":{"Line":4}},{"line":62,"address":[1202003],"length":1,"stats":{"Line":6}},{"line":65,"address":[1102984],"length":1,"stats":{"Line":2}},{"line":69,"address":[1086371,1086192,1088149,1088160,1086414,1086239],"length":1,"stats":{"Line":9}},{"line":70,"address":[1086343,1086762,1086471],"length":1,"stats":{"Line":7}},{"line":72,"address":[1086736],"length":1,"stats":{"Line":3}},{"line":73,"address":[1087048],"length":1,"stats":{"Line":2}},{"line":74,"address":[1087067,1087146],"length":1,"stats":{"Line":5}},{"line":77,"address":[1087617,1087282,1087368,1087187,1088155,1087251,1087534,1087451,1087700,1087729],"length":1,"stats":{"Line":16}},{"line":78,"address":[1087322,1087259],"length":1,"stats":{"Line":7}},{"line":79,"address":[1087405,1087345],"length":1,"stats":{"Line":7}},{"line":80,"address":[1087488,1087428],"length":1,"stats":{"Line":8}},{"line":81,"address":[836931,836871],"length":1,"stats":{"Line":8}},{"line":82,"address":[1087654,1087594],"length":1,"stats":{"Line":8}},{"line":83,"address":[1087677],"length":1,"stats":{"Line":4}},{"line":87,"address":[1088016,1088091,1090514],"length":1,"stats":{"Line":14}},{"line":88,"address":[1090595,1091784],"length":1,"stats":{"Line":10}},{"line":90,"address":[841151],"length":1,"stats":{"Line":3}},{"line":91,"address":[1091896,1091844,1092186],"length":1,"stats":{"Line":4}},{"line":95,"address":[841232,841853,842276],"length":1,"stats":{"Line":7}},{"line":96,"address":[1092864,1093250],"length":1,"stats":{"Line":6}},{"line":98,"address":[1093330,1093253,1093604],"length":1,"stats":{"Line":6}},{"line":100,"address":[837546,842913,837855,835761,837576,843310],"length":1,"stats":{"Line":13}},{"line":101,"address":[1088602],"length":1,"stats":{"Line":3}},{"line":102,"address":[838074,838010],"length":1,"stats":{"Line":6}},{"line":103,"address":[838452,838082],"length":1,"stats":{"Line":4}},{"line":108,"address":[1089022],"length":1,"stats":{"Line":4}},{"line":110,"address":[1088523],"length":1,"stats":{"Line":0}},{"line":111,"address":[1088571,1089590,1089873],"length":1,"stats":{"Line":0}},{"line":120,"address":[1091289],"length":1,"stats":{"Line":0}},{"line":127,"address":[1090981],"length":1,"stats":{"Line":2}}],"covered":36,"coverable":39},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","mod.rs"],"content":"//! Rules module - Audit rules and evaluation engine\n\npub mod categories;\npub mod engine;\npub mod patterns;\npub mod results;\n\npub use results::{Finding, Severity};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","patterns","mod.rs"],"content":"//! Pattern definitions for secret detection\n\nmod secrets;\n\npub use secrets::SECRET_PATTERNS;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","patterns","secrets.rs"],"content":"//! Secret detection patterns\n\nuse lazy_static::lazy_static;\nuse regex::Regex;\n\n/// A pattern for detecting secrets\npub struct SecretPattern {\n    pub name: \u0026'static str,\n    pub description: \u0026'static str,\n    pub regex: Regex,\n}\n\nlazy_static! {\n    /// Collection of secret patterns to detect\n    pub static ref SECRET_PATTERNS: Vec\u003cSecretPattern\u003e = vec![\n        // GitHub tokens\n        SecretPattern {\n            name: \"GitHub Personal Access Token\",\n            description: \"GitHub personal access tokens start with 'ghp_'\",\n            regex: Regex::new(r\"ghp_[A-Za-z0-9]{36}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"GitHub OAuth Token\",\n            description: \"GitHub OAuth tokens start with 'gho_'\",\n            regex: Regex::new(r\"gho_[A-Za-z0-9]{36}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"GitHub User-to-Server Token\",\n            description: \"GitHub user-to-server tokens start with 'ghu_'\",\n            regex: Regex::new(r\"ghu_[A-Za-z0-9]{36}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"GitHub Server-to-Server Token\",\n            description: \"GitHub server-to-server tokens start with 'ghs_'\",\n            regex: Regex::new(r\"ghs_[A-Za-z0-9]{36}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"GitHub Refresh Token\",\n            description: \"GitHub refresh tokens start with 'ghr_'\",\n            regex: Regex::new(r\"ghr_[A-Za-z0-9]{36}\").unwrap(),\n        },\n\n        // AWS\n        SecretPattern {\n            name: \"AWS Access Key ID\",\n            description: \"AWS access keys start with 'AKIA'\",\n            regex: Regex::new(r\"AKIA[0-9A-Z]{16}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"AWS Secret Access Key\",\n            description: \"AWS secret access keys are 40 character strings\",\n            regex: Regex::new(r#\"(?i)(aws_secret_access_key|aws_secret_key)\\s*[=:]\\s*['\"]?[A-Za-z0-9/+=]{40}['\"]?\"#).unwrap(),\n        },\n\n        // Stripe\n        SecretPattern {\n            name: \"Stripe Live Secret Key\",\n            description: \"Stripe live secret keys start with 'sk_live_'\",\n            regex: Regex::new(r\"sk_live_[0-9a-zA-Z]{24,}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"Stripe Test Secret Key\",\n            description: \"Stripe test secret keys start with 'sk_test_'\",\n            regex: Regex::new(r\"sk_test_[0-9a-zA-Z]{24,}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"Stripe Restricted Key\",\n            description: \"Stripe restricted keys start with 'rk_live_' or 'rk_test_'\",\n            regex: Regex::new(r\"rk_(live|test)_[0-9a-zA-Z]{24,}\").unwrap(),\n        },\n\n        // Slack\n        SecretPattern {\n            name: \"Slack Token\",\n            description: \"Slack tokens start with 'xox'\",\n            regex: Regex::new(r\"xox[baprs]-[0-9a-zA-Z-]{10,48}\").unwrap(),\n        },\n\n        // Google\n        SecretPattern {\n            name: \"Google API Key\",\n            description: \"Google API keys start with 'AIza'\",\n            regex: Regex::new(r\"AIza[0-9A-Za-z\\-_]{35}\").unwrap(),\n        },\n        SecretPattern {\n            name: \"Google OAuth Token\",\n            description: \"Google OAuth tokens start with 'ya29.'\",\n            regex: Regex::new(r\"ya29\\.[0-9A-Za-z\\-_]+\").unwrap(),\n        },\n\n        // Firebase\n        SecretPattern {\n            name: \"Firebase Cloud Messaging\",\n            description: \"Firebase server keys\",\n            regex: Regex::new(r\"AAAA[A-Za-z0-9_-]{7}:[A-Za-z0-9_-]{140}\").unwrap(),\n        },\n\n        // Twilio\n        SecretPattern {\n            name: \"Twilio API Key\",\n            description: \"Twilio API keys start with 'SK'\",\n            regex: Regex::new(r\"SK[0-9a-fA-F]{32}\").unwrap(),\n        },\n\n        // SendGrid\n        SecretPattern {\n            name: \"SendGrid API Key\",\n            description: \"SendGrid API keys start with 'SG.'\",\n            regex: Regex::new(r\"SG\\.[0-9A-Za-z\\-_]{22}\\.[0-9A-Za-z\\-_]{43}\").unwrap(),\n        },\n\n        // Mailgun\n        SecretPattern {\n            name: \"Mailgun API Key\",\n            description: \"Mailgun API keys start with 'key-'\",\n            regex: Regex::new(r\"key-[0-9a-zA-Z]{32}\").unwrap(),\n        },\n\n        // npm\n        SecretPattern {\n            name: \"npm Token\",\n            description: \"npm tokens start with 'npm_'\",\n            regex: Regex::new(r\"npm_[A-Za-z0-9]{36}\").unwrap(),\n        },\n\n        // Discord\n        SecretPattern {\n            name: \"Discord Token\",\n            description: \"Discord bot tokens\",\n            regex: Regex::new(r\"[MN][A-Za-z\\d]{23,}\\.[\\w-]{6}\\.[\\w-]{27}\").unwrap(),\n        },\n\n        // Generic patterns\n        SecretPattern {\n            name: \"Private Key\",\n            description: \"PEM encoded private key\",\n            regex: Regex::new(r\"-----BEGIN (RSA|DSA|EC|OPENSSH) PRIVATE KEY-----\").unwrap(),\n        },\n        SecretPattern {\n            name: \"JWT Token\",\n            description: \"JSON Web Token\",\n            regex: Regex::new(r\"eyJ[A-Za-z0-9-_=]+\\.eyJ[A-Za-z0-9-_=]+\\.[A-Za-z0-9-_.+/=]+\").unwrap(),\n        },\n\n        // Database connection strings\n        SecretPattern {\n            name: \"MongoDB Connection String\",\n            description: \"MongoDB connection string with credentials\",\n            regex: Regex::new(r\"mongodb(\\+srv)?://[^:]+:[^@]+@\").unwrap(),\n        },\n        SecretPattern {\n            name: \"PostgreSQL Connection String\",\n            description: \"PostgreSQL connection string with credentials\",\n            regex: Regex::new(r\"postgres(ql)?://[^:]+:[^@]+@\").unwrap(),\n        },\n        SecretPattern {\n            name: \"MySQL Connection String\",\n            description: \"MySQL connection string with credentials\",\n            regex: Regex::new(r\"mysql://[^:]+:[^@]+@\").unwrap(),\n        },\n        SecretPattern {\n            name: \"Redis Connection String\",\n            description: \"Redis connection string with credentials\",\n            regex: Regex::new(r\"redis://[^:]+:[^@]+@\").unwrap(),\n        },\n\n        // Generic credential patterns\n        SecretPattern {\n            name: \"Generic Password Assignment\",\n            description: \"Password assigned in code\",\n            regex: Regex::new(r#\"(?i)(password|passwd|pwd)\\s*[=:]\\s*['\"][^'\"]{8,}['\"]\"#).unwrap(),\n        },\n        SecretPattern {\n            name: \"Generic API Key Assignment\",\n            description: \"API key assigned in code\",\n            regex: Regex::new(r#\"(?i)(api[_-]?key|apikey)\\s*[=:]\\s*['\"][^'\"]{16,}['\"]\"#).unwrap(),\n        },\n        SecretPattern {\n            name: \"Generic Secret Assignment\",\n            description: \"Secret assigned in code\",\n            regex: Regex::new(r#\"(?i)(secret[_-]?key|secretkey)\\s*[=:]\\s*['\"][^'\"]{16,}['\"]\"#).unwrap(),\n        },\n        SecretPattern {\n            name: \"Generic Token Assignment\",\n            description: \"Token assigned in code\",\n            regex: Regex::new(r#\"(?i)(access[_-]?token|auth[_-]?token)\\s*[=:]\\s*['\"][^'\"]{16,}['\"]\"#).unwrap(),\n        },\n\n        // URL with credentials\n        SecretPattern {\n            name: \"URL with Embedded Credentials\",\n            description: \"URL containing username:password\",\n            regex: Regex::new(r\"https?://[^:]+:[^@]+@[^/]+\").unwrap(),\n        },\n    ];\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_github_token_detection() {\n        let pattern = \u0026SECRET_PATTERNS[0]; // GitHub PAT\n        assert!(pattern\n            .regex\n            .is_match(\"ghp_abcdefghijklmnopqrstuvwxyz1234567890\"));\n        assert!(!pattern.regex.is_match(\"ghp_short\"));\n    }\n\n    #[test]\n    fn test_aws_key_detection() {\n        let pattern = \u0026SECRET_PATTERNS[5]; // AWS Access Key\n        assert!(pattern.regex.is_match(\"AKIAIOSFODNN7EXAMPLE\"));\n        assert!(!pattern.regex.is_match(\"NOTANAWSKEY12345678\"));\n    }\n\n    #[test]\n    fn test_stripe_key_detection() {\n        let pattern = \u0026SECRET_PATTERNS[7]; // Stripe Live Key\n        assert!(pattern.regex.is_match(\"sk_live_abcdefghijklmnopqrstuvwx\"));\n        assert!(!pattern.regex.is_match(\"sk_live_short\"));\n    }\n}\n","traces":[{"line":15,"address":[131177,127624,130242,127811,130616,127998,126689,126502,129868,128372,132906,126299,127437,129494,128746,131551,131918,130803,129120,130055,131364,128559,130990,131738,128185,129307,130429,126876,127063,128933,127250,126345,129681],"length":1,"stats":{"Line":4}},{"line":17,"address":[126404],"length":1,"stats":{"Line":2}},{"line":20,"address":[1394809,1394741],"length":1,"stats":{"Line":4}},{"line":22,"address":[1394996],"length":1,"stats":{"Line":2}},{"line":25,"address":[1394966,1394898],"length":1,"stats":{"Line":4}},{"line":27,"address":[1395183],"length":1,"stats":{"Line":2}},{"line":30,"address":[1395153,1395082],"length":1,"stats":{"Line":4}},{"line":32,"address":[1395370],"length":1,"stats":{"Line":2}},{"line":35,"address":[126837,126908],"length":1,"stats":{"Line":4}},{"line":37,"address":[1395557],"length":1,"stats":{"Line":2}},{"line":40,"address":[127095,127024],"length":1,"stats":{"Line":4}},{"line":44,"address":[1395744],"length":1,"stats":{"Line":2}},{"line":47,"address":[1395643,1395714],"length":1,"stats":{"Line":4}},{"line":49,"address":[1395931],"length":1,"stats":{"Line":2}},{"line":52,"address":[1395901,1395830],"length":1,"stats":{"Line":4}},{"line":56,"address":[1396118],"length":1,"stats":{"Line":2}},{"line":59,"address":[1396088,1396017],"length":1,"stats":{"Line":4}},{"line":61,"address":[1396305],"length":1,"stats":{"Line":2}},{"line":64,"address":[1396275,1396204],"length":1,"stats":{"Line":4}},{"line":66,"address":[1396492],"length":1,"stats":{"Line":2}},{"line":69,"address":[1396391,1396462],"length":1,"stats":{"Line":4}},{"line":73,"address":[1396679],"length":1,"stats":{"Line":2}},{"line":76,"address":[1396649,1396578],"length":1,"stats":{"Line":4}},{"line":80,"address":[1396866],"length":1,"stats":{"Line":2}},{"line":83,"address":[1396765,1396836],"length":1,"stats":{"Line":4}},{"line":85,"address":[1397053],"length":1,"stats":{"Line":2}},{"line":88,"address":[1396952,1397023],"length":1,"stats":{"Line":4}},{"line":92,"address":[1397240],"length":1,"stats":{"Line":2}},{"line":95,"address":[1397210,1397139],"length":1,"stats":{"Line":4}},{"line":99,"address":[1397427],"length":1,"stats":{"Line":2}},{"line":102,"address":[1397326,1397397],"length":1,"stats":{"Line":4}},{"line":106,"address":[1397614],"length":1,"stats":{"Line":2}},{"line":109,"address":[1397513,1397584],"length":1,"stats":{"Line":4}},{"line":113,"address":[1397801],"length":1,"stats":{"Line":2}},{"line":116,"address":[1397700,1397771],"length":1,"stats":{"Line":4}},{"line":120,"address":[1397988],"length":1,"stats":{"Line":2}},{"line":123,"address":[1397887,1397958],"length":1,"stats":{"Line":4}},{"line":127,"address":[1398175],"length":1,"stats":{"Line":2}},{"line":130,"address":[1398074,1398145],"length":1,"stats":{"Line":4}},{"line":134,"address":[1398362],"length":1,"stats":{"Line":2}},{"line":137,"address":[129900,129829],"length":1,"stats":{"Line":4}},{"line":139,"address":[1398549],"length":1,"stats":{"Line":2}},{"line":142,"address":[130016,130087],"length":1,"stats":{"Line":4}},{"line":146,"address":[1398736],"length":1,"stats":{"Line":2}},{"line":149,"address":[1398706,1398635],"length":1,"stats":{"Line":4}},{"line":151,"address":[1398923],"length":1,"stats":{"Line":2}},{"line":154,"address":[1398822,1398893],"length":1,"stats":{"Line":4}},{"line":156,"address":[1399110],"length":1,"stats":{"Line":2}},{"line":159,"address":[130648,130577],"length":1,"stats":{"Line":4}},{"line":161,"address":[1399297],"length":1,"stats":{"Line":2}},{"line":164,"address":[1399196,1399267],"length":1,"stats":{"Line":4}},{"line":168,"address":[1399484],"length":1,"stats":{"Line":2}},{"line":171,"address":[130951,131022],"length":1,"stats":{"Line":4}},{"line":173,"address":[1399671],"length":1,"stats":{"Line":2}},{"line":176,"address":[131138,131209],"length":1,"stats":{"Line":4}},{"line":178,"address":[1399858],"length":1,"stats":{"Line":2}},{"line":181,"address":[1399757,1399828],"length":1,"stats":{"Line":4}},{"line":183,"address":[1400045],"length":1,"stats":{"Line":2}},{"line":186,"address":[1400015,1399944],"length":1,"stats":{"Line":4}},{"line":190,"address":[1400232],"length":1,"stats":{"Line":2}},{"line":193,"address":[1400131,1400202],"length":1,"stats":{"Line":4}}],"covered":61,"coverable":61},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","rules","results.rs"],"content":"//! Audit results structures\n\nuse serde::{Deserialize, Serialize};\n\n/// Severity levels for findings\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum Severity {\n    /// Critical issues that must be resolved\n    Critical,\n    /// Warnings that should be addressed\n    Warning,\n    /// Informational suggestions\n    Info,\n}\n\nimpl Severity {\n    #[allow(dead_code)]\n    pub fn from_string(s: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"critical\" | \"error\" =\u003e Some(Self::Critical),\n            \"warning\" | \"warn\" =\u003e Some(Self::Warning),\n            \"info\" | \"information\" | \"note\" =\u003e Some(Self::Info),\n            _ =\u003e None,\n        }\n    }\n}\n\n/// A single audit finding\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Finding {\n    /// Unique rule identifier (e.g., \"SEC001\")\n    pub rule_id: String,\n\n    /// Category of the rule (e.g., \"secrets\", \"docs\")\n    pub category: String,\n\n    /// Severity of the finding\n    pub severity: Severity,\n\n    /// Short message describing the finding\n    pub message: String,\n\n    /// Optional file location (e.g., \"src/config.ts:42\")\n    pub location: Option\u003cString\u003e,\n\n    /// Detailed description of the issue\n    pub description: Option\u003cString\u003e,\n\n    /// Suggested remediation steps\n    pub remediation: Option\u003cString\u003e,\n}\n\nimpl Finding {\n    /// Create a new finding\n    pub fn new(\n        rule_id: impl Into\u003cString\u003e,\n        category: impl Into\u003cString\u003e,\n        severity: Severity,\n        message: impl Into\u003cString\u003e,\n    ) -\u003e Self {\n        Self {\n            rule_id: rule_id.into(),\n            category: category.into(),\n            severity,\n            message: message.into(),\n            location: None,\n            description: None,\n            remediation: None,\n        }\n    }\n\n    /// Set the location\n    pub fn with_location(mut self, location: impl Into\u003cString\u003e) -\u003e Self {\n        self.location = Some(location.into());\n        self\n    }\n\n    /// Set the description\n    pub fn with_description(mut self, description: impl Into\u003cString\u003e) -\u003e Self {\n        self.description = Some(description.into());\n        self\n    }\n\n    /// Set the remediation\n    pub fn with_remediation(mut self, remediation: impl Into\u003cString\u003e) -\u003e Self {\n        self.remediation = Some(remediation.into());\n        self\n    }\n}\n\n/// Collection of audit results\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AuditResults {\n    /// Repository name\n    pub repository_name: String,\n\n    /// Preset used for the audit\n    pub preset: String,\n\n    /// List of findings\n    findings: Vec\u003cFinding\u003e,\n}\n\nimpl AuditResults {\n    /// Create new audit results\n    pub fn new(repository_name: impl Into\u003cString\u003e, preset: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            repository_name: repository_name.into(),\n            preset: preset.into(),\n            findings: Vec::new(),\n        }\n    }\n\n    /// Add a finding\n    #[allow(dead_code)]\n    pub fn add_finding(\u0026mut self, finding: Finding) {\n        self.findings.push(finding);\n    }\n\n    /// Add multiple findings\n    pub fn add_findings(\u0026mut self, findings: impl IntoIterator\u003cItem = Finding\u003e) {\n        self.findings.extend(findings);\n    }\n\n    /// Get all findings\n    pub fn findings(\u0026self) -\u003e \u0026[Finding] {\n        \u0026self.findings\n    }\n\n    /// Get findings by severity\n    pub fn findings_by_severity(\u0026self, severity: Severity) -\u003e impl Iterator\u003cItem = \u0026Finding\u003e {\n        self.findings.iter().filter(move |f| f.severity == severity)\n    }\n\n    /// Get findings by category\n    pub fn findings_by_category\u003c'a\u003e(\n        \u0026'a self,\n        category: \u0026'a str,\n    ) -\u003e impl Iterator\u003cItem = \u0026'a Finding\u003e {\n        self.findings.iter().filter(move |f| f.category == category)\n    }\n\n    /// Count findings by severity\n    pub fn count_by_severity(\u0026self, severity: Severity) -\u003e usize {\n        self.findings\n            .iter()\n            .filter(|f| f.severity == severity)\n            .count()\n    }\n\n    /// Check if there are any critical findings\n    pub fn has_critical(\u0026self) -\u003e bool {\n        self.findings\n            .iter()\n            .any(|f| f.severity == Severity::Critical)\n    }\n\n    /// Check if there are any warnings\n    pub fn has_warnings(\u0026self) -\u003e bool {\n        self.findings\n            .iter()\n            .any(|f| f.severity == Severity::Warning)\n    }\n\n    /// Get total number of findings\n    #[allow(dead_code)]\n    pub fn total_count(\u0026self) -\u003e usize {\n        self.findings.len()\n    }\n\n    /// Check if there are no findings\n    #[allow(dead_code)]\n    pub fn is_clean(\u0026self) -\u003e bool {\n        self.findings.is_empty()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_finding_builder() {\n        let finding = Finding::new(\"SEC001\", \"secrets\", Severity::Critical, \"Secret detected\")\n            .with_location(\"src/config.ts:42\")\n            .with_description(\"A hardcoded secret was found\")\n            .with_remediation(\"Move the secret to environment variables\");\n\n        assert_eq!(finding.rule_id, \"SEC001\");\n        assert_eq!(finding.location, Some(\"src/config.ts:42\".to_string()));\n    }\n\n    #[test]\n    fn test_audit_results() {\n        let mut results = AuditResults::new(\"test-repo\", \"opensource\");\n\n        results.add_finding(Finding::new(\n            \"SEC001\",\n            \"secrets\",\n            Severity::Critical,\n            \"Secret found\",\n        ));\n        results.add_finding(Finding::new(\n            \"DOC001\",\n            \"docs\",\n            Severity::Warning,\n            \"README missing\",\n        ));\n\n        assert_eq!(results.total_count(), 2);\n        assert!(results.has_critical());\n        assert!(results.has_warnings());\n        assert_eq!(results.count_by_severity(Severity::Critical), 1);\n    }\n}\n","traces":[{"line":19,"address":[979088,979592,979586],"length":1,"stats":{"Line":0}},{"line":20,"address":[979111,979200],"length":1,"stats":{"Line":0}},{"line":21,"address":[979216],"length":1,"stats":{"Line":0}},{"line":22,"address":[979320],"length":1,"stats":{"Line":0}},{"line":23,"address":[979424],"length":1,"stats":{"Line":0}},{"line":24,"address":[979558],"length":1,"stats":{"Line":0}},{"line":56,"address":[1024784,1025460,1025488,1025426,1026156,1026176],"length":1,"stats":{"Line":10}},{"line":63,"address":[],"length":0,"stats":{"Line":10}},{"line":64,"address":[],"length":0,"stats":{"Line":10}},{"line":66,"address":[380253,379498],"length":1,"stats":{"Line":10}},{"line":74,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[381017,381278,381219,380760,380958,380698],"length":1,"stats":{"Line":14}},{"line":76,"address":[1026952,1026691,1026437],"length":1,"stats":{"Line":8}},{"line":80,"address":[381671,381964,381440,381696],"length":1,"stats":{"Line":4}},{"line":81,"address":[381754,381470,381529,381816],"length":1,"stats":{"Line":12}},{"line":82,"address":[],"length":0,"stats":{"Line":6}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[382314,382376,382073,382014],"length":1,"stats":{"Line":13}},{"line":88,"address":[1028063,1027793],"length":1,"stats":{"Line":7}},{"line":107,"address":[382911,382944,382560,382917,383252],"length":1,"stats":{"Line":11}},{"line":109,"address":[],"length":0,"stats":{"Line":13}},{"line":110,"address":[383044,382697],"length":1,"stats":{"Line":13}},{"line":111,"address":[1028656,1028280],"length":1,"stats":{"Line":14}},{"line":117,"address":[979616],"length":1,"stats":{"Line":8}},{"line":118,"address":[979621],"length":1,"stats":{"Line":8}},{"line":122,"address":[383280],"length":1,"stats":{"Line":3}},{"line":123,"address":[383285],"length":1,"stats":{"Line":3}},{"line":127,"address":[1198784],"length":1,"stats":{"Line":2}},{"line":128,"address":[1198789],"length":1,"stats":{"Line":2}},{"line":132,"address":[1198800],"length":1,"stats":{"Line":0}},{"line":133,"address":[1028864,1028884],"length":1,"stats":{"Line":0}},{"line":137,"address":[979760],"length":1,"stats":{"Line":8}},{"line":141,"address":[979812],"length":1,"stats":{"Line":24}},{"line":145,"address":[979872],"length":1,"stats":{"Line":2}},{"line":146,"address":[979888],"length":1,"stats":{"Line":2}},{"line":148,"address":[383408,383425],"length":1,"stats":{"Line":4}},{"line":153,"address":[979952],"length":1,"stats":{"Line":2}},{"line":154,"address":[979961],"length":1,"stats":{"Line":2}},{"line":156,"address":[383481,383456],"length":1,"stats":{"Line":4}},{"line":160,"address":[980016],"length":1,"stats":{"Line":2}},{"line":161,"address":[980025],"length":1,"stats":{"Line":2}},{"line":163,"address":[383520,383545],"length":1,"stats":{"Line":4}},{"line":168,"address":[980080],"length":1,"stats":{"Line":2}},{"line":169,"address":[980085],"length":1,"stats":{"Line":2}},{"line":174,"address":[980096],"length":1,"stats":{"Line":0}},{"line":175,"address":[980101],"length":1,"stats":{"Line":0}}],"covered":36,"coverable":46},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","scanner","filesystem.rs"],"content":"//! File system scanning utilities\n\nuse ignore::WalkBuilder;\nuse rayon::prelude::*;\nuse std::path::Path;\n\n/// Information about a file in the repository\n#[derive(Debug, Clone)]\npub struct FileInfo {\n    /// Relative path from repository root\n    pub path: String,\n    /// File size in bytes\n    pub size: u64,\n    /// Whether the file is a directory\n    #[allow(dead_code)]\n    pub is_dir: bool,\n}\n\n/// Scan a directory and return information about all files\n///\n/// Uses parallel processing for better performance on large repositories.\npub fn scan_directory(root: \u0026Path) -\u003e Vec\u003cFileInfo\u003e {\n    let walker = WalkBuilder::new(root)\n        .hidden(false)\n        .git_ignore(true)\n        .git_global(true)\n        .git_exclude(true)\n        .ignore(true)\n        .parents(true)\n        .build();\n\n    walker\n        .into_iter()\n        .par_bridge()\n        .filter_map(|entry_result| {\n            let entry = entry_result.ok()?;\n            let path = entry.path();\n\n            // Skip the root directory itself\n            if path == root {\n                return None;\n            }\n\n            // Skip .git directory\n            if path.components().any(|c| c.as_os_str() == \".git\") {\n                return None;\n            }\n\n            // Get relative path - handle errors gracefully\n            let relative_path = match path.strip_prefix(root) {\n                Ok(stripped) =\u003e stripped\n                    .to_str()\n                    .map(|s| s.to_string())\n                    .unwrap_or_else(|| stripped.to_string_lossy().to_string()),\n                Err(_) =\u003e {\n                    return None;\n                }\n            };\n\n            if relative_path.is_empty() {\n                return None;\n            }\n\n            // Get file metadata\n            let metadata = entry.metadata().ok()?;\n\n            Some(FileInfo {\n                path: relative_path,\n                size: metadata.len(),\n                is_dir: metadata.is_dir(),\n            })\n        })\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_scan_directory() {\n        let dir = tempdir().unwrap();\n        let root = dir.path();\n\n        // Create test files\n        fs::write(root.join(\"test.txt\"), \"hello\").unwrap();\n        fs::create_dir(root.join(\"subdir\")).unwrap();\n        fs::write(root.join(\"subdir/nested.txt\"), \"world\").unwrap();\n\n        let files = scan_directory(root);\n\n        assert!(files.iter().any(|f| f.path == \"test.txt\"));\n        assert!(files\n            .iter()\n            .any(|f| f.path == \"subdir/nested.txt\" || f.path == \"subdir\\\\nested.txt\"));\n    }\n}\n","traces":[{"line":22,"address":[405856,405827,405328],"length":1,"stats":{"Line":2}},{"line":23,"address":[405355,405463],"length":1,"stats":{"Line":6}},{"line":32,"address":[405677],"length":1,"stats":{"Line":4}},{"line":35,"address":[1037024,1038471,1038546],"length":1,"stats":{"Line":2}},{"line":36,"address":[1037082],"length":1,"stats":{"Line":2}},{"line":37,"address":[1037485,1037394],"length":1,"stats":{"Line":4}},{"line":40,"address":[1037501],"length":1,"stats":{"Line":2}},{"line":41,"address":[1037580],"length":1,"stats":{"Line":2}},{"line":45,"address":[1038560,1037606,1037537,1038569],"length":1,"stats":{"Line":8}},{"line":46,"address":[1037686],"length":1,"stats":{"Line":0}},{"line":50,"address":[1037635,1037714],"length":1,"stats":{"Line":4}},{"line":51,"address":[1037787],"length":1,"stats":{"Line":2}},{"line":53,"address":[1038662,1038640],"length":1,"stats":{"Line":4}},{"line":54,"address":[1038688,1037911,1038712],"length":1,"stats":{"Line":2}},{"line":56,"address":[1037769],"length":1,"stats":{"Line":0}},{"line":60,"address":[1037927,1037983],"length":1,"stats":{"Line":4}},{"line":61,"address":[1038024],"length":1,"stats":{"Line":0}},{"line":65,"address":[1038042,1038477,1037989],"length":1,"stats":{"Line":4}},{"line":67,"address":[1038350],"length":1,"stats":{"Line":2}},{"line":68,"address":[1038218],"length":1,"stats":{"Line":2}},{"line":69,"address":[1038258],"length":1,"stats":{"Line":2}},{"line":70,"address":[1038322],"length":1,"stats":{"Line":2}}],"covered":19,"coverable":22},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","scanner","git.rs"],"content":"//! Git repository utilities\n\nuse std::path::Path;\nuse std::process::Command;\n\n/// Get the repository name from git remote\npub fn get_repository_name(root: \u0026Path) -\u003e Option\u003cString\u003e {\n    // Try to get the remote URL\n    let output = Command::new(\"git\")\n        .args([\"remote\", \"get-url\", \"origin\"])\n        .current_dir(root)\n        .output()\n        .ok()?;\n\n    if !output.status.success() {\n        return None;\n    }\n\n    let url = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n    parse_repo_name_from_url(\u0026url)\n}\n\n/// Parse repository name from a git URL\nfn parse_repo_name_from_url(url: \u0026str) -\u003e Option\u003cString\u003e {\n    // Handle SSH URLs: git@github.com:owner/repo.git\n    if url.starts_with(\"git@\") {\n        let parts: Vec\u003c\u0026str\u003e = url.split(':').collect();\n        if parts.len() == 2 {\n            let repo_path = parts[1].trim_end_matches(\".git\");\n            return Some(repo_path.to_string());\n        }\n    }\n\n    // Handle HTTPS URLs: https://github.com/owner/repo.git\n    if url.starts_with(\"https://\") || url.starts_with(\"http://\") {\n        let url = url.trim_end_matches(\".git\");\n        let parts: Vec\u003c\u0026str\u003e = url.split('/').collect();\n        if parts.len() \u003e= 2 {\n            let owner = parts[parts.len() - 2];\n            let repo = parts[parts.len() - 1];\n            return Some(format!(\"{}/{}\", owner, repo));\n        }\n    }\n\n    None\n}\n\n/// Get the default branch name\n#[allow(dead_code)]\npub fn get_default_branch(root: \u0026Path) -\u003e Option\u003cString\u003e {\n    // Try to get from git symbolic-ref\n    let output = Command::new(\"git\")\n        .args([\"symbolic-ref\", \"refs/remotes/origin/HEAD\", \"--short\"])\n        .current_dir(root)\n        .output()\n        .ok()?;\n\n    if output.status.success() {\n        let branch = String::from_utf8_lossy(\u0026output.stdout)\n            .trim()\n            .trim_start_matches(\"origin/\")\n            .to_string();\n        if !branch.is_empty() {\n            return Some(branch);\n        }\n    }\n\n    // Fall back to checking for main or master\n    let branches = [\"main\", \"master\"];\n    for branch in branches {\n        let output = Command::new(\"git\")\n            .args([\n                \"show-ref\",\n                \"--verify\",\n                \"--quiet\",\n                \u0026format!(\"refs/heads/{}\", branch),\n            ])\n            .current_dir(root)\n            .output()\n            .ok()?;\n\n        if output.status.success() {\n            return Some(branch.to_string());\n        }\n    }\n\n    None\n}\n\n/// Check if the repository is a git repository\n#[allow(dead_code)]\npub fn is_git_repository(root: \u0026Path) -\u003e bool {\n    root.join(\".git\").exists()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_ssh_url() {\n        let url = \"git@github.com:owner/repo.git\";\n        assert_eq!(\n            parse_repo_name_from_url(url),\n            Some(\"owner/repo\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_parse_https_url() {\n        let url = \"https://github.com/owner/repo.git\";\n        assert_eq!(\n            parse_repo_name_from_url(url),\n            Some(\"owner/repo\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_parse_https_url_without_git() {\n        let url = \"https://github.com/owner/repo\";\n        assert_eq!(\n            parse_repo_name_from_url(url),\n            Some(\"owner/repo\".to_string())\n        );\n    }\n}\n","traces":[{"line":7,"address":[1032784,1031808,1032778],"length":1,"stats":{"Line":4}},{"line":9,"address":[1032046,1031975,1031851],"length":1,"stats":{"Line":9}},{"line":10,"address":[1031886],"length":1,"stats":{"Line":3}},{"line":15,"address":[1032371],"length":1,"stats":{"Line":2}},{"line":16,"address":[1032405],"length":1,"stats":{"Line":2}},{"line":19,"address":[1032485,1032433],"length":1,"stats":{"Line":0}},{"line":20,"address":[1032704],"length":1,"stats":{"Line":0}},{"line":24,"address":[1034067,1032816,1034061],"length":1,"stats":{"Line":3}},{"line":26,"address":[1032887],"length":1,"stats":{"Line":2}},{"line":27,"address":[1032966],"length":1,"stats":{"Line":2}},{"line":28,"address":[1033025,1033090],"length":1,"stats":{"Line":4}},{"line":29,"address":[1033096,1033156],"length":1,"stats":{"Line":4}},{"line":30,"address":[1033218],"length":1,"stats":{"Line":2}},{"line":35,"address":[1033323,1032922],"length":1,"stats":{"Line":3}},{"line":36,"address":[1033360],"length":1,"stats":{"Line":3}},{"line":37,"address":[845311],"length":1,"stats":{"Line":3}},{"line":38,"address":[1033546,1033455],"length":1,"stats":{"Line":4}},{"line":39,"address":[1033568],"length":1,"stats":{"Line":2}},{"line":40,"address":[1033699],"length":1,"stats":{"Line":2}},{"line":41,"address":[1033829],"length":1,"stats":{"Line":2}},{"line":45,"address":[845394],"length":1,"stats":{"Line":0}},{"line":50,"address":[1034080,1036486,1036530],"length":1,"stats":{"Line":0}},{"line":52,"address":[1034135,1034265,1034348],"length":1,"stats":{"Line":0}},{"line":53,"address":[1034176],"length":1,"stats":{"Line":0}},{"line":58,"address":[846602],"length":1,"stats":{"Line":0}},{"line":59,"address":[1034829,1034970],"length":1,"stats":{"Line":0}},{"line":63,"address":[1035130],"length":1,"stats":{"Line":0}},{"line":64,"address":[1035159],"length":1,"stats":{"Line":0}},{"line":69,"address":[1034717],"length":1,"stats":{"Line":0}},{"line":70,"address":[1035284,1034771,1035385],"length":1,"stats":{"Line":0}},{"line":71,"address":[847839,847384],"length":1,"stats":{"Line":0}},{"line":72,"address":[1035806],"length":1,"stats":{"Line":0}},{"line":76,"address":[1035556,1035627],"length":1,"stats":{"Line":0}},{"line":82,"address":[1036340],"length":1,"stats":{"Line":0}},{"line":83,"address":[1036387],"length":1,"stats":{"Line":0}},{"line":87,"address":[1035514],"length":1,"stats":{"Line":0}},{"line":92,"address":[1036725,1036731,1036576],"length":1,"stats":{"Line":0}},{"line":93,"address":[1036596,1036692],"length":1,"stats":{"Line":0}}],"covered":18,"coverable":38},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","scanner","mod.rs"],"content":"//! Scanner module - File system and repository scanning\n\nmod filesystem;\nmod git;\n\nuse std::path::PathBuf;\n\npub use filesystem::FileInfo;\n\n/// Main scanner for repository analysis\n///\n/// The `Scanner` provides access to repository files and metadata.\n/// It caches file information for efficient access during rule execution.\npub struct Scanner {\n    /// Root directory of the repository\n    root: PathBuf,\n    /// Cached file information\n    file_cache: Vec\u003cFileInfo\u003e,\n}\n\nimpl Scanner {\n    /// Create a new scanner for the given root directory\n    ///\n    /// Scans the directory and caches file information for later use.\n    ///\n    /// # Arguments\n    ///\n    /// * `root` - The root directory of the repository to scan\n    ///\n    /// # Returns\n    ///\n    /// A new `Scanner` instance with cached file information\n    pub fn new(root: PathBuf) -\u003e Self {\n        let file_cache = filesystem::scan_directory(\u0026root);\n\n        Self { root, file_cache }\n    }\n\n    /// Get the repository name from the root path or git remote\n    ///\n    /// First attempts to get the repository name from git remote.\n    /// Falls back to the directory name if git information is unavailable.\n    ///\n    /// # Returns\n    ///\n    /// The repository name as a string\n    pub fn repository_name(\u0026self) -\u003e String {\n        // Try to get from git remote first\n        if let Some(name) = git::get_repository_name(\u0026self.root) {\n            return name;\n        }\n\n        // Fall back to directory name\n        self.root\n            .file_name()\n            .and_then(|n| n.to_str())\n            .map(|s| s.to_string())\n            .unwrap_or_else(|| {\n                // If directory name contains non-UTF8, use lossy conversion\n                self.root.to_string_lossy().to_string()\n            })\n    }\n\n    /// Check if a file exists in the repository\n    ///\n    /// # Arguments\n    ///\n    /// * `path` - Relative path to the file from repository root\n    ///\n    /// # Returns\n    ///\n    /// `true` if the file exists, `false` otherwise\n    pub fn file_exists(\u0026self, path: \u0026str) -\u003e bool {\n        self.root.join(path).exists()\n    }\n\n    /// Check if a directory exists in the repository\n    ///\n    /// # Arguments\n    ///\n    /// * `path` - Relative path to the directory from repository root\n    ///\n    /// # Returns\n    ///\n    /// `true` if the directory exists, `false` otherwise\n    pub fn directory_exists(\u0026self, path: \u0026str) -\u003e bool {\n        let full_path = self.root.join(path);\n        full_path.exists() \u0026\u0026 full_path.is_dir()\n    }\n\n    /// Read file content as a string\n    ///\n    /// # Arguments\n    ///\n    /// * `path` - Relative path to the file from repository root\n    ///\n    /// # Returns\n    ///\n    /// The file content as a string, or an I/O error if reading fails\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the file cannot be read or is not valid UTF-8\n    pub fn read_file(\u0026self, path: \u0026str) -\u003e std::io::Result\u003cString\u003e {\n        std::fs::read_to_string(self.root.join(path))\n    }\n\n    /// Get files with specific extensions\n    ///\n    /// # Arguments\n    ///\n    /// * `extensions` - Slice of file extensions (without the dot), e.g., `[\"rs\", \"toml\"]`\n    ///\n    /// # Returns\n    ///\n    /// A vector of references to `FileInfo` for matching files\n    pub fn files_with_extensions(\u0026self, extensions: \u0026[\u0026str]) -\u003e Vec\u003c\u0026FileInfo\u003e {\n        self.file_cache\n            .iter()\n            .filter(|f| {\n                extensions\n                    .iter()\n                    .any(|ext| f.path.ends_with(\u0026format!(\".{}\", ext)))\n            })\n            .collect()\n    }\n\n    /// Get files matching a glob pattern\n    ///\n    /// Supports simple glob patterns like `*.rs`, `**/test/**`, etc.\n    ///\n    /// # Arguments\n    ///\n    /// * `pattern` - Glob pattern to match against file paths\n    ///\n    /// # Returns\n    ///\n    /// A vector of references to `FileInfo` for matching files\n    pub fn files_matching_pattern(\u0026self, pattern: \u0026str) -\u003e Vec\u003c\u0026FileInfo\u003e {\n        self.file_cache\n            .iter()\n            .filter(|f| {\n                if pattern.contains('*') {\n                    glob_match(pattern, \u0026f.path)\n                } else {\n                    f.path.ends_with(pattern) || f.path.contains(pattern)\n                }\n            })\n            .collect()\n    }\n\n    /// Get files larger than a given size in bytes\n    ///\n    /// # Arguments\n    ///\n    /// * `size` - Minimum file size in bytes\n    ///\n    /// # Returns\n    ///\n    /// A vector of references to `FileInfo` for files larger than the specified size\n    pub fn files_larger_than(\u0026self, size: u64) -\u003e Vec\u003c\u0026FileInfo\u003e {\n        self.file_cache.iter().filter(|f| f.size \u003e size).collect()\n    }\n\n    /// Get files in a specific directory\n    ///\n    /// # Arguments\n    ///\n    /// * `dir` - Directory path (with or without trailing slash)\n    ///\n    /// # Returns\n    ///\n    /// A vector of references to `FileInfo` for files in the specified directory\n    pub fn files_in_directory(\u0026self, dir: \u0026str) -\u003e Vec\u003c\u0026FileInfo\u003e {\n        let dir_path = if dir.ends_with('/') {\n            dir.to_string()\n        } else {\n            format!(\"{}/\", dir)\n        };\n\n        self.file_cache\n            .iter()\n            .filter(|f| f.path.starts_with(\u0026dir_path) || f.path.starts_with(dir))\n            .collect()\n    }\n\n    /// Get all files in the repository\n    ///\n    /// # Returns\n    ///\n    /// A slice of all `FileInfo` entries\n    #[allow(dead_code)]\n    pub fn all_files(\u0026self) -\u003e \u0026[FileInfo] {\n        \u0026self.file_cache\n    }\n}\n\n/// Simple glob matching\nfn glob_match(pattern: \u0026str, text: \u0026str) -\u003e bool {\n    if pattern == \"*\" {\n        return true;\n    }\n\n    if pattern.starts_with(\"*.\") {\n        let ext = \u0026pattern[1..];\n        return text.ends_with(ext);\n    }\n\n    if pattern.contains(\"**\") {\n        let parts: Vec\u003c\u0026str\u003e = pattern.split(\"**\").collect();\n        if parts.len() == 2 {\n            let prefix = parts[0].trim_end_matches('/');\n            let suffix = parts[1].trim_start_matches('/');\n\n            if !prefix.is_empty() \u0026\u0026 !text.starts_with(prefix) {\n                return false;\n            }\n            if !suffix.is_empty() {\n                return text.ends_with(suffix) || text.contains(\u0026format!(\"/{}\", suffix));\n            }\n            return true;\n        }\n    }\n\n    text.contains(pattern.trim_start_matches('*').trim_end_matches('*'))\n}\n","traces":[{"line":33,"address":[1064196,1064000],"length":1,"stats":{"Line":2}},{"line":34,"address":[1064091,1064025],"length":1,"stats":{"Line":5}},{"line":47,"address":[1064224],"length":1,"stats":{"Line":3}},{"line":49,"address":[1064254],"length":1,"stats":{"Line":3}},{"line":50,"address":[1064341],"length":1,"stats":{"Line":0}},{"line":54,"address":[1064384],"length":1,"stats":{"Line":2}},{"line":56,"address":[775598,775584],"length":1,"stats":{"Line":4}},{"line":57,"address":[775616,775638],"length":1,"stats":{"Line":6}},{"line":58,"address":[775789,775664,775783],"length":1,"stats":{"Line":0}},{"line":60,"address":[1456306],"length":1,"stats":{"Line":0}},{"line":73,"address":[1064464,1064633,1064627],"length":1,"stats":{"Line":3}},{"line":74,"address":[1064493,1064594],"length":1,"stats":{"Line":6}},{"line":86,"address":[1064656,1064913,1064919],"length":1,"stats":{"Line":4}},{"line":87,"address":[1064691],"length":1,"stats":{"Line":4}},{"line":88,"address":[1064801,1064886,1064733],"length":1,"stats":{"Line":9}},{"line":104,"address":[1064944],"length":1,"stats":{"Line":3}},{"line":105,"address":[1064994],"length":1,"stats":{"Line":3}},{"line":117,"address":[1065056],"length":1,"stats":{"Line":3}},{"line":118,"address":[1065108],"length":1,"stats":{"Line":3}},{"line":120,"address":[775808],"length":1,"stats":{"Line":2}},{"line":121,"address":[775829,775859],"length":1,"stats":{"Line":4}},{"line":123,"address":[1456480,1456532,1456512],"length":1,"stats":{"Line":6}},{"line":139,"address":[1065184],"length":1,"stats":{"Line":2}},{"line":140,"address":[431048],"length":1,"stats":{"Line":2}},{"line":142,"address":[776160],"length":1,"stats":{"Line":2}},{"line":143,"address":[776184],"length":1,"stats":{"Line":2}},{"line":144,"address":[776265],"length":1,"stats":{"Line":2}},{"line":146,"address":[776334,776214],"length":1,"stats":{"Line":5}},{"line":161,"address":[1065296],"length":1,"stats":{"Line":2}},{"line":162,"address":[776400,776410],"length":1,"stats":{"Line":6}},{"line":174,"address":[1065789,1065408,1065783],"length":1,"stats":{"Line":3}},{"line":175,"address":[1065448],"length":1,"stats":{"Line":4}},{"line":176,"address":[1065589],"length":1,"stats":{"Line":0}},{"line":178,"address":[1065473],"length":1,"stats":{"Line":4}},{"line":181,"address":[1065687,1065615],"length":1,"stats":{"Line":8}},{"line":183,"address":[1457056,1457079],"length":1,"stats":{"Line":7}},{"line":193,"address":[1065808],"length":1,"stats":{"Line":2}},{"line":194,"address":[1065813],"length":1,"stats":{"Line":2}},{"line":199,"address":[1067019,1065824,1066996],"length":1,"stats":{"Line":2}},{"line":200,"address":[431697],"length":1,"stats":{"Line":2}},{"line":201,"address":[1065938],"length":1,"stats":{"Line":2}},{"line":204,"address":[431722],"length":1,"stats":{"Line":2}},{"line":205,"address":[1065995],"length":1,"stats":{"Line":2}},{"line":206,"address":[431892],"length":1,"stats":{"Line":2}},{"line":209,"address":[1065951],"length":1,"stats":{"Line":2}},{"line":210,"address":[431998],"length":1,"stats":{"Line":2}},{"line":211,"address":[1066314,1066249],"length":1,"stats":{"Line":4}},{"line":212,"address":[1066379,1066320],"length":1,"stats":{"Line":4}},{"line":213,"address":[1066454],"length":1,"stats":{"Line":2}},{"line":215,"address":[1066560,1066647],"length":1,"stats":{"Line":4}},{"line":216,"address":[1066653],"length":1,"stats":{"Line":0}},{"line":218,"address":[1066684,1066616],"length":1,"stats":{"Line":4}},{"line":219,"address":[1066700,1066745],"length":1,"stats":{"Line":0}},{"line":221,"address":[1066731],"length":1,"stats":{"Line":2}},{"line":225,"address":[1066088],"length":1,"stats":{"Line":2}}],"covered":49,"coverable":55},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","utils","mod.rs"],"content":"//! Utility modules for RepoLens\n\npub mod prerequisites;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kdelfour","Workspace","Professionel","Delfour.co","cli--audit-github-project","src","utils","prerequisites.rs"],"content":"//! Prerequisites checking for RepoLens initialization\n//!\n//! This module verifies that required tools and configurations are available\n//! before running RepoLens commands.\n\nuse anyhow::{bail, Context, Result};\nuse colored::Colorize;\nuse std::path::Path;\nuse std::process::Command;\n\n/// Level of importance for a prerequisite check\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum CheckLevel {\n    /// Required for operation - failure blocks execution\n    Required,\n    /// Optional - failure generates a warning\n    Optional,\n}\n\n/// Status of a prerequisite check\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum CheckStatus {\n    /// Check passed successfully\n    Ok,\n    /// Check failed\n    Failed,\n    /// Check was skipped (due to dependency failure)\n    Skipped,\n}\n\n/// Result of a single prerequisite check\n#[derive(Debug, Clone)]\npub struct CheckResult {\n    /// Name of the check\n    pub name: String,\n    /// Whether this check is required or optional\n    pub level: CheckLevel,\n    /// Status of the check\n    pub status: CheckStatus,\n    /// Human-readable message (shown on failure)\n    pub message: Option\u003cString\u003e,\n    /// Suggested fix for the issue\n    pub fix: Option\u003cString\u003e,\n}\n\nimpl CheckResult {\n    /// Create a successful check result\n    pub fn ok(name: \u0026str, level: CheckLevel) -\u003e Self {\n        Self {\n            name: name.to_string(),\n            level,\n            status: CheckStatus::Ok,\n            message: None,\n            fix: None,\n        }\n    }\n\n    /// Create a failed check result\n    pub fn failed(name: \u0026str, level: CheckLevel, message: \u0026str, fix: Option\u003c\u0026str\u003e) -\u003e Self {\n        Self {\n            name: name.to_string(),\n            level,\n            status: CheckStatus::Failed,\n            message: Some(message.to_string()),\n            fix: fix.map(|s| s.to_string()),\n        }\n    }\n\n    /// Create a skipped check result\n    pub fn skipped(name: \u0026str, level: CheckLevel) -\u003e Self {\n        Self {\n            name: name.to_string(),\n            level,\n            status: CheckStatus::Skipped,\n            message: None,\n            fix: None,\n        }\n    }\n\n    /// Check if this result represents a failure\n    #[allow(dead_code)]\n    pub fn is_failed(\u0026self) -\u003e bool {\n        self.status == CheckStatus::Failed\n    }\n\n    /// Check if this is a required check that failed\n    pub fn is_required_failure(\u0026self) -\u003e bool {\n        self.level == CheckLevel::Required \u0026\u0026 self.status == CheckStatus::Failed\n    }\n\n    /// Check if this is an optional check that failed\n    pub fn is_optional_failure(\u0026self) -\u003e bool {\n        self.level == CheckLevel::Optional \u0026\u0026 self.status == CheckStatus::Failed\n    }\n}\n\n/// Aggregated report of all prerequisite checks\n#[derive(Debug, Clone)]\npub struct PrerequisitesReport {\n    /// All check results\n    pub checks: Vec\u003cCheckResult\u003e,\n}\n\nimpl PrerequisitesReport {\n    /// Create a new empty report\n    pub fn new() -\u003e Self {\n        Self { checks: Vec::new() }\n    }\n\n    /// Add a check result to the report\n    pub fn add(\u0026mut self, result: CheckResult) {\n        self.checks.push(result);\n    }\n\n    /// Check if all required checks passed\n    pub fn all_required_passed(\u0026self) -\u003e bool {\n        !self.checks.iter().any(|c| c.is_required_failure())\n    }\n\n    /// Get all failed required checks\n    pub fn required_failures(\u0026self) -\u003e Vec\u003c\u0026CheckResult\u003e {\n        self.checks\n            .iter()\n            .filter(|c| c.is_required_failure())\n            .collect()\n    }\n\n    /// Get all failed optional checks (warnings)\n    pub fn optional_failures(\u0026self) -\u003e Vec\u003c\u0026CheckResult\u003e {\n        self.checks\n            .iter()\n            .filter(|c| c.is_optional_failure())\n            .collect()\n    }\n\n    /// Check if there are any warnings\n    pub fn has_warnings(\u0026self) -\u003e bool {\n        self.checks.iter().any(|c| c.is_optional_failure())\n    }\n}\n\nimpl Default for PrerequisitesReport {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n// ============================================================================\n// Check functions\n// ============================================================================\n\n/// Check if git is installed\npub fn check_git_installed() -\u003e CheckResult {\n    let output = Command::new(\"git\").arg(\"--version\").output();\n\n    match output {\n        Ok(o) if o.status.success() =\u003e CheckResult::ok(\"Git installed\", CheckLevel::Required),\n        _ =\u003e CheckResult::failed(\n            \"Git installed\",\n            CheckLevel::Required,\n            \"Git is not installed\",\n            Some(\"Install git: https://git-scm.com/downloads\"),\n        ),\n    }\n}\n\n/// Check if the current directory is a git repository\npub fn check_is_git_repo(root: \u0026Path) -\u003e CheckResult {\n    let git_dir = root.join(\".git\");\n\n    if git_dir.exists() {\n        CheckResult::ok(\"Git repository\", CheckLevel::Required)\n    } else {\n        CheckResult::failed(\n            \"Git repository\",\n            CheckLevel::Required,\n            \"Not a git repository\",\n            Some(\"Run: git init\"),\n        )\n    }\n}\n\n/// Check if GitHub CLI (gh) is installed\npub fn check_gh_installed() -\u003e CheckResult {\n    let output = Command::new(\"gh\").arg(\"--version\").output();\n\n    match output {\n        Ok(o) if o.status.success() =\u003e {\n            CheckResult::ok(\"GitHub CLI installed\", CheckLevel::Required)\n        }\n        _ =\u003e CheckResult::failed(\n            \"GitHub CLI installed\",\n            CheckLevel::Required,\n            \"GitHub CLI (gh) is not installed\",\n            Some(\"Install gh: https://cli.github.com/\"),\n        ),\n    }\n}\n\n/// Check if GitHub CLI is authenticated\npub fn check_gh_authenticated() -\u003e CheckResult {\n    let output = Command::new(\"gh\").args([\"auth\", \"status\"]).output();\n\n    match output {\n        Ok(o) if o.status.success() =\u003e {\n            CheckResult::ok(\"GitHub CLI authenticated\", CheckLevel::Required)\n        }\n        _ =\u003e CheckResult::failed(\n            \"GitHub CLI authenticated\",\n            CheckLevel::Required,\n            \"GitHub CLI is not authenticated\",\n            Some(\"Run: gh auth login\"),\n        ),\n    }\n}\n\n/// Check if a remote origin is configured\npub fn check_remote_origin(root: \u0026Path) -\u003e CheckResult {\n    let output = Command::new(\"git\")\n        .args([\"remote\", \"get-url\", \"origin\"])\n        .current_dir(root)\n        .output();\n\n    match output {\n        Ok(o) if o.status.success() =\u003e {\n            CheckResult::ok(\"Remote origin configured\", CheckLevel::Optional)\n        }\n        _ =\u003e CheckResult::failed(\n            \"Remote origin configured\",\n            CheckLevel::Optional,\n            \"No remote origin configured\",\n            Some(\"Run: git remote add origin \u003curl\u003e\"),\n        ),\n    }\n}\n\n/// Check if the remote origin is a GitHub repository\npub fn check_remote_is_github(root: \u0026Path) -\u003e CheckResult {\n    let output = Command::new(\"git\")\n        .args([\"remote\", \"get-url\", \"origin\"])\n        .current_dir(root)\n        .output();\n\n    match output {\n        Ok(o) if o.status.success() =\u003e {\n            let url = String::from_utf8_lossy(\u0026o.stdout);\n            if url.contains(\"github.com\") {\n                CheckResult::ok(\"Remote is GitHub\", CheckLevel::Optional)\n            } else {\n                CheckResult::failed(\n                    \"Remote is GitHub\",\n                    CheckLevel::Optional,\n                    \"Remote origin is not a GitHub repository\",\n                    Some(\"RepoLens works best with GitHub repositories\"),\n                )\n            }\n        }\n        _ =\u003e CheckResult::skipped(\"Remote is GitHub\", CheckLevel::Optional),\n    }\n}\n\n// ============================================================================\n// Run all checks\n// ============================================================================\n\n/// Options for running prerequisite checks\n#[derive(Debug, Clone, Default)]\npub struct CheckOptions {\n    /// Skip optional checks\n    #[allow(dead_code)]\n    pub skip_optional: bool,\n}\n\n/// Run all prerequisite checks\npub fn run_all_checks(root: \u0026Path, _options: \u0026CheckOptions) -\u003e PrerequisitesReport {\n    let mut report = PrerequisitesReport::new();\n\n    // Required checks\n    let git_installed = check_git_installed();\n    let git_ok = git_installed.status == CheckStatus::Ok;\n    report.add(git_installed);\n\n    if git_ok {\n        report.add(check_is_git_repo(root));\n    } else {\n        report.add(CheckResult::skipped(\"Git repository\", CheckLevel::Required));\n    }\n\n    let gh_installed = check_gh_installed();\n    let gh_ok = gh_installed.status == CheckStatus::Ok;\n    report.add(gh_installed);\n\n    if gh_ok {\n        report.add(check_gh_authenticated());\n    } else {\n        report.add(CheckResult::skipped(\n            \"GitHub CLI authenticated\",\n            CheckLevel::Required,\n        ));\n    }\n\n    // Optional checks (only if git repo exists)\n    let is_repo = report\n        .checks\n        .iter()\n        .find(|c| c.name == \"Git repository\")\n        .map(|c| c.status == CheckStatus::Ok)\n        .unwrap_or(false);\n\n    if is_repo {\n        let remote_result = check_remote_origin(root);\n        let has_remote = remote_result.status == CheckStatus::Ok;\n        report.add(remote_result);\n\n        if has_remote {\n            report.add(check_remote_is_github(root));\n        } else {\n            report.add(CheckResult::skipped(\n                \"Remote is GitHub\",\n                CheckLevel::Optional,\n            ));\n        }\n    } else {\n        report.add(CheckResult::skipped(\n            \"Remote origin configured\",\n            CheckLevel::Optional,\n        ));\n        report.add(CheckResult::skipped(\n            \"Remote is GitHub\",\n            CheckLevel::Optional,\n        ));\n    }\n\n    report\n}\n\n// ============================================================================\n// Display functions\n// ============================================================================\n\n/// Display the full prerequisites report\npub fn display_report(report: \u0026PrerequisitesReport, _verbose: bool) {\n    println!(\"{}\\n\", \"Checking prerequisites...\".bold());\n\n    for check in \u0026report.checks {\n        let icon = match check.status {\n            CheckStatus::Ok =\u003e \"‚úì\".green(),\n            CheckStatus::Failed if check.level == CheckLevel::Required =\u003e \"‚úó\".red(),\n            CheckStatus::Failed =\u003e \"!\".yellow(),\n            CheckStatus::Skipped =\u003e \"‚óã\".dimmed(),\n        };\n\n        let name = match check.status {\n            CheckStatus::Ok =\u003e check.name.normal(),\n            CheckStatus::Failed if check.level == CheckLevel::Required =\u003e check.name.red(),\n            CheckStatus::Failed =\u003e check.name.yellow(),\n            CheckStatus::Skipped =\u003e check.name.dimmed(),\n        };\n\n        let suffix = match check.status {\n            CheckStatus::Skipped =\u003e \" (skipped)\".dimmed().to_string(),\n            CheckStatus::Failed if check.level == CheckLevel::Optional =\u003e {\n                \" (optional)\".dimmed().to_string()\n            }\n            _ =\u003e String::new(),\n        };\n\n        println!(\"  {} {}{}\", icon, name, suffix);\n\n        // Show message and fix for failures\n        if check.status == CheckStatus::Failed {\n            if let Some(msg) = \u0026check.message {\n                println!(\"    {}\", msg.dimmed());\n            }\n            if let Some(fix) = \u0026check.fix {\n                println!(\"    {}: {}\", \"Fix\".cyan(), fix);\n            }\n        }\n    }\n\n    println!();\n}\n\n/// Display error summary for failed required checks\npub fn display_error_summary(report: \u0026PrerequisitesReport) {\n    let failures = report.required_failures();\n    if failures.is_empty() {\n        return;\n    }\n\n    eprintln!(\n        \"{} {} required prerequisite(s) failed:\",\n        \"Error:\".red().bold(),\n        failures.len()\n    );\n\n    for check in failures {\n        eprintln!(\"  {} {}\", \"‚Ä¢\".red(), check.name);\n        if let Some(fix) = \u0026check.fix {\n            eprintln!(\"    {}: {}\", \"Fix\".cyan(), fix);\n        }\n    }\n}\n\n/// Display warnings for failed optional checks\npub fn display_warnings(report: \u0026PrerequisitesReport) {\n    let warnings = report.optional_failures();\n    if warnings.is_empty() {\n        return;\n    }\n\n    println!(\n        \"{} {} optional check(s) failed:\",\n        \"Warning:\".yellow().bold(),\n        warnings.len()\n    );\n\n    for check in warnings {\n        if let Some(msg) = \u0026check.message {\n            println!(\"  {} {}\", \"‚Ä¢\".yellow(), msg);\n        }\n    }\n\n    println!();\n}\n\n// ============================================================================\n// Centralized utility functions (used by other modules)\n// ============================================================================\n\n/// Check if gh CLI is available and authenticated\npub fn is_gh_available() -\u003e bool {\n    Command::new(\"gh\")\n        .args([\"auth\", \"status\"])\n        .output()\n        .map(|o| o.status.success())\n        .unwrap_or(false)\n}\n\n/// Get repository info (owner/name) from GitHub CLI\npub fn get_repo_info() -\u003e Result\u003cString\u003e {\n    let output = Command::new(\"gh\")\n        .args([\n            \"repo\",\n            \"view\",\n            \"--json\",\n            \"nameWithOwner\",\n            \"-q\",\n            \".nameWithOwner\",\n        ])\n        .output()\n        .context(\"Failed to get repository info\")?;\n\n    if !output.status.success() {\n        bail!(\"Failed to get repository info. Make sure you're in a git repository.\");\n    }\n\n    Ok(String::from_utf8_lossy(\u0026output.stdout).trim().to_string())\n}\n","traces":[{"line":48,"address":[866208],"length":1,"stats":{"Line":0}},{"line":50,"address":[1176474],"length":1,"stats":{"Line":0}},{"line":59,"address":[866416,866843,866849],"length":1,"stats":{"Line":0}},{"line":61,"address":[866539],"length":1,"stats":{"Line":0}},{"line":64,"address":[866586,866641],"length":1,"stats":{"Line":0}},{"line":65,"address":[866675],"length":1,"stats":{"Line":0}},{"line":70,"address":[1177088],"length":1,"stats":{"Line":0}},{"line":72,"address":[866906],"length":1,"stats":{"Line":0}},{"line":82,"address":[867072],"length":1,"stats":{"Line":0}},{"line":83,"address":[867077],"length":1,"stats":{"Line":0}},{"line":87,"address":[867104],"length":1,"stats":{"Line":0}},{"line":88,"address":[867117],"length":1,"stats":{"Line":0}},{"line":92,"address":[867184],"length":1,"stats":{"Line":0}},{"line":93,"address":[867197],"length":1,"stats":{"Line":0}},{"line":106,"address":[867264],"length":1,"stats":{"Line":0}},{"line":107,"address":[867277],"length":1,"stats":{"Line":0}},{"line":111,"address":[867328],"length":1,"stats":{"Line":0}},{"line":112,"address":[867333],"length":1,"stats":{"Line":0}},{"line":116,"address":[867360],"length":1,"stats":{"Line":0}},{"line":117,"address":[867369],"length":1,"stats":{"Line":0}},{"line":121,"address":[867424],"length":1,"stats":{"Line":0}},{"line":122,"address":[867456],"length":1,"stats":{"Line":0}},{"line":124,"address":[978800,978814],"length":1,"stats":{"Line":0}},{"line":129,"address":[867520],"length":1,"stats":{"Line":0}},{"line":130,"address":[867552],"length":1,"stats":{"Line":0}},{"line":132,"address":[922000,922014],"length":1,"stats":{"Line":0}},{"line":137,"address":[867616],"length":1,"stats":{"Line":0}},{"line":138,"address":[1177849],"length":1,"stats":{"Line":0}},{"line":143,"address":[867680],"length":1,"stats":{"Line":0}},{"line":144,"address":[867688],"length":1,"stats":{"Line":0}},{"line":153,"address":[867712,868318,868405],"length":1,"stats":{"Line":0}},{"line":154,"address":[867729],"length":1,"stats":{"Line":0}},{"line":156,"address":[1178166],"length":1,"stats":{"Line":0}},{"line":157,"address":[868090],"length":1,"stats":{"Line":0}},{"line":160,"address":[867981],"length":1,"stats":{"Line":0}},{"line":162,"address":[867989],"length":1,"stats":{"Line":0}},{"line":168,"address":[868432,868744,868738],"length":1,"stats":{"Line":0}},{"line":169,"address":[868462],"length":1,"stats":{"Line":0}},{"line":171,"address":[868499,868567],"length":1,"stats":{"Line":0}},{"line":172,"address":[868681,868736],"length":1,"stats":{"Line":0}},{"line":176,"address":[1178817],"length":1,"stats":{"Line":0}},{"line":178,"address":[868598],"length":1,"stats":{"Line":0}},{"line":184,"address":[868768,869461,869374],"length":1,"stats":{"Line":0}},{"line":185,"address":[1179009],"length":1,"stats":{"Line":0}},{"line":187,"address":[868998],"length":1,"stats":{"Line":0}},{"line":188,"address":[1179370],"length":1,"stats":{"Line":0}},{"line":189,"address":[869248],"length":1,"stats":{"Line":0}},{"line":193,"address":[869037],"length":1,"stats":{"Line":0}},{"line":195,"address":[869045],"length":1,"stats":{"Line":0}},{"line":201,"address":[870144,869488,870231],"length":1,"stats":{"Line":0}},{"line":202,"address":[869505],"length":1,"stats":{"Line":0}},{"line":204,"address":[869768],"length":1,"stats":{"Line":0}},{"line":205,"address":[869916],"length":1,"stats":{"Line":0}},{"line":206,"address":[870018],"length":1,"stats":{"Line":0}},{"line":210,"address":[869807],"length":1,"stats":{"Line":0}},{"line":212,"address":[869815],"length":1,"stats":{"Line":0}},{"line":218,"address":[871094,871007,870256],"length":1,"stats":{"Line":0}},{"line":219,"address":[870502,870431,870299],"length":1,"stats":{"Line":0}},{"line":220,"address":[1180566],"length":1,"stats":{"Line":0}},{"line":224,"address":[870625],"length":1,"stats":{"Line":0}},{"line":225,"address":[1180997],"length":1,"stats":{"Line":0}},{"line":226,"address":[870881],"length":1,"stats":{"Line":0}},{"line":230,"address":[870664],"length":1,"stats":{"Line":0}},{"line":232,"address":[870672],"length":1,"stats":{"Line":0}},{"line":238,"address":[871120,872199,872112],"length":1,"stats":{"Line":0}},{"line":239,"address":[871295,871366,871163],"length":1,"stats":{"Line":0}},{"line":240,"address":[1181430],"length":1,"stats":{"Line":0}},{"line":244,"address":[871489],"length":1,"stats":{"Line":0}},{"line":245,"address":[1181795],"length":1,"stats":{"Line":0}},{"line":246,"address":[871756,871677],"length":1,"stats":{"Line":0}},{"line":247,"address":[871855,871775],"length":1,"stats":{"Line":0}},{"line":248,"address":[872059,872003],"length":1,"stats":{"Line":0}},{"line":252,"address":[871897],"length":1,"stats":{"Line":0}},{"line":254,"address":[871905],"length":1,"stats":{"Line":0}},{"line":258,"address":[872118,871528],"length":1,"stats":{"Line":0}},{"line":275,"address":[873713,873752,872224],"length":1,"stats":{"Line":0}},{"line":276,"address":[872275],"length":1,"stats":{"Line":0}},{"line":279,"address":[872314],"length":1,"stats":{"Line":0}},{"line":280,"address":[872434,872358],"length":1,"stats":{"Line":0}},{"line":281,"address":[1182667],"length":1,"stats":{"Line":0}},{"line":283,"address":[872552],"length":1,"stats":{"Line":0}},{"line":284,"address":[872676,872619],"length":1,"stats":{"Line":0}},{"line":286,"address":[1182782,1182863],"length":1,"stats":{"Line":0}},{"line":289,"address":[1182880],"length":1,"stats":{"Line":0}},{"line":290,"address":[872764,872685],"length":1,"stats":{"Line":0}},{"line":291,"address":[1182997],"length":1,"stats":{"Line":0}},{"line":293,"address":[1183109],"length":1,"stats":{"Line":0}},{"line":294,"address":[1183230,1183166],"length":1,"stats":{"Line":0}},{"line":296,"address":[872899,872962],"length":1,"stats":{"Line":0}},{"line":298,"address":[872891],"length":1,"stats":{"Line":0}},{"line":303,"address":[1183249,1183200],"length":1,"stats":{"Line":0}},{"line":306,"address":[922080,922094],"length":1,"stats":{"Line":0}},{"line":307,"address":[978960,978969],"length":1,"stats":{"Line":0}},{"line":310,"address":[873668,873144],"length":1,"stats":{"Line":0}},{"line":311,"address":[873364,873209],"length":1,"stats":{"Line":0}},{"line":312,"address":[873372,873443],"length":1,"stats":{"Line":0}},{"line":313,"address":[1183676],"length":1,"stats":{"Line":0}},{"line":315,"address":[1183788],"length":1,"stats":{"Line":0}},{"line":316,"address":[873686,873631],"length":1,"stats":{"Line":0}},{"line":318,"address":[873578,873651],"length":1,"stats":{"Line":0}},{"line":320,"address":[1183794],"length":1,"stats":{"Line":0}},{"line":324,"address":[873232,873156],"length":1,"stats":{"Line":0}},{"line":326,"address":[1183372],"length":1,"stats":{"Line":0}},{"line":328,"address":[873247],"length":1,"stats":{"Line":0}},{"line":330,"address":[1183463],"length":1,"stats":{"Line":0}},{"line":334,"address":[1183538],"length":1,"stats":{"Line":0}},{"line":342,"address":[1184000,1186221,1185245],"length":1,"stats":{"Line":0}},{"line":343,"address":[873811],"length":1,"stats":{"Line":0}},{"line":345,"address":[874031,874010],"length":1,"stats":{"Line":0}},{"line":346,"address":[1184331],"length":1,"stats":{"Line":0}},{"line":347,"address":[1184413],"length":1,"stats":{"Line":0}},{"line":348,"address":[1184449,1184564],"length":1,"stats":{"Line":0}},{"line":349,"address":[1184536],"length":1,"stats":{"Line":0}},{"line":350,"address":[1184471],"length":1,"stats":{"Line":0}},{"line":353,"address":[874281],"length":1,"stats":{"Line":0}},{"line":354,"address":[1184732,1184600],"length":1,"stats":{"Line":0}},{"line":355,"address":[1184907,1184625,1184846,1184807],"length":1,"stats":{"Line":0}},{"line":356,"address":[874649,874597],"length":1,"stats":{"Line":0}},{"line":357,"address":[874717,874434],"length":1,"stats":{"Line":0}},{"line":360,"address":[1184761],"length":1,"stats":{"Line":0}},{"line":361,"address":[1184995,1185267],"length":1,"stats":{"Line":0}},{"line":362,"address":[1184973,1185095],"length":1,"stats":{"Line":0}},{"line":363,"address":[1185101],"length":1,"stats":{"Line":0}},{"line":365,"address":[874813,875113],"length":1,"stats":{"Line":0}},{"line":368,"address":[874991,875159],"length":1,"stats":{"Line":0}},{"line":371,"address":[1185546],"length":1,"stats":{"Line":0}},{"line":372,"address":[875384],"length":1,"stats":{"Line":0}},{"line":373,"address":[875530,875442],"length":1,"stats":{"Line":0}},{"line":375,"address":[875715,875467],"length":1,"stats":{"Line":0}},{"line":376,"address":[1185947],"length":1,"stats":{"Line":0}},{"line":381,"address":[874144],"length":1,"stats":{"Line":0}},{"line":385,"address":[876016,877249,877255],"length":1,"stats":{"Line":0}},{"line":386,"address":[1186258],"length":1,"stats":{"Line":0}},{"line":387,"address":[1186294,1186350],"length":1,"stats":{"Line":0}},{"line":391,"address":[1186513],"length":1,"stats":{"Line":0}},{"line":397,"address":[1186663,1186849],"length":1,"stats":{"Line":0}},{"line":398,"address":[876747,876685],"length":1,"stats":{"Line":0}},{"line":399,"address":[1187175],"length":1,"stats":{"Line":0}},{"line":400,"address":[877013],"length":1,"stats":{"Line":0}},{"line":406,"address":[1188541,1187504,1188535],"length":1,"stats":{"Line":0}},{"line":407,"address":[877298],"length":1,"stats":{"Line":0}},{"line":408,"address":[877334,877390],"length":1,"stats":{"Line":0}},{"line":412,"address":[877553],"length":1,"stats":{"Line":0}},{"line":418,"address":[877883,877697],"length":1,"stats":{"Line":0}},{"line":419,"address":[877938,878067],"length":1,"stats":{"Line":0}},{"line":420,"address":[878075],"length":1,"stats":{"Line":0}},{"line":424,"address":[878002],"length":1,"stats":{"Line":0}},{"line":432,"address":[878352,878584,878590],"length":1,"stats":{"Line":0}},{"line":433,"address":[878453,878508,878359],"length":1,"stats":{"Line":0}},{"line":434,"address":[1188615],"length":1,"stats":{"Line":0}},{"line":436,"address":[979001,978992],"length":1,"stats":{"Line":0}},{"line":441,"address":[878608,879632,879626],"length":1,"stats":{"Line":0}},{"line":442,"address":[878891,878830,879026,878625],"length":1,"stats":{"Line":0}},{"line":443,"address":[878660],"length":1,"stats":{"Line":0}},{"line":454,"address":[879221],"length":1,"stats":{"Line":0}},{"line":455,"address":[879310,879250],"length":1,"stats":{"Line":0}},{"line":458,"address":[879276,879390,879482],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":157}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, 'üåô'),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      const nbHit = covered? trace.stats.Line: 0;
      return e(
        'div',
        { className: 'code-text-container' },
        e(
          'code',
          {
            className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          },
          line
        ),
        e(
          'div',
          { className: 'cover-indicator' + (covered? ' check-cover': '') + (uncovered? ' no-cover': '')},
          e(
            'div',
            { className: (covered? 'stat-line-hit': '')},
            covered? nbHit: ""
          )
        )
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = 'üåô';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '‚òÄÔ∏è';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = 'üåô';
    }
  });
})();
</script>
</body>
</html>